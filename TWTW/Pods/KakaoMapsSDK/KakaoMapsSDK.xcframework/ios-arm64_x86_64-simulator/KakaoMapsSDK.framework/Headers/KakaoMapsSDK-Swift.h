#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
#ifndef KAKAOMAPSSDK_SWIFT_H
#define KAKAOMAPSSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreFoundation;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#import <KakaoMapsSDK/KakaoMapsSDK.h>

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="KakaoMapsSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

/// Poi 의 애니메이션 효과 지정 인터페이스
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK18PoiAnimationEffect_")
@protocol PoiAnimationEffect
/// 애니메이션 종료시 해당 poi를 숨길지 여부
@property (nonatomic) BOOL hideAtStop;
/// 애니메이션 종료시 해당 poi를 제거할지 여부
@property (nonatomic) BOOL removeAtStop;
@end


/// 키프레임으로 구성되는 애니메이션 효과
SWIFT_CLASS("_TtC12KakaoMapsSDK23KeyFrameAnimationEffect")
@interface KeyFrameAnimationEffect : NSObject <PoiAnimationEffect>
/// Initializer
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// 애니메이션 종료 시 애니메이터에 속한 객체들을 숨길지에 대한 여부.
/// true로 설정하면 애니메이션이 종료되면 객체들이 화면에서 자동으로 사라진다.
@property (nonatomic) BOOL hideAtStop;
/// 애니메이션 종료 시 애니메이터에 속한 객체들을 제거할지에 대한 여부.
/// true로 설정하면 애니메이션이 종료되면 객체들이 제거된다.
@property (nonatomic) BOOL removeAtStop;
/// 애니메이션 종료 후 초기상태로 원복 여부.
@property (nonatomic) BOOL resetToInitialState;
@end

@class AlphaAnimationKeyFrame;

/// AnimationEffect중 Animation 시간동안 지정된 Keyframe 에 따라 회전 변환을 수행하는 애니메이션 효과.
/// Poi에 적용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK20AlphaAnimationEffect")
@interface AlphaAnimationEffect : KeyFrameAnimationEffect
/// Initializer
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// 애니메이션 키프레임을 추가한다.
/// \param frame 추가할 키프레임.
///
- (void)addKeyframe:(AlphaAnimationKeyFrame * _Nonnull)frame;
@end


/// 키프레임 애니메이션을 구성하기 위한 keyframe
SWIFT_CLASS("_TtC12KakaoMapsSDK17AnimationKeyFrame")
@interface AnimationKeyFrame : NSObject
/// 애니메이션 지속 시간, 프레임 보간방법 지정
@property (nonatomic) struct AnimationInterpolation interpolation;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// AlphaAnimation 을 구성하기 위해 하나의 keyframe을 구성하기 위한 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK22AlphaAnimationKeyFrame")
@interface AlphaAnimationKeyFrame : AnimationKeyFrame
/// Initializer
/// \param alpha 투명도 값. 0.0~1.0
///
/// \param interpolation 프레임 시간, 보간 방법.
///
- (nonnull instancetype)initWithAlpha:(float)alpha interpolation:(struct AnimationInterpolation)interpolation OBJC_DESIGNATED_INITIALIZER;
/// 투명도 값. 0.0~1.0
@property (nonatomic) float alpha;
@end


@class NSString;

/// Animator protocol
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK8Animator_")
@protocol Animator
/// 애니메이션 시작
- (void)start;
/// 애니메이션 정지
- (void)stop;
/// 애니메이션 정지 콜백 지정
- (void)setStopCallback:(void (^ _Nullable)(id <Animator> _Nullable))callback;
/// 애니메이터 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull animatorID;
/// 애니메이션 시작 여부
@property (nonatomic, readonly) BOOL isStart;
@end

@class MapPoint;

/// 지도상의 사각형 범위를 나타내는 클래스. 서남쪽, 북동쪽 좌표를 각각 좌하단, 우상단으로 하는 정방형 범위를 의미한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8AreaRect")
@interface AreaRect : NSObject
/// Initializer
/// \param southWest 서남쪽 MapPoint
///
/// \param northEast 동북쪽 MapPoint
///
- (nonnull instancetype)initWithSouthWest:(MapPoint * _Nonnull)southWest northEast:(MapPoint * _Nonnull)northEast OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param points AreaRect의 범위에 포함되어야 할 MapPoint들
///
- (nonnull instancetype)initWithPoints:(NSArray<MapPoint *> * _Nonnull)points OBJC_DESIGNATED_INITIALIZER;
/// 두 AreaRect의 범위를 합친 AreaRect를 구한다.
/// \param rect1 첫 번째 AreaRect
///
/// \param rect2 두 번째 AreaRect
///
///
/// returns:
/// 두 AreaRect의 범위를 합친 새 AreaRect
+ (AreaRect * _Nonnull)union:(AreaRect * _Nonnull)rect1 :(AreaRect * _Nonnull)rect2 SWIFT_WARN_UNUSED_RESULT;
/// AreaRect의 중심점
///
/// returns:
/// AreaRect의 중심점
- (MapPoint * _Nonnull)center SWIFT_WARN_UNUSED_RESULT;
/// AreaRect의 서남쪽 포인트
@property (nonatomic, strong) MapPoint * _Nonnull southWest;
/// AreaRect의 동북쪽 포인트
@property (nonatomic, strong) MapPoint * _Nonnull northEast;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 카메라 위치를 지정하기 위한 클래스. 사용편의를 위해 카메라의 좌표가 아니라 카메라 시야범위의 중심점 위치 및 각도로 표현한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK14CameraPosition")
@interface CameraPosition : NSObject <NSCopying>
/// Initializer
/// \param target 카메라가 바라보는 지점의 MapPoint
///
/// \param height 카메라 높이(m)
///
/// \param rotation 카메라 회전각 (radian, 정북기준 시계방향)
///
/// \param tilt 카메라 기울임각 (radian, 수직방향 기준)
///
- (nonnull instancetype)initWithTarget:(MapPoint * _Nonnull)target height:(double)height rotation:(double)rotation tilt:(double)tilt OBJC_DESIGNATED_INITIALIZER;
/// 객체 복사를 위한 함수
/// \param zone zone
///
///
/// returns:
/// new copied object
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// 카메라가 바라보는 지점에 대한 MapPoint
@property (nonatomic, readonly, strong) MapPoint * _Nonnull targetPoint;
/// 카메라 높이(m)
@property (nonatomic, readonly) double height;
/// 카메라 회전각(radian, 정북기준 시계방향)
@property (nonatomic, readonly) double rotation;
/// 카메라 기울임각(radian, 수직방향 기준)
@property (nonatomic, readonly) double tilt;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 카메라의 위치 및 각도 변화량을 지정하는 클래스. 카메라가 이동할 위치나 각도를 지정하는 것이 아니라, 얼마나 이동할지(ex. 10도씩 시계방향으로 회전)를 지정하고자 할 때 사용한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK15CameraTransform")
@interface CameraTransform : NSObject <NSCopying>
/// Initializer
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Initializer.
/// \param deltaPos 카메라가 바라보는 위치 변화량
///
/// \param deltaHeight 카메라 높이 변화량
///
/// \param deltaRotation 카메라 회전각 변화량
///
/// \param deltaTilt 카메라 기울임각 변화량
///
- (nonnull instancetype)initWithDeltaPos:(struct CameraTransformDelta)deltaPos deltaHeight:(double)deltaHeight deltaRotation:(double)deltaRotation deltaTilt:(double)deltaTilt OBJC_DESIGNATED_INITIALIZER;
/// 객체 복사를 위한 함수.
/// \param zone zone
///
///
/// returns:
/// new copied object
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// 카메라가 바라보는 위치 변화량.
@property (nonatomic) struct CameraTransformDelta deltaPos;
/// 카메라 높이 변화량
@property (nonatomic) double deltaHeight;
/// 카메라의 회전각 변화량
@property (nonatomic) double deltaRotation;
/// 카메라 기울임각 변화량을 지정
@property (nonatomic) double deltaTilt;
@end

@class KakaoMap;

/// 카메라의 위치 및 각도를 조작하기 위한 클래스.
SWIFT_CLASS("_TtC12KakaoMapsSDK12CameraUpdate")
@interface CameraUpdate : NSObject
/// KakaoMap의 현재 카메라 위치 및 각도로 CameraUpdate를 생성한다.
/// \param mapView KakaoMap객체
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithMapView:(KakaoMap * _Nonnull)mapView SWIFT_WARN_UNUSED_RESULT;
/// CameraPosition으로 지정된 위치로 이동하는 CameraUpdate를 생성한다.
/// \param cameraPosition 카메라 위치 및 각도를 지정한 CameraPosition
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithCameraPosition:(CameraPosition * _Nonnull)cameraPosition SWIFT_WARN_UNUSED_RESULT;
/// AreaRect로 지정된 범위가 화면에 최대한 가득 차게 보이도록 이동하는 CameraUpdate를 생성한다.
/// \param area 화면에 보일 범위를 지정하는 AreaRect
///
/// \param levelLimit 레벨을 지정하면 카메라가 지정한 레벨까지만 확대되도록 제한함. -1 일 경우 제한하지 않음. 기본값 -1.
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithArea:(AreaRect * _Nonnull)area levelLimit:(NSInteger)levelLimit SWIFT_WARN_UNUSED_RESULT;
/// Target위치를 바라보도록 이동하는 CameraUpdate를 생성한다.
/// \param target 카메라가 바라볼 위치
///
/// \param mapView 이동할 카메라가 속한 KakaoMap
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithTarget:(MapPoint * _Nonnull)target mapView:(KakaoMap * _Nonnull)mapView SWIFT_WARN_UNUSED_RESULT;
/// 카메라 방향을 지정한 각도 및 기울기로 움직이는 CameraUpdate를 생성한다.
/// <ul>
///   <li>
///     retunrs: 생성된 CameraUpdate
///   </li>
/// </ul>
/// \param rotation 카메라 회전각
///
/// \param tilt 카메라 기울임각
///
+ (CameraUpdate * _Nonnull)makeWithRotation:(double)rotation tilt:(double)tilt mapView:(KakaoMap * _Nonnull)mapView SWIFT_WARN_UNUSED_RESULT;
/// target위치를 지정된 줌 레벨에서 바라보도록 이동하는 CameraUpdate를 생성한다.
/// \param target 카메라가 바라볼 위치
///
/// \param zoomLevel 줌 레벨
///
/// \param mapView 이동할 카메라가 속한 KakaoMap
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithTarget:(MapPoint * _Nonnull)target zoomLevel:(NSInteger)zoomLevel mapView:(KakaoMap * _Nonnull)mapView SWIFT_WARN_UNUSED_RESULT;
/// target위치를 지정된 줌 레벨에서 rotation만큼 회전 및 tilt만큼 기울어진 상태로 바라보도록 이동하는 CameraUpdate를 생성한다.
/// \param target 카메라가 바라볼 위치
///
/// \param zoomLevel 줌 레벨
///
/// \param rotation 카메라의 회전 각도
///
/// \param tilt 카메라의 기울어짐 각도
///
/// \param mapView 카메라가 속한 KakaoMap
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithTarget:(MapPoint * _Nonnull)target zoomLevel:(NSInteger)zoomLevel rotation:(double)rotation tilt:(double)tilt mapView:(KakaoMap * _Nonnull)mapView SWIFT_WARN_UNUSED_RESULT;
/// 지정된 줌 레벨로 이동하는 CameraUpdate를 생성한다.
/// <ul>
///   <li>
///     paramter zoomLevel: 줌 레벨
///   </li>
/// </ul>
/// \param mapView 카메라가 속한 KakaoMap
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithZoomLevel:(NSInteger)zoomLevel mapView:(KakaoMap * _Nonnull)mapView SWIFT_WARN_UNUSED_RESULT;
/// 카메라를 현재 위치로부터 transform으로 지정된 만큼 이동하는 CameraUpdate를 생성한다.
/// \param transform 카메라의 이동량
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithTransform:(CameraTransform * _Nonnull)transform SWIFT_WARN_UNUSED_RESULT;
/// CameraUpdate의 종류.
@property (nonatomic, readonly) CameraUpdateType type;
/// 지정된 CameraPosition.  CameraPosition을 이용해 생성되었을 경우에만 유효하다.
@property (nonatomic, readonly, strong) CameraPosition * _Nullable cameraPosition;
/// 지정된 CameraTransform. CameraTransfrom을 이용해 생성되었을 경우에만 유효하다.
@property (nonatomic, readonly, strong) CameraTransform * _Nullable cameraTransform;
/// 지정된 AreaRect. AreaRect를 이용해 생성되었을 경우에만 유효하다.
@property (nonatomic, readonly, strong) AreaRect * _Nullable area;
/// 지정된 확대레벨 제한값
@property (nonatomic, readonly) NSInteger levelLimit;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PolygonStyleSet;
@class MapPolygonShapeOptions;
@class MapPolygonShape;
@class PolygonShapeOptions;
@class PolygonShape;
@class UIColor;
@protocol ShapeAnimationEffect;
@class ShapeAnimator;

/// 지도 뷰 전체를 어둡게 가리는 DimScreen 클래스.
/// KakaoMap에 종속되어 있으며 사용자가 별도로 생성할 수 없다. KakaoMap 인터페이스로 DimScreend의 On/Off가 가능하다.
/// screen에 원하는대로 Shape를 추가하여 특정 부분만 하이라이트 효과를 줄 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK9DimScreen")
@interface DimScreen : NSObject
/// PolygonStyleSet을 추가한다.
/// PolygonShape의 Polygon이 여러개인 경우, Polygon마다 다른 스타일을 설정할 수 있다. 같은 styleID로 추가하더라도 overwrite되지 않는다.
/// seealso:
/// PolygonStyleSet
/// \param styles 추가할 PolygonStyleSet
///
- (void)addPolygonStyleSet:(PolygonStyleSet * _Nonnull)styles;
/// DimScreen에 MapPolygonShape를 추가한다.
/// 중복ID로는 추가할 수 없으며, 기존에 같은 아이디의 Shape가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOption 생성할 MapPolygonShape 옵션
///
/// \param callback MapPolygonShape객체가 생성이 완료됐을 때 호출할 콜백함수(optional)
///
///
/// returns:
/// 생성된 MapPolygonShape 객체
- (MapPolygonShape * _Nullable)addHighlightMapPolygonShape:(MapPolygonShapeOptions * _Nonnull)shapeOption callback:(void (^ _Nullable)(MapPolygonShape * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// DimScreen에 다수의 MapPolygonShape를 추가한다.
/// 중복ID로는 추가할 수 없으며, 기존에 같은 아이디의 Shape가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 MapPolygonShape 옵션 배열
///
/// \param callback MapPolygonShape객체가 모두 생성이 완료됐을 때 호출할 콜백함수(optional)
///
///
/// returns:
/// 생성된 MapPolygonShape 객체 배열
- (NSArray<MapPolygonShape *> * _Nullable)addHighlightMapPolygonShapes:(NSArray<MapPolygonShapeOptions *> * _Nonnull)shapeOptions callback:(void (^ _Nullable)(NSArray<MapPolygonShape *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 DimScreen에 속한 MapPolygonShape를 가져온다.
/// \param shapeID 가져올 MapPolygonShape ID
///
///
/// returns:
/// ID에 해당하는 MapPolygonShape 객체, 없을경우 nil.
- (MapPolygonShape * _Nullable)getHighlightMapPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID SWIFT_WARN_UNUSED_RESULT;
/// 현재 DimScreen에 속한 다수의 MapPolygonShape를 가져온다.
/// \param shapeIDs 가져올 MapPolygonShape ID 배열
///
///
/// returns:
/// ID에 해당하는 MapPolygonShape 객체 배열, 없을경우 nil.
- (NSArray<MapPolygonShape *> * _Nullable)getHighlightMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 DimScreen에 속한 모든 MapPolygonShape를 가져온다.
///
/// returns:
/// 현재 DimScreen에 추가된 MapPolygonShape 배열
- (NSArray<MapPolygonShape *> * _Nullable)getAllHighlightMapPolygonShapes SWIFT_WARN_UNUSED_RESULT;
/// 현재 DimScreen에서 특정 MapPolygonShape를 지운다.
/// \param shapeID DimScreen에서 제거할 MapPolygonShape Id
///
/// \param callback DimScreen에서 해당 Shape제거가 완료되었을 때, 호출할 콜백함수(optional)
///
- (void)removeHighlightMapPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID callback:(void (^ _Nullable)(void))callback;
/// 현재 DimScreen에서 다수의 MapPolygonShape를 지운다.
/// \param shapeID DimScreen에서 제거할 MapPolygonShape Id 배열
///
/// \param callback DimScreen에서 id에 해당하는 모든 shape제거가 완료되었을 때, 호출할 콜백함수(optional)
///
- (void)removeHighlightMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 DimScreen에 속한 특정 MapPolygonShape를 보여준다.
/// \param shapeIDs 보여줄 MapPolygonShape ID 배열
///
- (void)showHighlightMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 DimScreen에 속한 특정 MapPolygonShape를 숨긴다.
/// \param shapeIDs 숨길 MapPolygonShape ID 배열
///
- (void)hideHighlightMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// DimScreen에 PolygonShape를 추가한다.
/// 이미 추가한 ID로 추가할 수 없으며, 이 경우 기존의 객체가 리턴된다.
/// \param shaepOption DimScreen에 추가할 PolygonShapeOptions
///
/// \param callback DimScreen에 객체 추가가 완료되었을 때, 호출할 콜백함수(optional)
///
///
/// returns:
/// 추가된 PolygonShape 객체
- (PolygonShape * _Nullable)addHighlightPolygonShape:(PolygonShapeOptions * _Nonnull)shapeOption callback:(void (^ _Nullable)(PolygonShape * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// DimScreen에 여러개의 PolygonShape를 추가한다.
/// 이미 추가한 ID로 추가할 수 없으며, 이 경우 기존의 객체가 리턴된다.
/// \param shaepOptions DimScreen에 추가할 PolygonShapeOptions 배열
///
/// \param callback DimScreen에 객체 추가가 모두 완료되었을 때, 호출할 콜백함수(optional)
///
///
/// returns:
/// 추가된 PolygonShape 객체 배열
- (NSArray<PolygonShape *> * _Nullable)addHighlightPolygonShapes:(NSArray<PolygonShapeOptions *> * _Nonnull)shapeOptions callback:(void (^ _Nullable)(NSArray<PolygonShape *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// DimScreen에 추가된 PolygonShape를 가져온다.
/// \param shapeID 가져올 PolygonShape ID
///
///
/// returns:
/// shapeID에 해당하는 Shape객체. 없을경우 nil 리턴
- (PolygonShape * _Nullable)getHighlightPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID SWIFT_WARN_UNUSED_RESULT;
/// DimScreen에 추가된 다수의 PolygonShape를 가져온다.
/// \param shapeIDs 가져올 PolygonShape ID 배열
///
///
/// returns:
/// shapeID에 해당하는 PolygonShape객체 배열. 없을경우 nil 리턴
- (NSArray<PolygonShape *> * _Nullable)getHighlightPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs SWIFT_WARN_UNUSED_RESULT;
/// DimScreen에 추가된 모든 PolygonShape를 가져온다.
///
/// returns:
/// DimScreen에 추가된 모든 PolygonShape 객체 배열
- (NSArray<PolygonShape *> * _Nullable)getAllHighlightPolygonShapes SWIFT_WARN_UNUSED_RESULT;
/// DimScreen에 추가된 특정 PolygonShape를 지운다.
/// \param shapeID 지울 PolygonShape ID
///
/// \param callback 제거가 완료되었을 때, 호출할 callback 함수(optional)
///
- (void)removeHighlightPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID callback:(void (^ _Nullable)(void))callback;
/// DimScreen에 추가된 다수의 PolygonShape를 지운다.
/// \param shapeIDs 지울 PolygonShape ID 배열
///
/// \param callback 제거가 완료되었을 때, 호출할 callback 함수(optional)
///
- (void)removeHighlightPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 DimScreen에 속한 특정 PolygonShape를 보여준다.
/// \param shapeIDs 보여줄 PolygonShape ID 배열
///
- (void)showHighlightPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 DimScreen에 속한 특정 PolygonShape를 숨긴다.
/// \param shapeIDs 숨길 PolygonShape ID 배열
///
- (void)hideHighlightPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// DimScreen에 추가된 모든 Shape를 지운다.
- (void)clearAllHighlightShapes;
/// DimScreen의 활성화 상태를 지정한다.
/// <code>true</code>설정 시 DimScreen이 활성화 되어 표시된다. <code>false</code> 설정시 DimScreen이 비활성화된다.
@property (nonatomic) BOOL isEnabled;
/// DimScreen의 컬러값
/// 값을 설정하면 DimScreen의 컬러가 업데이트된다.
@property (nonatomic, strong) UIColor * _Nonnull color;
/// DimScreen이 덮을 레이어 범위
/// seealso:
/// DimScreenCover
@property (nonatomic) DimScreenCover cover;
/// ShapeAnimator를 추가한다.
/// ShapeAnimator 객체는 사용자가 직접 생성할 수 없으며, Manager를 통해서만 생성이 가능하다. 이미 존재하는 AnimatorID로는 overwrite되지 않는다.
/// seealso:
/// AnimationInterpolation
/// seealso:
/// WaveTextAnimation
/// \param animatorID ShapeAnimator ID
///
/// \param effect 레벨별 애니메이션 효과 지정
///
///
/// returns:
/// 생성된 Animator 객체
- (ShapeAnimator * _Nullable)addShapeAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID effect:(id <ShapeAnimationEffect> _Nonnull)effect SWIFT_WARN_UNUSED_RESULT;
/// 추가한 ShapeAnimator 객체를 제거한다.
/// \param animatorID 제거할 animatorID
///
- (void)removeShapeAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID;
/// 추가되어있는 모든 ShapeAnimaotr를 제거한다.
- (void)clearAllShapeAnimators;
/// 추가한 ShapeAnimator 객체를 가져온다.
/// \param animatorID 가져올 AnimatorID
///
///
/// returns:
/// animatorID에 해당하는 ShapeAnimator 객체. 존재하지 않을 경우 nil 리턴
- (ShapeAnimator * _Nullable)getShapeAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// InfoWindowAnimation을 생성할 때 Animation Effect 종류를 정의하는 프로토콜
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK25InfoWindowAnimationEffect_")
@protocol InfoWindowAnimationEffect
/// 애니메이션의 지속시간, 반복 회수, 프레임간의 보간 방법등을 지정
@property (nonatomic) struct AnimationInterpolation interpolation;
/// 애니메이션 종료시 대상 객체를 숨길지 여부를 지정.
@property (nonatomic) BOOL hideAtStop;
/// 애니메이션 재생 횟수.
@property (nonatomic) NSUInteger playCount;
@end


/// AnimationEffect중 Animation 시간동안 특정 pixel값만큼 위에서 아래로 떨어지는 애니메이션 효과 클래스.
/// Poi와 InfoWindow Animator에 적용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK19DropAnimationEffect")
@interface DropAnimationEffect : NSObject <InfoWindowAnimationEffect, PoiAnimationEffect>
/// Initializer
/// \param pixelHeight Drop Animation시 떨어지는 pixel Height
///
- (nonnull instancetype)initWithPixelHeight:(float)pixelHeight OBJC_DESIGNATED_INITIALIZER;
/// Drop Animation시 떨어지는 pixel height
@property (nonatomic, readonly) float pixelHeight;
/// 애니메이션 지속 시간, 반복 횟수 등 세부사항 지정
@property (nonatomic) struct AnimationInterpolation interpolation;
/// 애니메이션 종료 시 애니메이터에 속한 객체들을 숨길지에 대한 여부.
/// true로 설정하면 애니메이션이 종료되면 객체들이 화면에서 자동으로 사라진다.
@property (nonatomic) BOOL hideAtStop;
/// 애니메이션 종료 시 애니메이터에 속한 객체들을 제거할지에 대한 여부.
/// true로 설정하면 애니메이션이 종료되면 객체들이 제거된다.
@property (nonatomic) BOOL removeAtStop;
/// 애니메이션 재생 횟수.
@property (nonatomic) NSUInteger playCount;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// GuiComponent의 베이스 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK16GuiComponentBase")
@interface GuiComponentBase : NSObject
/// initialzier
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Component의 childComponent를 가져온다.
/// \param componentId 가져오고자 하는 componentID
///
///
/// returns:
/// ID에 해당하는 child component. 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// Component의 padding(pixel)
/// 컴포넌트 기준으로 상하좌우로 여백값을 줄 수 있으며, 컴포넌트 본래 사이즈 + padding값이 해당 컴포넌트의 최종 크기가 된다.
/// padding값을 별도로 지정하지 않는 경우, 컴포넌트의 최종 크기는 본래 사이즈가 된다.
@property (nonatomic) struct GuiPadding padding;
/// component의 origin
/// component 자체의 원점 위치를 조절한다. root component에만 적용된다.
@property (nonatomic) struct GuiAlignment origin;
/// component의 align
/// Gui내에서 컴포넌트가 차지하는 최종 공간에서 컴포넌트의 정렬 위치.
@property (nonatomic) struct GuiAlignment align;
/// GuiComponent의 타입
@property (nonatomic, readonly) GuiComponentType type;
/// GuiComponent의 Id
@property (nonatomic, readonly, copy) NSString * _Nonnull componentId;
@end

@class UIImage;

/// gif처럼 여러장의 이미지로 구성된 애니메이션을 보여주는 component 클래스
/// 애니메이션을 구성하는 이미지는 모두 같은 크기, 같은 포맷이어야 한다.
/// 하나의 child component를 가질 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK16GuiAnimatedImage")
@interface GuiAnimatedImage : GuiComponentBase
/// initializer
/// \param componentId Component ID
///
- (nonnull instancetype)init:(NSString * _Nonnull)componentId OBJC_DESIGNATED_INITIALIZER;
/// 애니메이션 이미지들을 추가한다. 각 이미지들이 animation의 keyframe image가 된다.
/// \param images 애니메이션 이미지
///
- (void)addImages:(NSArray<UIImage *> * _Nonnull)images;
/// GuiAnimatedImage의 child Component를 가져온다.
/// child component가 GuiLayout component로 구성되어 있어도 componentId로 가져올 수 있다.
/// \param componentId 가져올 component의 Id
///
///
/// returns:
/// componentID에 해당하는 component. 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// AnimatedImage 컴포넌트의 애니메이션을 실행시킨다.
- (void)start;
/// AnimatedImage 컴포넌트의 애니메이션을 멈춘다.
- (void)stop;
/// AnimatedImage 컴포넌트의 애니메이션을 재시작시킨다.
- (void)resume;
/// AnimatedImage 컴포넌트의 애니메이션을 일시정지한다..
- (void)pause;
/// 애니메이션의 이미지들을 가져온다.
@property (nonatomic, readonly, copy) NSArray<UIImage *> * _Nonnull images;
/// 애니메이션 이미지 사이즈를 지정한다. 지정하지 않을경우 원본 크기를 사용한다.
@property (nonatomic) struct GuiSize imageSize;
/// 애니메이션 1회 재생 시간을 지정한다.
@property (nonatomic) NSUInteger duration;
/// 애니메이션 반복 횟수를 지정한다.
/// 애니메이션 재생을 시작하면 지정한 회수만큼 반복 재생된다.
/// 너무 긴 시간동안 애니메이션을 재생하면 배터리 사용량이 크게 늘어날 수 있다.
/// 무한반복 혹은 짧은 반복횟수를 여러번 반복하는것은 권장하지 않는다.
@property (nonatomic) NSUInteger playCount;
/// GuiAnimatedImage Component에 추가되는 child component
/// GuiLayout 컴포넌트를 넣어서 여러개의 Component를 구성할 수도 있다.
@property (nonatomic, strong) GuiComponentBase * _Nullable child;
@end

@protocol GuiEventDelegate;

/// Gui 베이스 클래스
/// Gui는 특성상 culling 이 되지 않으므로, 지도상의 특정 위치에 그려져서 화면에 그려지는 영역 밖에 있더라도 실제로 그려진다.
/// 그러므로 다수의 Gui를 추가하게 되면 엔진 부하를 야기할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK7GuiBase")
@interface GuiBase : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Gui를 그린다.
- (void)show;
/// Gui를 숨긴다.
- (void)hide;
/// Gui가 그려지고 있던 경우 갱신하여 새로 그린다. 한번 Gui를 그린 상태에서 속성을 변경하고자 하는 경우, 이 함수를 호출해야 반영된다.
- (void)updateGui;
/// childComponent를 가져온다.
/// \param componentId 가져올 컴포넌트의 Id
///
///
/// returns:
/// ComponentId에 해당하는 GuiComponent. 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// Gui의 name
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// GuiEventDelegate를 지정한다.
@property (nonatomic, strong) id <GuiEventDelegate> _Nullable delegate;
/// Gui의 렌더링 우선순위를 지정한다. 값을 세팅하면, 따로 updateGui() 호출 없이도 바로 반영된다.
/// zOrder는 같은 Gui타입끼리만 유효하며, zOrder 값이 클수록 더 위에 그려진다.
/// 즉, zOrder가 0인 Gui는 zOrder가 1인 Gui보다 아래에 그려진다.
@property (nonatomic) NSInteger zOrder;
/// Gui 표출 여부
@property (nonatomic, readonly) BOOL isShow;
@end


/// Gui에 Image를 그리기 위한 component 클래스.
/// 이미지는 크기를 지정하지 않으면 원본 크기로 그려지고 지정하면 지정된 크기대로 그려진다(배경이미지로 사용되는 경우는 component의 크기로 그려짐).
/// 하나의 child component를 가질 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8GuiImage")
@interface GuiImage : GuiComponentBase
/// initializer
/// \param componentId componentID
///
- (nonnull instancetype)init:(NSString * _Nonnull)componentId OBJC_DESIGNATED_INITIALIZER;
/// GuiImage의 child Component를 가져온다.
/// child component가 GuiLayout component로 구성되어 있어도 componentId로 가져올 수 있다.
/// \param componentId 가져올 component의 Id
///
///
/// returns:
/// componentID에 해당하는 component. 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// 사용될 이미지
@property (nonatomic, strong) UIImage * _Nullable image;
/// 사용될 이미지의 사이즈. 크기를 지정하지 않으면 원본 사이즈로 사용된다.
@property (nonatomic) struct GuiSize imageSize;
/// imageStretch를 지정하면 리사이즈될 때 나인패치 이미지 형태로 리사이즈 되어 그려진다.
@property (nonatomic) struct GuiEdgeInsets imageStretch;
/// GuiImage Component에 추가되는 child component
/// GuiLayout 컴포넌트를 넣어서 여러개의 Component를 구성할 수도 있다.
@property (nonatomic, strong) GuiComponentBase * _Nullable child;
@end


/// 버튼 Component 클래스. 사용자로부터 탭 이벤트를 받을 수 있다.
/// 한 개의 child component를 가질 수 있다. Child component로 GuiLayout을 사용하면 여러 개의 child를 추가할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK9GuiButton")
@interface GuiButton : GuiImage
/// initailizer
/// \param componentId Component ID
///
- (nonnull instancetype)init:(NSString * _Nonnull)componentId OBJC_DESIGNATED_INITIALIZER;
/// button pressed Image 지정
@property (nonatomic, strong) UIImage * _Nullable pressedImage;
/// button pressed Image Size 지정. 지정하지 않을경우 원본사이즈 유지
@property (nonatomic) struct GuiSize pressedImageSize;
@end


@class NSMutableArray;

/// 여러개의 child를 가질 수 있는 GuiComponentGroup 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK17GuiComponentGroup")
@interface GuiComponentGroup : GuiComponentBase
/// 현재 컴포넌트에 child component를 추가한다.
/// \param component 추가하고자 하는 child component
///
- (void)addChild:(GuiComponentBase * _Nonnull)component;
/// 현재 컴포넌트의 child component를 가져온다.
/// \param componentId 가져오고자 하는 child component Id
///
///
/// returns:
/// componentId에 해당하는 child component, 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// 현재 컴포넌트의 child component를 지운다..
/// \param componentId 지우고자 하는 child component Id
///
- (void)removeChild:(NSString * _Nonnull)componentId;
/// 현재 컴포넌트가 childComponent를 가지고 있는지 체크한다.
///
/// returns:
/// 현재 컴포넌트가 child를 가지고있을경우 true, 아니면 false
@property (nonatomic, readonly) BOOL hasChildren;
/// 현재 컴포넌트가 갖는 child component Array
///
/// returns:
/// child component 배열
@property (nonatomic, readonly, strong) NSMutableArray * _Nonnull children;
@end


/// Gui에서 발생하는 이벤트에 대한 delegate.
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK16GuiEventDelegate_")
@protocol GuiEventDelegate
@optional
/// Component 탭 이벤트
/// \param gui 탭된 Gui
///
/// \param componentName 탭된 GuiComponent의 이름
///
- (void)guiDidTapped:(GuiBase * _Nonnull)gui componentName:(NSString * _Nonnull)componentName;
/// Animation 재생상태 변경시 발생
/// \param gui 재생상태가 변경된 Gui
///
/// \param componentName Component의 이름
///
/// \param state animation state
///
- (void)guiAnimationStateDidChanged:(GuiBase * _Nonnull)gui componentName:(NSString * _Nonnull)componentName state:(AnimationState)state;
/// Gui 이동 정지 이벤트
/// \param gui Gui
///
/// \param position 위치.
///
- (void)guiMoveDidStopped:(GuiBase * _Nonnull)gui position:(MapPoint * _Nonnull)position;
@end



/// 여러개의 child component를 가지는 component 클래스.
/// child component를 가로, 혹은 세로로 배치할 수 있으며, 배치 방향에 따라 추가한 순서대로 그려진다.
/// GuiLayout의 크기는 배치된 총 child component의 전체 크기가 된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK9GuiLayout")
@interface GuiLayout : GuiComponentGroup
/// initializer
/// \param componentId component ID
///
- (nonnull instancetype)init:(NSString * _Nonnull)componentId OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param componentId componentID
///
/// \param arrangement child component 배치 방향
///
- (nonnull instancetype)init:(NSString * _Nonnull)componentId arrangement:(LayoutArrangement)arrangement OBJC_DESIGNATED_INITIALIZER;
/// layout에 추가한 child component의 배치 방향
@property (nonatomic) LayoutArrangement arrangement;
/// layout의 child component 구분선 표시 여부
@property (nonatomic) BOOL showSplitLine;
/// layout의 child component 구분선 색깔
@property (nonatomic, strong) UIColor * _Nonnull splitLineColor;
/// layout의 child component 구분선 두께
@property (nonatomic) NSInteger splitLineWidth;
/// layout의 배경 색깔
@property (nonatomic, strong) UIColor * _Nonnull bgColor;
@end

@class InfoWindowAnimator;
@class SpriteGuiLayer;
@class InfoWindowLayer;

/// 사용자 Gui를 사용하고 관리하기 위한 클래스
/// SpriteGui, InfoWIndow를 추가 및 제거 등 관리할 수 있다. InfoWindow의 경우, InfoWindow에 적용할 Animator를 추가할 수 있다.
/// ViewBase에 종속적이므로 각 ViewBase가 삭제된 뒤에도 사용하지 않도록 주의하여야 한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10GuiManager")
@interface GuiManager : NSObject
/// InfoWindowAnimator를 추가한다.
/// InfoWindowAnimator 객체는 사용자가 직접 생성할 수 없으며, GuiManager를 통해서만 생성이 가능하다. 이미 존재하는 AnimatorID로는 overwrite되지 않는다.
/// seealso:
/// InfoWindowAnimator
/// seealso:
/// AnimationInterpolation
/// \param animatorID InfoWindowAnimator ID
///
/// \param effect 애니메이션 효과 지정
///
///
/// returns:
/// 생성된 Animator 객체
- (InfoWindowAnimator * _Nullable)addInfoWindowAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID effect:(id <InfoWindowAnimationEffect> _Nonnull)effect SWIFT_WARN_UNUSED_RESULT;
/// 추가한 InfoWindowAnimator를 제거한다.
/// \param animatorID 제거할 animatorID
///
- (void)removeInfoWindowAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID;
/// 추가되어있는 모든 InfoWindowAnimator를 제거한다.
- (void)clearAllInfoWindowAnimators;
/// 추가한 InfoWindowAnimator 객체를 가져온다.
/// \param animatorID 가져올 animatorID
///
///
/// returns:
/// animatorID에 해당하는 InfoWindowAnimator 객체. 존재하지 않을 경우 nil 리턴.
- (InfoWindowAnimator * _Nullable)getInfoWindowAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID SWIFT_WARN_UNUSED_RESULT;
/// SpriteGui Layer. SpriteGui를 추가하기 위해서는 해당 레이어에 Gui를 추가한다.
@property (nonatomic, readonly, strong) SpriteGuiLayer * _Nonnull spriteGuiLayer;
/// InfoWindow Layer. InfoWindow를 추가하기 위해서는 해당 레이어에 InfoWindow를 추가한다.
@property (nonatomic, readonly, strong) InfoWindowLayer * _Nonnull infoWindowLayer;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class TextStyle;

/// Gui에 글자를 그리는 component class
SWIFT_CLASS("_TtC12KakaoMapsSDK7GuiText")
@interface GuiText : GuiComponentBase
/// initializer
/// \param componentId GuiText의 componentId
///
- (nonnull instancetype)init:(NSString * _Nonnull)componentId OBJC_DESIGNATED_INITIALIZER;
/// GuiText에 텍스트를 추가한다.
/// 여러 라인으로 추가할 수 있고, 각 라인별로 스타일을 지정할 수 있다.
/// \param text 추가하고자하는 텍스트
///
/// \param style 추가하고자하는 텍스트에 적용할 스타일
///
- (void)addTextWithText:(NSString * _Nonnull)text style:(TextStyle * _Nonnull)style;
/// Gui에 추가된 텍스트를 가져온다.
/// 여러 라인으로 추가했을 경우, 추가한 인덱스로 텍스트를 가져올 수 있다.
/// \param index 추가한 텍스트의 인덱스
///
///
/// returns:
/// 인덱스에 해당하는 텍스트
- (NSString * _Nonnull)textWithIndex:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Gui에 추가된 텍스트 스타일을 가져온다.
/// 여러 라인으로 추가했을 경우, 추가한 인덱스로 텍스트 스타일을 가져올 수 있다.
/// \param index 추가한 텍스트의 인덱스
///
///
/// returns:
/// 추가한 텍스트 인덱스의 스타일
- (TextStyle * _Nonnull)textStyleWithIndex:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Gui Text Component에 추가된 텍스트 라인 수를 가져온다
///
/// returns:
/// 텍스트 라인 수
- (NSInteger)textCount SWIFT_WARN_UNUSED_RESULT;
/// text의 특정 라인을 업데이트한다. 변경사항은 Gui의 updateGui를 호출해야 유효하다.
/// \param index 텍스트 라인 index
///
/// \param text 업데이트 할 내용
///
/// \param style 업데이트할 텍스트 스타일
///
- (void)updateTextWithIndex:(NSInteger)index text:(NSString * _Nonnull)text style:(TextStyle * _Nullable)style;
@end


/// InfoWindow class
/// 인포윈도우는 body, tail 두 부분으로 구성된다. body는 GuiImage로 구성되어 있으며, 이 GuiImage Component에 존재하는 기본 layout에 원하는 child 컴포넌트를 구성할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10InfoWindow")
@interface InfoWindow : GuiBase
/// initializer
/// \param name InfoWindow 이름
///
- (nonnull instancetype)init:(NSString * _Nonnull)name OBJC_DESIGNATED_INITIALIZER;
/// InfoWindow의 body
/// GuiImage Component이며, body에 child component를 추가할 수 있다.
@property (nonatomic, strong) GuiImage * _Nullable body;
/// InfoWindow의 tail
@property (nonatomic, strong) GuiImage * _Nullable tail;
/// InfoWindow의 body offset
/// tail의 원점(origin) 으로부터 body의 원점이 떨어진 위치.
/// InfoWindow의 tail은 원점이 position으로 지정된 위치에 놓이고 body는 body의 원점이 tail 원점으로부터 offset만큼 떨어진 위치에 놓이게 된다.
@property (nonatomic) CGPoint bodyOffset;
/// InfoWindow의 position offset
/// tail의 원점(origin) 이 position 으로 부터 떨어진 위치.
/// InfoWindow의 tail은 원점이 position으로 지정된 위치에서 position offset 만큼 떨어진 위치에 놓이고 body는 body의 원점이 tail 원점으로부터 offset만큼 떨어진 위치에 놓이게 된다.
@property (nonatomic) CGPoint positionOffset;
/// InfoWindow가 표시 될 위치. 값을 셋팅하면, 별도의 updateGui() 호출 없이도 바로 반영된다.
@property (nonatomic, strong) MapPoint * _Nullable position;
/// InfoWindow를 화면에 표시하고, InfoWinodw가 표시되는 영역으로 자동으로 이동한다.
/// \param callback 카메라 이동이 끝났을 때, 호출할 callback(optional)
///
- (void)showWithAutoMoveWithCallback:(void (^ _Nullable)(void))callback;
/// infoWindow의 child Component를 가져온다.
/// \param componentId Child component ID
///
///
/// returns:
/// componentId에 해당하는 child Component. 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// InfoWindow를 특정 위치로 지정한 시간만큼 이동시킨다.
/// \param position 이동시킬 위치
///
/// \param duration 이동시킬 시간
///
- (void)moveAt:(MapPoint * _Nonnull)position duration:(NSUInteger)duration;
- (MapPoint * _Nullable)rawPosition SWIFT_WARN_UNUSED_RESULT;
@end



/// InfoWindow에 애니메이션 효과를 주기 위한 Animator 클래스.
/// Animator를 생성해서 효과를 주고자 하는 InfoWindow를 Animator에 넣어서 animator를 동작시키는 방식이다.
/// Animator는 사용자가 직접 생성할 수 없으며, GuiManager를 통해서만 생성이 가능하다.
SWIFT_CLASS("_TtC12KakaoMapsSDK18InfoWindowAnimator")
@interface InfoWindowAnimator : NSObject <Animator>
/// Animator를 동작시킨다.
/// Animator에 추가된 InfoWindow가 없으면 start함수는 동작하지 않는다. start를 호출한 이후에는 Animator에   InfoWindow를 추가하거나 지울 수 없다. 추가하고자 하는 경우, stop을 호출하고 추가해야한다.
/// start 호출 이후 애니메이션이 끝나면 Animator에 추가된 InfoWindow는 비워지므로, 다시 start를 호출하려면 InfoWindow를 추가해야한다.
/// InfoWindow Interface에 있는 move등의 동작은 Animator가 start되면 멈춘다.
- (void)start;
/// Animator 의 종료 콜백을 지정한다. Start 된 애니메이션이 종료되거나 stop이 호출되면 지정한 callback 이 호출된다. nil 로 지정해서 기존에 지정했던 callback을 제거할 수 있다. 기본값 nil.
/// \param callback Animator에 추가할 종료 콜백.
///
- (void)setStopCallback:(void (^ _Nullable)(id <Animator> _Nullable))callback;
/// Animator의 동작을 멈춘다.
/// stop이 호출되면 다시 애니메이션이 끝난것으로 간주되어 Animator에 속한 InfoWindow는 모두 비워지므로, Animator를 다시 동작시키리면 다시 InfoWindow를 Animator에 추가해야한다.
- (void)stop;
/// Animator에 InfoWindow를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 InfoWindow를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 InfoWindow를 추가할 수 없다.
/// \param infoWindow Animator에 추가할 InfoWindow
///
- (void)addInfoWindow:(InfoWindow * _Nonnull)infoWindow;
/// Animator에 여러개의 InfoWindow를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 InfoWindow를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 InfoWindow를 추가할 수 없다.
/// \param infoWindows Animator에 추가할 InfoWindow 배열
///
- (void)addInfoWindows:(NSArray<InfoWindow *> * _Nonnull)infoWindows;
/// Animator에 추가한 InfoWindow를 모두 지운다.
/// start() 호출 이후에는 동작하지 않는다.
- (void)clearAllInfoWindows;
/// 추가한 animatorID
@property (nonatomic, readonly, copy) NSString * _Nonnull animatorID;
/// Animator 시작 여부
@property (nonatomic, readonly) BOOL isStart;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// InfoWindowLayer - InfoWindow 들을 담는 layer
SWIFT_CLASS("_TtC12KakaoMapsSDK15InfoWindowLayer")
@interface InfoWindowLayer : NSObject
/// InfoWindowLayer의 visible 상태.
/// layer의 on/off 상태를 나타내며, layer에 속한 객체의 show/hide는 별도로 동작시켜야한다.
/// 즉, layer의 visible이 true여도 layer에 속한 객체의 show를 호출해야 보이고, visible이 false라면 layer에 속한 객체는 화면에 표시되지 않는다.
@property (nonatomic) BOOL visible;
/// 추가한 모든 InfoWindow를 지운다.
- (void)clear;
/// InfoWindow를 현재 레이어에 추가한다.
/// InfoWindow를 레이어에 추가하기 전까지는 화면에 표시되지 않는다.
/// 같은 이름으로 중복으로 추가할 수 없다.
/// \param gui 추가할 InfoWindow 객체
///
- (void)addInfoWindow:(InfoWindow * _Nonnull)gui;
/// InfoWindow를 현재 레이어에서 제거한다.
/// \param gui 제거할 InfoWindow 객체
///
- (void)removeInfoWindow:(InfoWindow * _Nonnull)gui;
/// guiName을 Key로 갖는 InfoWindow를 현재 레이어에서 제거한다.
/// \param guiName 제거할 InfoWindow의 guiName
///
- (void)removeInfoWindowWithGuiName:(NSString * _Nonnull)guiName;
/// InfoWindowLayer에 추가되어있는 InfoWindow를 guiName을 Key로 가져온다.
/// \param guiName 가져올 InfoWindow의 guiName
///
///
/// returns:
/// 이름에 해당하는 InfoWindow. 없을 경우 nil.
- (InfoWindow * _Nullable)getInfoWindowWithGuiName:(NSString * _Nonnull)guiName SWIFT_WARN_UNUSED_RESULT;
/// InfoWindowLayer에 특정 guiName을 가진 InfoWindow가 존재하는지 체크한다.
/// \param guiName 추가되어있는지 확인할 InfoWindow guiName
///
///
/// returns:
/// 존재 여부. 이미 추가되어있는 guiName의 경우 true, 아니면 false를 리턴한다.
- (BOOL)isInfoWindowExistWithGuiName:(NSString * _Nonnull)guiName SWIFT_WARN_UNUSED_RESULT;
/// InfoWindowLayer에 추가한 모든 InfoWindow를 가져온다.
///
/// returns:
/// 추가된 모든 InfoWindow 객체 배열
- (NSArray<InfoWindow *> * _Nullable)getAllInfoWindows SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// API의 뷰 클래스들의 베이스 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK8ViewBase")
@interface ViewBase : NSObject <NativeEventDelegate>
/// 뷰의 이름을 가져온다.
///
/// returns:
/// 뷰의 이름
- (NSString * _Nonnull)viewName SWIFT_WARN_UNUSED_RESULT;
/// 뷰의 위치 및 크기.
/// viewRect를 지정하면, view가 위치 및 크기가 업데이트된다.
@property (nonatomic) CGRect viewRect;
/// 생성한 View의 타입을 가져온다.
@property (nonatomic, readonly) MapType mapType;
/// 제스쳐 동작 활성화 상태를 지정한다.
/// \param type 제스쳐 동작 종류.
///
/// \param enable 활성화 상태
///
- (void)setGestureEnableWithType:(GestureType)gestureType enable:(BOOL)enable;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class LabelManager;
@class ShapeManager;
@class TrackingManager;
@class RouteManager;
@protocol KakaoMapEventDelegate;

/// 지도 뷰를 위한 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK8KakaoMap")
@interface KakaoMap : ViewBase
/// 여백을 지정한다.
/// 여백을 지정하면, 지도 중심점 계산이나 애니메이션 기능과 같이 뷰 영역 계산이 필요한 부분에 반영된다.
/// 예를들어, 좌측 여백을 지정하면 화면의 중심점에 대한 위치 계산시 (좌측여백 / 2)만큼 우측으로 밀린 지점에 대한 위치로 계산한다.
/// \param insets 상하좌우 여백
///
- (void)setMargins:(UIEdgeInsets)insets;
/// 여백을 0으로 초기화한다.
- (void)resetMargins;
/// 지도 Poi 표시 여부를 설정한다.
/// \param enable true인경우, 지도판의 Poi가 표시되고, false인 경우 지도판의 Poi가 표시되지 않는다.
///
- (void)setPoiEnabled:(BOOL)enable;
/// 지도 기본 Poi(API를 통해 추가된 POI가 아닌 POI) 들의 클릭가능 여부
@property (nonatomic) BOOL poiClickable;
/// 최소 줌 레벨.
/// KakaoMap의 최소 줌 레벨을 가져온다.
@property (nonatomic, readonly) NSInteger minLevel;
/// 최대 줌 레벨.
/// KakaoMap의 최대 줌 레벨을 가져온다.
@property (nonatomic, readonly) NSInteger maxLevel;
/// 최소 카메라 레벨.
/// 카메라의 최소 줌 레벨을 가져온다. 해당 레벨보다 작은 레벨로는 카메라 줌레벨을 축소시킬 수 없다.
@property (nonatomic, readonly) NSInteger cameraMinLevel;
/// 현재 줌 레벨.
/// 현재 KakaoMap의 줌 레벨을 가져온다.
@property (nonatomic, readonly) NSInteger zoomLevel;
/// 현재 포커스 상태
/// KakaoMap의 현재 Focus 여부를 가져온다.
@property (nonatomic, readonly) BOOL isFocused;
/// 현재 지도의 상하좌우 여백 값.
/// KakaoMap의 현재 상하좌우 여백값을 가져온다.
@property (nonatomic, readonly) UIEdgeInsets margins;
/// 카메라를 cameraUpdate로 정의된 대로 즉시 이동한다.
/// 진행중이던 카메라 이동 애니메이션은 모두 종료된다.
/// seealso:
/// CameraUpdate
/// \param cameraUpdate 카메라 이동을 정의한 CameraUpdate.
///
/// \param callback 이동 완료시 호출될 callback
///
- (void)moveCamera:(CameraUpdate * _Nonnull)cameraUpdate callback:(void (^ _Nullable)(void))callback;
/// 카메라를 cameraUpdate로 정의된 대로 animationOption 에 따라 이동한다.
/// seealso:
/// CameraUpdate
/// seealso:
/// CameraAnimationOptions
/// \param cameraUpdate 카메라 이동을 정의한 CameraUpdate.
///
/// \param options 이동 애니메이션 옵션.
///
/// \param callback 이동 애니메이션 종료시 호출될 callback
///
- (void)animateCameraWithCameraUpdate:(CameraUpdate * _Nonnull)cameraUpdate options:(struct CameraAnimationOptions)options callback:(void (^ _Nullable)(void))callback;
/// 카메라의 orientation(회전, 기울임)을 0으로 초기화시킨다.
/// \param options 애니메이션 옵션.
///
/// \param callback 카메라 이동 애니메이션 종료시 호출될 callback
///
- (void)resetCameraOrientation:(struct CameraAnimationOptions)options callback:(void (^ _Nullable)(void))callback;
/// CameraAnimationOptions에 autoElevation 을 true로 지정한 애니메이션 진행시, autoElevation하는 동안 정북방향으로 카메라를 회전할지 여부를 지정한다.
/// \param enable true면 autoElevation시 정북으로 회전한다.
///
- (void)setBackToNorthDuringAutoElevation:(BOOL)enable;
/// level에 해당하는 카메라 높이를 가져온다.
/// \param level 지도 레벨
///
///
/// returns:
/// 카메라 높이(m)
- (double)heightAtLevel:(NSInteger)level SWIFT_WARN_UNUSED_RESULT;
/// 현재 KakaoMap 영역의 viewPoint에 해당하는 실제 위치를 가져온다.
/// \param viewPoint KakaoMap 뷰 범위 내의 임의의 한 지점 (x, y)
///
///
/// returns:
/// viewPoint에 해당하는 실제 위치를 나타내는 MapPoint. viewPoint가 KakaoMap의 범위 밖일 경우 잘못된 MapPoint가 return 된다.
- (MapPoint * _Nonnull)getPosition:(CGPoint)viewPoint SWIFT_WARN_UNUSED_RESULT;
/// 카메라 애니메이션 활성화 상태를 지정한다.
/// <code>true</code>로 설정하면 animateCamera 호출 시 애니메이션이 활성화 된다. <code>false</code>로 설정하면 animateCamera()를 호출해도 애니메이션 없이 즉시 이동된다.
@property (nonatomic) BOOL cameraAnimationEnabled;
/// 현재 카메라 높이(m)를 가져온다.
@property (nonatomic, readonly) double cameraHeight;
/// 현재 카메라의 회전각(radian, 정북기준 시계방향).
@property (nonatomic, readonly) double rotationAngle;
/// 현재 카메라의 기울임각(radian, 수직 방향 기준).
@property (nonatomic, readonly) double tiltAngle;
/// 지도상 표시를 지원하는 언어코드 목록을 가져온다.
///
/// returns:
/// 지원하는 언어코드의 배열
- (NSArray<NSString *> * _Nonnull)getSupportedLanguages SWIFT_WARN_UNUSED_RESULT;
/// 지도상에 표시될 언어를 설정한다.
/// 지원되는 언어만 선택가능하다. 미지원언어를 지정할 경우 무시된다.
/// \param langCode 언어 코드.(ex. ko, en, ja, zh)
///
- (void)setLanguage:(NSString * _Nonnull)langCode;
/// 건물 높이 scale을 지정한다. scale값에 따라 그려지는 건물의 높이가 조절된다.
/// \param scale 0 ~ 1 사이의 건물 높이 scale
///
@property (nonatomic) float buildingScale;
/// 지도상의 poi size를 조절한다. icon 크기도 함께 변한다.
/// default값은 Regular
@property (nonatomic) PoiScaleType poiScale;
/// 지도 위에 overlay를 표시한다.
/// \param overlay 지도위에 표시하고자 하는 overlay 이름
///
- (void)showOverlay:(NSString * _Nonnull)overlay;
/// 지도 위에 overlay를 숨긴다.
/// \param overlay 숨길 overlay 이름
///
- (void)hideOverlay:(NSString * _Nonnull)overlay;
/// 축척을 표시한다.
- (void)showScaleBar;
/// 축척을 숨긴다.
- (void)hideScaleBar;
/// 축척의 alignment와 offset을 지정한다.
/// seealso:
/// GuiAlignment
/// \param origin 축척의 origin
///
/// \param position 축척 origin으로부터의 offset(pt)
///
- (void)setScaleBarPositionWithOrigin:(struct GuiAlignment)origin position:(CGPoint)position;
/// 축척의 자동숨김 기능 활성화를 지정한다.
/// 활성화되면 축척이 보여진 뒤 일정시간 후에 자동으로 숨겨진다.
/// \param autoDisappear 자동숨김 활성화.
///
- (void)setScaleBarAutoDisappear:(BOOL)autoDisappear;
/// 축척의 FadeInOutOption을 지정한다.
/// \param option FadeInOut 옵션.
///
- (void)setScaleBarFadeInOutOption:(struct FadeInOutOptions)option;
/// 나침반을 표시한다.
- (void)showCompass;
/// 나침반을 숨긴다.
- (void)hideCompass;
/// 나침반의 alignment를 지정한다.
/// seealso:
/// GuiAlignment
/// \param origin 나침반의 alignment
///
/// \param position 나침반 alignmnet로부터의 offset(pt)
///
- (void)setCompassPositionWithOrigin:(struct GuiAlignment)origin position:(CGPoint)position;
/// 로고의 위치를 지정한다.
/// 로고는 SpriteGUI 와 같은 방식으로 화면상의 특정위치에 고정적으로 표시되므로, 다른 GUI 와 겹치는 현상을 피하기 위해 로고의 위치를 이동시키는 데 사용한다.
/// 위치 지정방식은 SpriteGUI와 동일하다.
/// \param origin 로고의 alignment
///
/// \param position alignment 기준점으로부터의 offset
///
- (void)setLogoPositionWithOrigin:(struct GuiAlignment)origin position:(CGPoint)position;
/// 제스쳐의 동작 기준점을 뷰의 가운데로 고정시킨다. 줌/회전/틸트 관련 제스쳐에만 적용된다(그 외 제스쳐는 무시함).
/// \param forGesture 제스쳐 종류
///
- (void)lockReferencePointForGesture:(GestureType)gesture;
/// 제스쳐의 동작 기준점을 뷰의 가운데 고정을 해제한다.
/// \param forGesture 제스쳐 종류
///
- (void)unlockReferencePointForGesture:(GestureType)gesture;
/// 뷰를 다시 그린다.
- (void)refresh;
/// 지도 뷰의 DimmingScreen 객체
@property (nonatomic, readonly, strong) DimScreen * _Nonnull dimScreen;
/// LabelManager
///
/// returns:
/// 이 KakaoMap의 LabelManager
- (LabelManager * _Nonnull)getLabelManager SWIFT_WARN_UNUSED_RESULT;
/// ShapeManager
///
/// returns:
/// 이 KakaoMap의 ShapeManager
- (ShapeManager * _Nonnull)getShapeManager SWIFT_WARN_UNUSED_RESULT;
/// TrackingManager
///
/// returns:
/// 이 KakaoMap의 TrackingManager
- (TrackingManager * _Nonnull)getTrackingManager SWIFT_WARN_UNUSED_RESULT;
/// RouteManager
///
/// returns:
/// 이 KakaoMap의 RouteManager
- (RouteManager * _Nonnull)getRouteManager SWIFT_WARN_UNUSED_RESULT;
/// GuiManager
///
/// returns:
/// 이 KakaoMap의 GuiManager
- (GuiManager * _Nonnull)getGuiManager SWIFT_WARN_UNUSED_RESULT;
/// 이벤트 delegate를 지정한다.
/// \param delegate event delegate
///
@property (nonatomic, strong) id <KakaoMapEventDelegate> _Nullable eventDelegate;
/// 뷰의 활성화 상태
/// <code>true</code>인 경우 렌더링이 실행되며,<code>false</code>인 경우 렌더링을 하지 않는다.
@property (nonatomic) BOOL isEnabled;
@end


@interface KakaoMap (SWIFT_EXTENSION(KakaoMapsSDK))
/// ViewInfo를 변경한다.
/// 지정된 이름의 Viewinfo를 서버로부터 가져와서 현재 뷰에 교체하여 적용한다.
/// Note: 지도용 ViewInfo만 가능.
/// \param appName 변경할 app 이름
///
/// \param viewInfoName 변경할 viewInfo 이름
///
- (void)changeViewInfoWithAppName:(NSString * _Nonnull)appName viewInfoName:(NSString * _Nonnull)viewInfoName;
@end



/// KakaoMap의 이벤트 Delegate
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK21KakaoMapEventDelegate_")
@protocol KakaoMapEventDelegate
@optional
/// 포커스가 변경되었을 때 호출.
/// \param kakaoMap KakaoMap
///
/// \param focus 변경된 포커스 상태
///
- (void)kakaoMapFocusDidChangedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap focus:(BOOL)focus;
/// KakaoMap의 크기가 변경되었을 때 호출.
/// \param kakaoMap KakaoMap
///
- (void)kakaoMapDidResized:(KakaoMap * _Nonnull)kakaoMap;
/// KakaoMap의 Margin이 변경되었을 때 호출.
/// \param kakaoMap KakaoMap
///
- (void)kakaoMapMarginDidUpdated:(KakaoMap * _Nonnull)kakaoMap;
/// KakaoMap의 영역이 탭되었을 때 호출.
/// \param kakaoMap 탭된 kakaoMap 객체
///
/// \param point 탭 위치
///
- (void)kakaoMapDidTappedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap point:(CGPoint)point;
/// Terrain Layer가 탭되면 호출.
/// \param kakaoMap 탭된 kakaoMap 객체
///
/// \param position 탭된 지점의 위치
///
- (void)terrainDidTappedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap position:(MapPoint * _Nonnull)position;
/// Terrain Layer가 길게 눌리면 발생.
/// \param kakaoMap 눌린 kakaoMap 객체
///
/// \param position 눌린 지점의 위치
///
- (void)terrainDidLongPressedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap position:(MapPoint * _Nonnull)position;
/// Poi가 탭되면 호출.
/// \param kakaoMap Poi가 속한 KakaoMap
///
/// \param layerID Poi가 속한 layerID
///
/// \param poiID Poi의 ID
///
/// \param position Poi의 위치
///
- (void)poiDidTappedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap layerID:(NSString * _Nonnull)layerID poiID:(NSString * _Nonnull)poiID position:(MapPoint * _Nonnull)position;
/// 나침반이 탭 되면 호출.
/// \param kakaoMap 나침반이 속한 KakaoMap
///
- (void)compassDidTappedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap;
/// 카메라 이동이 시작될 때 호출.
/// \param kakaoMap KakaoMap
///
/// \param by 지도 이동을 유발한 원인(사용자 제스쳐, API 호출).
///
- (void)cameraWillMoveWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap by:(MoveBy)by;
/// 지도 이동이 멈췄을 때 호출.
/// \param kakaoMap KakaoMap
///
/// \param by 지도 이동을 유발한 원인(사용자 제스쳐, API 호출).
///
- (void)cameraDidStoppedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap by:(MoveBy)by;
/// 지도의 viewInfo변경이 성공했을 때 호출
/// \param kakaoMap KakaoMap
///
/// \param viewInfoName 변경한 viewInfoName
///
- (void)onViewInfoChangedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap viewInfoName:(NSString * _Nonnull)viewInfoName;
/// 지도의 viewInfo변경이 실패했을 때 호출
/// \param kakaoMap KakaoMap
///
/// \param viewInfoName 변경한 viewInfoName
///
- (void)onViewInfoChangeFailureWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap viewInfoName:(NSString * _Nonnull)viewInfoName;
@end



/// Label protocol
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK5Label_")
@protocol Label
/// 라벨 표출
- (void)show;
/// 라벨 숨김
- (void)hide;
/// 라벨 스타일 변경
- (void)changeStyleWithStyleID:(NSString * _Nonnull)styleID enableTransition:(BOOL)enableTransition;
/// 라벨이 속한 레이어 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// 라벨 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull itemID;
/// 라벨 표출여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
@end

@class PoiOptions;
@class Poi;
@class WaveTextOptions;
@class WaveText;

/// Label 종류(Poi, WaveText)를 관리하는 단위인 LabelLayer 클래스.
/// Poi, WaveText를 추가/삭제 등 관리할 수 있으며, 일종의 그룹처럼 관리가 가능하다.
/// 사용자가 직접 객체를 생성할 수 없으며, LabelManager를 통해 객체를 간접적으로 생성할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10LabelLayer")
@interface LabelLayer : NSObject
/// LabelLayer의 visible 상태.
/// layer의 on/off 상태를 나타내며, layer에 속한 객체의 show/hide는 별도로 동작시켜야한다.
/// 즉, layer의 visible이 true여도 layer에 속한 객체의 show를 호출해야 보이고, visible이 false라면 layer에 속한 객체는 화면에 표시되지 않는다.
@property (nonatomic) BOOL visible;
/// 현재 Layer에 있는 모든 item을 일괄적으로 지운다.
/// 하나의 layer안에 Poi와 WaveText가 함께 추가가 가능하므로, 이 경우 clear를 호출게 되면 모든 Poi와 WaveText가 지워진다.
- (void)clearAllItems;
/// 현재 Layer에 있는  Exit Transition 속성을 가진 Poi를 지운다.
- (void)clearAllExitTransitionPois;
/// 현재 레이어의 clickable 속성을 지정한다.
/// \param clickable 클릭 설정 여부. 해당 레이어에 속한 모든 Poi에 적용된다.
///
- (void)setClickable:(BOOL)clickable;
/// 현재 Layer에 Poi를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// \param option 생성할 Poi의 옵션
///
/// \param at 생성할 Poi의 위치
///
/// \param callback Poi 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 Poi 객체
- (Poi * _Nullable)addPoiWithOption:(PoiOptions * _Nonnull)option at:(MapPoint * _Nonnull)position callback:(void (^ _Nullable)(Poi * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 같은 옵션을 가지는 다수의 Poi를 추가한다.
/// 같은 옵션을 가지지만 위치만 다른 Poi를 생성할 경우 사용한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// \param option 생성할 Poi의 옵션
///
/// \param at 생성할 Poi의 위치 배열
///
/// \param callback Poi 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 Poi 객체
- (NSArray<Poi *> * _Nullable)addPoisWithOption:(PoiOptions * _Nonnull)option at:(NSArray<MapPoint *> * _Nonnull)positions callback:(void (^ _Nullable)(NSArray<Poi *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 다른 옵션을 가지는 다수의 Poi를 추가한다.
/// Poi별로 다른 옵션을 가지는 경우 사용한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// warning:
/// 여러개의 옵션으로 여러개의 poi를 생성하는 경우, option과 position의 pair가 일치해야한다. 즉, position하나당 option 하나의 짝을 맞추어야 한다.
/// \param options 생성할 Poi의 옵션 배열
///
/// \param at Poi가 표시될 위치. option과 pair를 맞추어야 한다.
///
/// \param callback Poi 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 Poi 객체배열
- (NSArray<Poi *> * _Nullable)addPoisWithOptions:(NSArray<PoiOptions *> * _Nonnull)options at:(NSArray<MapPoint *> * _Nonnull)positions callback:(void (^ _Nullable)(NSArray<Poi *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정 Poi를 지운다.
/// \param poiID Layer에서 제거할 Poi Id
///
/// \param callback Poi 제거가 완료되었을 때, 호출할 callback(optional)
///
- (void)removePoiWithPoiID:(NSString * _Nonnull)poiID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 여러개의 Poi를 지운다.
/// \param poiIDs Layer에서 제거할 Poi Id 배열
///
/// \param callback Poi 제거가 완료되었을 때, 호출할 callback(optional)
///
- (void)removePoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속해있는 Poi를 모두 보여준다.
- (void)showAllPois;
/// 현재 Layer에 속해있는 Poi를 모두 숨긴다.
- (void)hideAllPois;
/// 현재 Layer에 속한 특정 Poi를 보여준다.
/// \param poiIDs 보여줄 Poi ID 배열
///
- (void)showPoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs;
/// 현재 Layer에 속한 특정 Poi를 숨긴다.
/// \param poiIDs 숨길 Poi ID 배열
///
- (void)hidePoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs;
/// 현재 Layer에 속한 Poi를 가져온다.
/// \param poiID 가져올 Poi ID
///
///
/// returns:
/// ID에 해당하는 Poi 객체, 없을경우 ni.
- (Poi * _Nullable)getPoiWithPoiID:(NSString * _Nonnull)poiID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 Poi들을 가져온다.
/// \param poiIDs 가져올 Poi ID
///
///
/// returns:
/// ID에 해당하는 Poi 객체 배열. 없을경우 ni.
- (NSArray<Poi *> * _Nullable)getPoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 Poi를 가져온다.
///
/// returns:
/// 레이어에 속한 모든 Poi.
- (NSArray<Poi *> * _Nullable)getAllPois SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 WaveText를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// \param options 생성할 WaveText의 option
///
/// \param callback WaveText 제거가 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성한 waveText 객체
- (WaveText * _Nullable)addWaveText:(WaveTextOptions * _Nonnull)options callback:(void (^ _Nullable)(WaveText * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 특정 WaveText를 지운다.
/// \param waveTextID 지우고자 하는 WaveText의 ID
///
/// \param callback WaveText 제거가 완료되었을 때, 호출할 callback(optional)
///
- (void)removeWaveTextWithWaveTextID:(NSString * _Nonnull)waveTextID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 여러개의 특정 WaveText를 지운다.
/// \param waveTextIDs 지우고자 하는 WaveText의 ID 배열
///
/// \param callback WaveText 제거가 모두 완료되었을 때, 호출할 callback(optional)
///
- (void)removeWaveTextsWithWaveTextIDs:(NSArray<NSString *> * _Nonnull)waveTextIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 모든 WaveText를 표시한다.
- (void)showAllWaveTexts;
/// 현재 Layer에 속한 모든 WaveText를 숨긴다.
- (void)hideAllWaveTexts;
/// 현재 Layer에 속한 특정 WaveText를 보여준다.
/// \param waveTextIDs 보여줄 WaveText ID 배열
///
- (void)showWaveTextsWithWaveTextIDs:(NSArray<NSString *> * _Nonnull)waveTextIDs;
/// 현재 Layer에 속한 특정 WaveText를 숨긴다.
/// \param waveTextIDs 숨길 WaveText ID 배열
///
- (void)hideWaveTextsWithWaveTextIDs:(NSArray<NSString *> * _Nonnull)waveTextIDs;
/// 현재 Layer에 속한 WaveText를 가져온다.
/// \param waveTextID 가져올 WaveText ID
///
///
/// returns:
/// ID에 해당하는 WaveText객체, 없을경우 ni.
- (WaveText * _Nullable)getWaveTextWithWaveTextID:(NSString * _Nonnull)waveTextID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 여러개의 WaveText를 가져온다.
/// \param waveTextIDs 가져올 WaveText ID배열
///
///
/// returns:
/// ID에 해당하는 WaveText객체 배열, 없을경우 ni.
- (NSArray<WaveText *> * _Nullable)getWaveTextsWithWaveTextIDs:(NSArray<NSString *> * _Nonnull)waveTextIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 waveText를 가져온다.
- (NSArray<WaveText *> * _Nullable)getAllWaveTexts SWIFT_WARN_UNUSED_RESULT;
/// layer의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// layer에 속한 Poi가 경쟁하는 방법을 지정한다.
/// Layer의 우선순위(zOrder)에 따라 Poi끼리 겹쳐졌을 때, Poi가 표시될 정책을 지정한다.
/// seealso:
/// CompetitionType
@property (nonatomic, readonly) CompetitionType competitionType;
/// Poi가 경쟁할 때, 경쟁을 하는 단위를 선택한다.
/// seealso:
/// CompetitionUnit
@property (nonatomic, readonly) CompetitionUnit competitionUnit;
/// competitionType이 same일 경우, 경쟁을 하는 기준이 된다.
/// seealso:
/// OrderingType
@property (nonatomic, readonly) OrderingType orderType;
/// layer의 렌더링 우선순위
/// zOrder는 같은 LabelLayer타입끼리만 유효하며, 기본적으로 zOrder 값이 클수록 더 높은 우선권을 가진다.
@property (nonatomic) NSInteger zOrder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// LabelLayer 생성 옵션
SWIFT_CLASS("_TtC12KakaoMapsSDK17LabelLayerOptions")
@interface LabelLayerOptions : NSObject
/// initializer
/// \param layerID layer ID
///
/// \param competitionType 다른 poi와 경쟁하는 방법
///
/// \param competitionUnit 경쟁을 하는 단위
///
/// \param orderType competitionType이 same일 때, 경쟁하는 기준
///
/// \param zOrder layer의 zOrder. 값이 클수록 위에 그려진다.
///
- (nonnull instancetype)initWithLayerID:(NSString * _Nonnull)layerID competitionType:(CompetitionType)competitionType competitionUnit:(CompetitionUnit)competitionUnit orderType:(OrderingType)orderType zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// layerID
@property (nonatomic, copy) NSString * _Nonnull layerID;
/// 다른 poi와 경쟁하는 방법을 지정한다. 해당 레이어에 속한 poi는 모두 해당 방법으로 경쟁한다.
@property (nonatomic) CompetitionType competitionType;
/// 경쟁할 때 단위를 지정한다. 해당 레이어에 속한 poi는 모두 해당 방법으로 경쟁한다.
@property (nonatomic) CompetitionUnit competitionUnit;
/// competitionType이 same일 때 경쟁하는 기준을 설정한다.
@property (nonatomic) OrderingType orderType;
/// layer의 zOrder
/// zOrder는 같은 LabelLayer타입끼리만 유효하며, zOrder 값이 클수록 더 위에 그려진다
/// 즉, zOrder가 0인 LabelLayer는에 속한 Label은 zOrder가 1인 LabelLayer에 속한 Label보다 아래에 그려진다.
@property (nonatomic) NSInteger zOrder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PoiStyle;
@class WaveTextStyle;
@class LodLabelLayerOptions;
@class LodLabelLayer;
@class PoiAnimator;

/// KakaoMap에서 사용자 Poi, LodPoi, WaveText등 Label종류를 사용하고 관리하기 위한 클래스
/// 각 Object의 레이어 관리, 스타일추가와 Poi의 Animator 추가등이 가능하다.
/// KakaoMap에 종속적이므로 KakaoMap이 삭제된 뒤에도 사용하지 않도록 주의하여야 한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12LabelManager")
@interface LabelManager : NSObject
/// PoiStyle을 추가한다.
/// 레벨별로 다른 스타일을 갖는 PoiStyle을 추가한다. 이미 추가된 styleID와 중복된 styleID로 추가할 수 없으며, overwrite되지 않는다.
/// seealso:
/// PoiStyle
/// \param style 추가할 PoiStyle
///
- (void)addPoiStyle:(PoiStyle * _Nonnull)style;
/// PoiStyle을 삭제한다.
/// \param styleID 삭제할 PoiStyle ID
///
- (void)removePoiStyle:(NSString * _Nonnull)styleID;
/// WaveTextStyle을 추가한다.
/// 레벨별로 다른 스타일을 갖는 WaveTextStyle을 추가한다. 이미 추가된 styleID와 중복된 styleID로 추가할 수 없으며, overwrite되지 않는다.
/// WaveText에는 TextStyle중 charSpace, lineSpace, aspectRatio 는 적용되지 않는다.
/// seealso:
/// WaveTextStyle
/// \param style 추가할 WaveTextStyle
///
- (void)addWaveTextStyle:(WaveTextStyle * _Nonnull)style;
/// LabelLayer를 추가한다.
/// LabelLayer는 LOD가 적용되지 않는 Label인 Poi와 WaveText를 관리하는 단위. 사용자가 LabelLayer 객체를 직접 생성할 수 없으며, LabelManager를 통해 LayerOptions으로 생성할 수 있다. 생성한 레이어에 Poi 및 WaveText를 추가&삭제할 수 있다.
/// LabelLayer, LodLabelLayer를 통합으로 관리하므로 중복 ID로 추가할 수 없으며, overwrite되지 않고 기존 Layer가 유지된다.
/// seealso:
/// LabelLayer
/// seealso:
/// LabelLayerOptions
/// \param option 추가할 LabelLayer Option
///
- (LabelLayer * _Nullable)addLabelLayerWithOption:(LabelLayerOptions * _Nonnull)option SWIFT_WARN_UNUSED_RESULT;
/// LabelLayer를 삭제한다.
/// LayerID로 Layer를 삭제한다. Layer 삭제와 동시에 Layer에 추가되어있던 Poi,WaveText도 모두 삭제된다.
/// \param layerID 삭제할 LabelLayer의 ID
///
- (void)removeLabelLayerWithLayerID:(NSString * _Nonnull)layerID;
/// LabelLayer를 모두 삭제한다.
/// KakaoMap에 등록된 모든 LabelLayer를 삭제한다. Layer 삭제와 동시에 Layer에 추가되어있던 Poi,WaveText도 모두 삭제된다.
- (void)clearAllLabelLayers;
/// 추가한 LabelLayer를 가져온다.
/// \param layerID 가져올 LabelLayer ID
///
///
/// returns:
/// LabelLayer
- (LabelLayer * _Nullable)getLabelLayerWithLayerID:(NSString * _Nonnull)layerID SWIFT_WARN_UNUSED_RESULT;
/// LodLabelLayer를 추가한다.
/// LodLabelLayer는 LOD가 적용되는 LodPoi를 관리하는 단위이다. 사용자가 LodLabelLayer 객체를 직접 생성할 수 없으며, LabelManager를 통해 LodLayerOptions으로 생성할 수 있다. 생성한 레이어에 LodPoi를 추가&삭제할 수 있다.
/// LabelLayer, LodLabelLayer를 통합으로 관리하므로 중복 ID로 추가할 수 없으며, overwrite되지 않고 기존 Layer가 유지된다.
/// seealso:
/// LodLabelLayer
/// seealso:
/// LodLabelLayerOptions
/// \param option 추가할 LodLabelLayerOptions
///
///
/// returns:
/// 추가된 LodLabelLayer.
- (LodLabelLayer * _Nullable)addLodLabelLayerWithOption:(LodLabelLayerOptions * _Nonnull)option SWIFT_WARN_UNUSED_RESULT;
/// LodLabelLayer를 삭제한다.
/// LayerID로 LodLabelLayer를 삭제한다. Layer 삭제와 동시에 Layer에 추가되어있던 LodPoi도 모두 삭제된다.
/// \param layerID 삭제할 LodLabelLayer의 ID
///
- (void)removeLodLabelLayerWithLayerID:(NSString * _Nonnull)layerID;
/// LodLabelLayer를 모두 삭제한다.
/// KakaoMap에 등록된 모든 LodLabelLayer를 삭제한다. Layer 삭제와 동시에 Layer에 추가되어있던 LodPoi도 모두 삭제된다.
- (void)clearAllLodLabelLayers;
/// 추가한 LodLabelLayer를 가져온다.
/// \param layerID 가져올 LodLabelLayer ID
///
///
/// returns:
/// LodLabelLayer
- (LodLabelLayer * _Nullable)getLodLabelLayerWithLayerID:(NSString * _Nonnull)layerID SWIFT_WARN_UNUSED_RESULT;
/// PoiAnimator를 추가한다.
/// PoiAnimator 객체는 사용자가 직접 생성할 수 없으며, Manager를 통해서만 생성 가능하다.
/// seealso:
/// PoiAnimator
/// seealso:
/// AnimationInterpolation
/// \param animatorID 추가할 animatorID
///
/// \param effect 애니메이션 효과 지정
///
///
/// returns:
/// 생성된 PoiAnimator
- (PoiAnimator * _Nullable)addPoiAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID effect:(id <PoiAnimationEffect> _Nonnull)effect SWIFT_WARN_UNUSED_RESULT;
/// 추가한 PoiAnimator를 삭제한다.
/// \param animatorID 삭제할 PoiAnimator ID
///
- (void)removePoiAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID;
/// 추가한 모든 PoiAnimator를 제거한다.
- (void)clearAllPoiAnimators;
/// 추가한 Animator를 가져온다.
/// \param animatorID animatorID
///
///
/// returns:
/// PoiAnimator
- (PoiAnimator * _Nullable)getPoiAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class LodPoi;

/// 대량의 Poi( ex. 즐겨찾기 )를 관리하는 단위인 LodLabelLayer 클래스
/// 대량의 Poi를 추가할땐 LabelLayer가 아닌 LodLabelLayer를 이용하여 경쟁처리를 하면 빠르게 Poi를 보여줄 수 있다.
/// LodLabelLayer에 추가된 LodPoi는 일반 Poi객체와는 다르게 이동/회전에 대한 인터페이스가 존재하지 않는다.
/// 사용자가 직접 객체를 생성할 수 없으며, LabelManager를 통해 객체를 간접적으로 생성할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK13LodLabelLayer")
@interface LodLabelLayer : NSObject
/// LodLabelLayer의 visible 상태.
/// layer의 on/off 상태를 나타내며, layer에 속한 객체의 show/hide는 별도로 동작시켜야한다.
/// 즉, layer의 visible이 true여도 layer에 속한 객체의 show를 호출해야 보이고, visible이 false라면 layer에 속한 객체는 화면에 표시되지 않는다.
@property (nonatomic) BOOL visible;
/// 현재 Layer에 있는 모든 item을 일괄적으로 지운다.
- (void)clearAllItems;
/// 현재 Layer에 있는  Exit Transition 속성을 가진 LodPoi를 지운다.
- (void)clearAllExitTransitionLodPois;
/// 현재 레이어의 clickable 속성을 지정한다.
/// \param clickable 클릭 설정 여부. 해당 레이어에 속한 모든 Poi에 적용된다.
///
- (void)setClickable:(BOOL)clickable;
/// 현재 Layer에 LodPoi를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// \param option 생성할 LodPoi의 옵션
///
/// \param at 생성할 LodPoi의 위치
///
/// \param callback LodPoi 생성이 완료되고나면 호출할 callback(optional)
///
///
/// returns:
/// 생성된 LodPoi 객체
- (LodPoi * _Nullable)addLodPoiWithOption:(PoiOptions * _Nonnull)option at:(MapPoint * _Nonnull)position callback:(void (^ _Nullable)(LodPoi * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 같은 옵션을 가지는 다수의 LodPoi를 추가한다.
/// 같은 옵션을 가지지만 위치만 다른 LodPoi를 생성할 경우 사용한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// \param option 생성할 LodPoi의 옵션
///
/// \param at 생성할 LodPoi의 위치 배열
///
/// \param callback LodPoi 생성이 모두 완료되고나면 호출할 callback (optional)
///
///
/// returns:
/// 생성된 LodPoi 객체
- (NSArray<LodPoi *> * _Nullable)addLodPoisWithOption:(PoiOptions * _Nonnull)option at:(NSArray<MapPoint *> * _Nonnull)positions callback:(void (^ _Nullable)(NSArray<LodPoi *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 다른 옵션을 가지는 다수의 LodPoi를 추가한다.
/// LodPoi별로 다른 옵션을 가지는 경우 사용한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// warning:
/// 여러개의 옵션으로 여러개의 poi를 생성하는 경우, option과 position의 pair가 일치해야한다. 즉, position하나당 option 하나의 짝을 맞추어야 한다.
/// \param options 생성할 LodPoi의 옵션 배열
///
/// \param at 생성할 LodPoi 위치
///
/// \param callback LodPoi 생성이 모두 완료되고나면 호출할 callback (optional)
///
///
/// returns:
/// 생성된 LodPoi 객체배열
- (NSArray<LodPoi *> * _Nullable)addLodPoisWithOptions:(NSArray<PoiOptions *> * _Nonnull)options at:(NSArray<MapPoint *> * _Nonnull)positions callback:(void (^ _Nullable)(NSArray<LodPoi *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정  LodPoi를 지운다.
/// \param poiID LodLabelLayer에서 제거할 LodPoi Id
///
/// \param callback 해당 LodPoi 제거가 완료되면 호출할 callback(optional)
///
- (void)removeLodPoiWithPoiID:(NSString * _Nonnull)poiID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 여러개의 LodPoi를 지운다.
/// \param poiIDs LodLabelLayer에서 제거할 LodPoi Id 배열
///
/// \param callback 해당 LodPoi 제거가 모두 완료되면 호출할 callback(optional)
///
- (void)removeLodPoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속해있는 LodPoi를 모두 보여준다.
- (void)showAllLodPois;
/// 현재 Layer에 속해있는 모든 LodPoi를 숨긴다.
- (void)hideAllLodPois;
/// 현재 Layer에 속한 특정 LodPoi를 보여준다.
/// \param poiIDs 보여줄 LodPoi ID 배열
///
- (void)showLodPoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs;
/// 현재 Layer에 속한 특정 LodPoi를 숨긴다.
/// \param poiIDs 숨길 LodPoi ID 배열
///
- (void)hideLodPoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs;
/// 현재 Layer에 속한 LodPoi를 가져온다.
/// \param poiID 가져올 LodPoi ID
///
///
/// returns:
/// ID에 해당하는 LodPoi 객체, 없을경우 ni.
- (LodPoi * _Nullable)getLodPoiWithPoiID:(NSString * _Nonnull)poiID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 여러개의 LodPoi를 가져온다.
/// \param poiIDs 가져올 LodPoi ID 배열
///
///
/// returns:
/// ID에 해당하는 LodPoi 객체 배열, 없을경우 ni.
- (NSArray<LodPoi *> * _Nullable)getLodPoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 LodPoi를 가져온다.
///
/// returns:
/// 현재 Layer에 속한 모든 LodPod.
- (NSArray<LodPoi *> * _Nullable)getAllLodPois SWIFT_WARN_UNUSED_RESULT;
/// layer의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// layer에 속한 Poi가 경쟁하는 방법을 지정한다.
/// Layer의 우선순위(zOrder)에 따라 Poi끼리 겹쳐졌을 때, Poi가 표시될 정책을 지정한다.
/// seealso:
/// CompetitionType
@property (nonatomic, readonly) CompetitionType competitionType;
/// Poi가 경쟁할 때, 경쟁을 하는 단위를 선택한다.
/// seealso:
/// CompetitionUnit
@property (nonatomic, readonly) CompetitionUnit competitionUnit;
/// competitionType이 same일 경우, 경쟁을 하는 기준이 된다.
/// seealso:
/// OrderingType
@property (nonatomic, readonly) OrderingType orderType;
/// layer의 렌더링 우선순위
/// zOrder는 같은 LabelLayer타입끼리만 유효하며, 기본적으로 zOrder 값이 클수록 더 높은 우선권을 가진다.
@property (nonatomic) NSInteger zOrder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// LodLabelLayer 생성 옵션
SWIFT_CLASS("_TtC12KakaoMapsSDK20LodLabelLayerOptions")
@interface LodLabelLayerOptions : NSObject
/// initializer
/// \param layerID layer ID
///
/// \param competitionType 다른 poi와 경쟁하는 방법
///
/// \param competitionUnit 경쟁을 하는 단위
///
/// \param orderType competitionType이 same일 때, 경쟁하는 기준
///
/// \param zOrder layer의 zOrder. 값이 클수록 위에 그려진다.
///
/// \param radius LOD를 계산할 때 사용하는 반경 원의 반지름
///
- (nonnull instancetype)initWithLayerID:(NSString * _Nonnull)layerID competitionType:(CompetitionType)competitionType competitionUnit:(CompetitionUnit)competitionUnit orderType:(OrderingType)orderType zOrder:(NSInteger)zOrder radius:(float)radius OBJC_DESIGNATED_INITIALIZER;
/// layerID
@property (nonatomic, copy) NSString * _Nonnull layerID;
/// 다른 poi와 경쟁하는 방법을 지정한다. 해당 레이어에 속한 poi는 모두 해당 방법으로 경쟁한다.
@property (nonatomic) CompetitionType competitionType;
/// 경쟁할 때 단위를 지정한다. 해당 레이어에 속한 poi는 모두 해당 방법으로 경쟁한다.
@property (nonatomic) CompetitionUnit competitionUnit;
/// competitionType이 same일 때 경쟁하는 기준을 설정한다.
@property (nonatomic) OrderingType orderType;
/// layer의 zOrder
/// zOrder는 같은 LodLabelLayer타입끼리만 유효하며, zOrder 값이 클수록 더 위에 그려진다
/// 즉, zOrder가 0인 LodLabelLayer는에 속한 Label은 zOrder가 1인 LodLabelLayer에 속한 Label보다 아래에 그려진다.
@property (nonatomic) NSInteger zOrder;
/// Lod 처리시 계산하는 반경
@property (nonatomic) float radius;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PoiText;
@class PoiBadge;

/// 지도상에 대량의 Poi를 그리기 위한 클래스
/// Lod 처리를 통해 성능저하를 줄이면서 대량의 Poi를 표시하고자 할 때 사용한다.
/// LodPoi를 추가하기 위해서는 먼저 KakaoMap에 LodLabelLayer를 추가한 뒤, 해당 Layer에 LodPoi를 추가할 수 있다.
/// show, hide, style 변경이 가능하며, Poi마다 개별 badge를 추가할 수 있다.
/// 레벨별로 충돌검사를 하는 LOD 처리가 들어가므로, 이동 및 회전에 대한 interface는 존재하지 않는다.
/// LodPoi는 사용자가 직접 생성할 수 없으며, PoiOptions class를 이용하여 LodLabelLayer에 추가하면 해당 Object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK6LodPoi")
@interface LodPoi : NSObject <Label>
/// LodPoi를 보여준다.
- (void)show;
/// LodPoi를 표시하고, 해당 위치로 이동한다.
/// \param callback LodPoi위치로 카메라 이동이 끝났을 때, 호출할 callback ( optional)
///
- (void)showWithAutoMoveWithCallback:(void (^ _Nullable)(void))callback;
/// LodPoi를 숨긴다.
- (void)hide;
/// LodPoi의 Style을 바꾼다.
/// LabelManager에 등록한 PoiStyle의 키를 이용하여 Style을 변경한다.
/// \param styleID 변경할 Style의 ID
///
/// \param enableTransition 변경시 trasition 효과 적용 여부
///
- (void)changeStyleWithStyleID:(NSString * _Nonnull)styleID enableTransition:(BOOL)enableTransition;
/// LodPoi의 text와 style을 변경한다.
/// LodPoi의 text와 style을 바꿀 때 사용한다.
/// \param texts 바꾸고자 하는 LodPoi의 text
///
/// \param styleID 변경할 styleID.
///
/// \param enableTransition Style 변경시 trasition 효과 적용 여부
///
- (void)changeTextAndStyleWithTexts:(NSArray<PoiText *> * _Nonnull)texts styleID:(NSString * _Nonnull)styleID enableTransition:(BOOL)enableTransition;
/// 개별 Poi에 Badge를 추가한다.
/// seealso:
/// PoiBadge
/// \param badge 추가할 Poi Badge
///
- (void)addBadge:(PoiBadge * _Nonnull)badge;
/// 개별 Poi에 여러개의 Badge를 추가한다.
/// seealso:
/// PoiBadge
/// \param badges 추가할 Poi Badge 배열
///
- (void)addBadges:(NSArray<PoiBadge *> * _Nonnull)badges;
/// Poi에 추가된 뱃지를 지운다.
/// Poi에 등록된 Badge ID를 이용하여 지운다.
/// note:
/// PoiStyle에 추가되어있는 In-Style Badge는 스타일에 종속되므로, 해당 함수로 지울 수 없다.
/// \param badgeID 지우고자하는 badge의 ID
///
- (void)removeBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi에 등록된 Badge를 일괄 지운다.
/// note:
/// PoiStyle에 추가되어있는 In-Style Badge는 스타일에 종속되므로, 해당 함수를 호출해도 지워지지 않는다.
- (void)removeAllBadge;
/// Poi에 등록되어있는 Badge를 보여준다.
/// \param badgeID 보여주고자 하는 badge의 ID
///
- (void)showBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi에 등록되어있는 Badge들을 보여준다.
/// \param badgeIDs 보여주고자 하는 badge의 ID 배열
///
- (void)showBadgesWithBadgeIDs:(NSArray<NSString *> * _Nonnull)badgeIDs;
/// Poi에 등록되어있는 Badge를 숨긴다.
/// \param badgeID 숨기고자 하는 badge의 ID
///
- (void)hideBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi에 등록되어있는 Badge들을 숨긴다.
/// \param badgeIDs 숨기고자 하는 badge의 ID 배열
///
- (void)hideBadgesWithBadgeIDs:(NSArray<NSString *> * _Nonnull)badgeIDs;
/// Poi의 In-Style badge를 보여준다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 badge를 보여준다.
/// \param badgeID 보여주고자 하는 In-Style badge의 ID
///
- (void)showStyleBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi의 In-Style badge를 모두 보여준다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 모든 badge를 보여준다.
- (void)showAllStyleBadges;
/// Poi의 In-Style badge를 숨긴다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 badge를 숨긴다.
/// \param badgeID 숨기고자 하는 In-Style badge의 ID
///
- (void)hideStyleBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi의 In-Style badge를 모두 숨긴다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 모든 badge를 숨긴다.
- (void)hideAllStyleBadges;
/// Poi가 속한 LayerID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// Poi의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull itemID;
/// LodPoi의 렌더링 우선순위
/// 새로운 rank로 값을 assign 하면, 해당 LodPoi의 rank가 업데이트된다.
@property (nonatomic) NSInteger rank;
/// LodPoi의 Clickable 여부
/// clickable 여부를 새로 assign하면, LodPoi의 click여부가 업데이트된다.
@property (nonatomic) BOOL clickable;
/// LodPoi가 현재 뷰에 보여지고 있는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 좌표계 및 좌표계 변환을 담당하는 클래스
/// 지원하는 좌표계 : WTM(5181), WCONG, WGS84(4326), Kakao(3857)
SWIFT_CLASS("_TtC12KakaoMapsSDK17MapCoordConverter")
@interface MapCoordConverter : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// WCong 좌표를 WGS84 좌표로 변환한다.
/// \param wcong 변환할 WCong 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WGS84 경위도 좌표
+ (struct GeoCoordinate)fromWCongToWGS84WithWcong:(struct CartesianCoordinate)wcong SWIFT_WARN_UNUSED_RESULT;
/// WCong 좌표를 Kakao 좌표로 변환한다.
/// \param wcong 변환할 wcong 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// Kakao  좌표
+ (struct CartesianCoordinate)fromWCongToKakaoWithWcong:(struct CartesianCoordinate)wcong SWIFT_WARN_UNUSED_RESULT;
/// WCong 좌표를 WTM 좌표로 변환한다.
/// \param wcong 변환할 wcong 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WTM  좌표
+ (struct CartesianCoordinate)fromWCongToWTMWithWcong:(struct CartesianCoordinate)wcong SWIFT_WARN_UNUSED_RESULT;
/// WTM 좌표를 WCong 좌표로 변환한다.
/// \param wtm 변환할 WTM 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WCong  좌표
+ (struct CartesianCoordinate)fromWTMToWCongWithWtm:(struct CartesianCoordinate)wtm SWIFT_WARN_UNUSED_RESULT;
/// WTM 좌표를 WGS84 좌표로 변환한다.
/// \param wtm 변환할 WTM 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WGS84 경위도  좌표
+ (struct GeoCoordinate)fromWTMToWGS84WithWtm:(struct CartesianCoordinate)wtm SWIFT_WARN_UNUSED_RESULT;
/// WTM 좌표를 Kakao 좌표로 변환한다.
/// \param wtm 변환할 WTM 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// Kakao  좌표
+ (struct CartesianCoordinate)fromWTMToKakaoWithWtm:(struct CartesianCoordinate)wtm SWIFT_WARN_UNUSED_RESULT;
/// WGS84 좌표를 WCong 좌표로 변환한다.
/// \param wgs 변환할 WGS84 좌표를 나타내는 경위도좌표 값
///
///
/// returns:
/// WCong  좌표
+ (struct CartesianCoordinate)fromWGS84ToWCongWithWgs:(struct GeoCoordinate)wgs SWIFT_WARN_UNUSED_RESULT;
/// WGS84 좌표를 WTM 좌표로 변환한다.
/// \param wgs 변환할 WGS84 좌표를 나타내는 경위도좌표 값
///
///
/// returns:
/// WTM  좌표
+ (struct CartesianCoordinate)fromWGS84ToWTMWithWgs:(struct GeoCoordinate)wgs SWIFT_WARN_UNUSED_RESULT;
/// WGS84 좌표를 Kakao 좌표로 변환한다.
/// \param wgs 변환할 WGS84 좌표를 나타내는 경위도좌표 값
///
///
/// returns:
/// Kakao  좌표
+ (struct CartesianCoordinate)fromWGS84ToKakaoWithWgs:(struct GeoCoordinate)wgs SWIFT_WARN_UNUSED_RESULT;
/// Kakao 좌표를 WGS84 좌표로 변환한다.
/// \param kakao 변환할 Kakao 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WGS84  좌표
+ (struct GeoCoordinate)fromKakaoToWGS84WithKakao:(struct CartesianCoordinate)kakao SWIFT_WARN_UNUSED_RESULT;
/// Kakao 좌표를 WTM 좌표로 변환한다.
/// \param kakao 변환할 Kakao 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WTM  좌표
+ (struct CartesianCoordinate)fromKakaoToWTMWithKakao:(struct CartesianCoordinate)kakao SWIFT_WARN_UNUSED_RESULT;
/// Kakao 좌표를 WCong 좌표로 변환한다.
/// \param kakao 변환할 Kakao 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WCong  좌표
+ (struct CartesianCoordinate)fromKakaoToWCongWithKakao:(struct CartesianCoordinate)kakao SWIFT_WARN_UNUSED_RESULT;
@end


/// 지도상의 위치를 나타내기 위한 클래스. WGS84(4326) 좌표계를 지원한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8MapPoint")
@interface MapPoint : NSObject
/// Initializer
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Initializer
/// WGS84 경위도좌표계 좌표값으로 MapPoint를 생성한다.
/// \param longitude 경도값
///
/// \param latitude 위도값
///
- (nonnull instancetype)initWithLongitude:(double)longitude latitude:(double)latitude;
/// Initializer
/// 다른 MapPoint 객체로부터 복사한 값으로 새로운 MapPoint 객체를 생성한다.
/// \param from 값을 가져올 MapPoint
///
- (nonnull instancetype)initFrom:(MapPoint * _Nonnull)from;
/// WGS84 좌표값
@property (nonatomic, readonly) struct GeoCoordinate wgsCoord;
@end



/// MapPolygonShape를 구성할 때 사용하는 MapPolygon 클래스.
/// 폴리곤은 단독으로 Map에 추가할 수 없으며, Shape에 종속되는 객체이다.
/// 하나의 외곽선과 hole을 넣어서 구성할 수 있다. 외곽선 point인 exterior ring과 폴리곤 내부 홀을 표시하는 holes로 구성된다.
/// exteriorRing, 즉 외곽선은 시계방향으로 MapPoint를 넣어야 하고, hole은 시계반대방향으로 MapPoint를 넣어야한다.
/// MapPolygon의 Point는 지도좌표계(ex. 3857)타입의 MapPoint로만 구성한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10MapPolygon")
@interface MapPolygon : NSObject
/// initializer
/// \param exteriorRing MapPolygon의 외곽선
///
/// \param holes MapPolygon의 hole 배열. hole이 없을경우 nil로 지정
///
/// \param styleIndex PolygonStyleSet에서 사용할 PolygonStyle 인덱스
///
- (nonnull instancetype)initWithExteriorRing:(NSArray<MapPoint *> * _Nonnull)exteriorRing holes:(NSArray<NSArray<MapPoint *> *> * _Nullable)holes styleIndex:(NSUInteger)styleIndex OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param exteriorRing Polygon의 외곽선
///
/// \param hole Polygon의 하나의 hole. hole이 없을경우 nil로 지정
///
/// \param styleIndex PolygonStyleSet에서 사용할 PolygonStyle 인덱스
///
- (nonnull instancetype)initWithExteriorRing:(NSArray<MapPoint *> * _Nonnull)exteriorRing hole:(NSArray<MapPoint *> * _Nullable)hole styleIndex:(NSUInteger)styleIndex;
/// Polygon의 외곽선.
/// 시계방향의 MapPoint 배열로 구성한다.
@property (nonatomic, readonly, copy) NSArray<MapPoint *> * _Nonnull exteriorRing;
/// MapPolygon의 holes
/// 0개 이상으로 구성되며, 반시계방향의 MapPoint 배열로 구성한다.
@property (nonatomic, readonly, copy) NSArray<NSArray<MapPoint *> *> * _Nullable holes;
/// PolygonStyleSet에서 사용할 표출 스타일 인덱스를 지정한다.
@property (nonatomic, readonly) NSUInteger styleIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Shape protocol
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK5Shape_")
@protocol Shape
/// Shape 표출
- (void)show;
/// Shape 숨김
- (void)hide;
/// Shape ID
@property (nonatomic, readonly, copy) NSString * _Nonnull shapeID;
/// Shape이 속한 레이어 ID
@property (nonatomic, readonly, copy) NSString * _Nullable layerID;
/// Shape orientation
@property (nonatomic) double orientation;
/// Shape 표출 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
@end


/// 지도상에 특정 영역을 2d Polygon으로 표시하는 MapPolygonShape 클래스.
/// 지도 위 특정 위치에 의미있는 면형을 표시하기 위해 사용된다.
/// 따라서 PolygonShape와는 다르게, basePosition 없이  좌표계( ex. 3857 )로 구성되어있는 정점으로만 구성한다.
/// MapPolygonShape를 추가하기 위해서는 먼저 KakaoMap에 ShapeLayer를 추가한 뒤, 해당 Layer에 MapPolygonShape를 추가할 수 있다.
/// show, hide, style변경 및 이동/회전이 가능하다.
/// MapPolygonShape는 사용자가 직접 생성할 수 없으며, MapPolygonShapeOptions class를 이용하여 Layer에 추가하면 해당 object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK15MapPolygonShape")
@interface MapPolygonShape : NSObject <Shape>
/// MapPolygonShape를 보여준다.
- (void)show;
/// MapPolygonShape를 숨긴다.
- (void)hide;
/// MapPolygonShape의 style과 Data를 변경한다.
/// MapPolygonShape의 Style과 MapPolygonShape가 표시하는 polgyon Data를 변경하고자 할 때 사용한다. 단, polygon Data를 바꿀때는 해당 MapPolygonShape 객체가 가리키는 본질이 변하지 않을때만 사용한다. 즉 전혀 다른 MapPolygonShape 객체일때는 MapPolygonShape를 하나 더 만드는것을 권장한다.
/// \param styleID 변경할 styleID
///
/// \param polygons 업데이트 할 폴리곤 데이터.
///
- (void)changeStyleAndDataWithStyleID:(NSString * _Nonnull)styleID polygons:(NSArray<MapPolygon *> * _Nonnull)polygons;
/// shape가 속한 layerID
@property (nonatomic, readonly, copy) NSString * _Nullable layerID;
/// ShapeID.
@property (nonatomic, readonly, copy) NSString * _Nonnull shapeID;
/// PolygonShape의 현재 orientation값
/// 새로운 orientation값으로 assign할 경우, PolygonShape의 orientation이 변경된다.
@property (nonatomic) double orientation;
/// PolygonShape가 현재 지도에 표시되는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// MapPolygonShape생성 옵션 클래스.
/// MapPolygonShape는 지도상의 특정 위치에 의미있는 면형을 표시하기 위해 사용한다.
/// PolygonShape와는 다르게, basePosition없이 지도 좌표계로 구성되어있는 점으로만 폴리곤을 구성한다.
/// MapPolygonShape는 1개 이상의 MapPolygon으로 구성된다. MapPolygon은 지도 좌표계(ex. 3857)로 구성할 수 있다.
/// StyleSetPolygonShape에 속한 Polygon마다 StyleSet을 이용하여 다르게 표출할 수도 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK22MapPolygonShapeOptions")
@interface MapPolygonShapeOptions : NSObject
/// initializer
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 값이 클수록 위에 그려진다.
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param shapeID Shape의 ID
///
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 값이 클수록 위에 그려진다.
///
- (nonnull instancetype)initWithShapeID:(NSString * _Nonnull)shapeID styleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// Shape의 ID
@property (nonatomic, readonly, copy) NSString * _Nullable shapeID;
/// Shape가 표출될 StyleID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
/// Shape의 렌더링 우선순위
/// 높을수록 더 위에 그려지며, Shape type끼리만 유효하다.
/// 즉, zOrder = 0 인 Shape는 zOrder = 1 인 shape보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
/// Shape에 속한 폴리곤.
/// 1개 이상의 폴리곤으로 구성된다.
/// seealso:
/// MapPolygon
@property (nonatomic, copy) NSArray<MapPolygon *> * _Nonnull polygons;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// MapPolylineShape를 구성할 때 사용하는 Polyline 클래스
/// 폴리라인은 단독으로 Map에 추가할 수 없으며, Shape에 종속되는 객체이다.
/// 2개 이상의 MapPoint로 만들어진 라인으로 구성된다. 폴리라인의 캡 스타일도 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK11MapPolyline")
@interface MapPolyline : NSObject
/// Initializer
/// \param line MapPolyline을 구성하는 MapPoint 배열
///
/// \param styleIndex MapPolyline에 적용할 PolylineStyleSet에 속한 PolylineStyle의 index
///
- (nonnull instancetype)initWithLine:(NSArray<MapPoint *> * _Nonnull)line styleIndex:(NSUInteger)styleIndex OBJC_DESIGNATED_INITIALIZER;
/// 라인. 2개 이상의 MapPoint로 구성된다.
@property (nonatomic, readonly, copy) NSArray<MapPoint *> * _Nonnull line;
/// ShapeStyleSet에서 사용할 표출 인덱스
@property (nonatomic, readonly) NSUInteger styleIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 지도상에 특정 선형을 2d Polyline으로 표시하는  PolylineShape 클래스.
/// 지도 위 특정 위치에 의미있는 선형을 표시하기 위해 사용된다.
/// 따라서 PolylineShape와는 다르게, basePosition 없이  좌표계( ex. 3857 )로 구성되어있는 정점으로만 구성한다.
/// MapPolylineShape를 추가하기 위해서는 먼저 KakaoMap에 ShapeLayer를 추가한 뒤, 해당 Layer에 MapPolylineShape를 추가할 수 있다.
/// show, hide, style변경 및 이동/회전이 가능하다.
/// MapPolylineShape는 사용자가 직접 생성할 수 없으며, MapPolylineShapeOptions class를 이용하여 Layer에 추가하면 해당 Object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK16MapPolylineShape")
@interface MapPolylineShape : NSObject <Shape>
/// MapPolylineShape를 보여준다.
- (void)show;
/// MapPolylineShape를 숨긴다.
- (void)hide;
/// MapPolylineShape의 style과 Data를 변경한다.
/// MapPolylineShape의 style과 표시하는 MapPolyline Data를 변경하고자 할 때 사용한다.
/// 단, MapPolyline Data를 바꿀때는 해당 MapPolylineShape 객체가 가리키는 본질이 변하지 않을때만 사용한다.
/// 즉 전혀 다른 MapPolylineShape 객체일때는 MapPolylineShape를 하나 더 만드는것을 권장한다.
/// \param styleID 변경할 styleID
///
/// \param lines 업데이트 할 폴리라인 데이터.
///
- (void)changeStyleAndDataWithStyleID:(NSString * _Nonnull)styleID lines:(NSArray<MapPolyline *> * _Nonnull)lines;
/// Shape가 속한 layerID
@property (nonatomic, readonly, copy) NSString * _Nullable layerID;
/// Shape의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull shapeID;
/// MapPolylineShape의 Orientation (radian)
/// 새로운 orientation값을 assign하면, PolylineShape의 orientation 값이 업데이트된다.
@property (nonatomic) double orientation;
/// MapPolylineShape가 현재 지도에 표시되는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// MapPolylineShape 생성 옵션 클래스.
/// MapPolylineShape는 지도상의 특정 위치에 의미있는 선형을 표시하기 위해 사용한다.
/// PolylineShape와는 다르게, basePosition 없이 지도 좌표계로 구성되어있는 점으로만 폴리라인을 구성한다.
/// MapPolylineShape는 1개 이상의 MapPolyline으로 구성된다. MapPolyline은 지도 좌표계(ex. 3857)로 구성할 수 있다.
/// Style은 PolylineShape에 속한 Polyline마다 StyleSet을 이용하여 다르게 적용할 수 있다.
/// PolylineShape의 id를 별도로 지정하지 않는 경우, 내부적으로 자동으로 부여한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK23MapPolylineShapeOptions")
@interface MapPolylineShapeOptions : NSObject
/// initializer
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 값이 높을수록 위에 그려진다.
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param shapeID Shape의 ID
///
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 값이 높을수록 위에 그려진다.
///
- (nonnull instancetype)initWithShapeID:(NSString * _Nonnull)shapeID styleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// Shape의 ID
@property (nonatomic, readonly, copy) NSString * _Nullable shapeID;
/// Shape가 표출될 StyleID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
/// Shape의 렌더링 우선순위
/// 높을수록 더 위에 그려지며, Shape type끼리만 유효하다.
/// 즉, zOrder = 0 인 Shape는 zOrder = 1 인 shape보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
/// Shape에 속한 MapPolyline 배열
/// 1개 이상의 폴리라인으로 구성된다.
/// seealso:
/// MapPolyline
@property (nonatomic, copy) NSArray<MapPolyline *> * _Nonnull polylines;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// API에서 보여줄 View의 이름과 종류, 사용할 설정을 지정한다.
/// View를 어떻게 보여줄지에 대한 세부 설정은 config file로 컨피그 서버에 저장되어 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8ViewInfo")
@interface ViewInfo : NSObject
/// ViewInfo의 종류.
@property (nonatomic, readonly) ViewInfoType viewInfoType;
/// Cocoa에 등록된 app 이름.
@property (nonatomic, readonly, copy) NSString * _Nonnull appName;
/// View의 이름.
@property (nonatomic, readonly, copy) NSString * _Nonnull viewName;
/// 사용할 viewInfo의 이름. ex)’map’
@property (nonatomic, readonly, copy) NSString * _Nonnull viewInfoName;
/// 초기 활성화 여부
@property (nonatomic, readonly) BOOL enabledInitially;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 지도 ViewInfo. KakaoMap으로 view가 생성된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK11MapviewInfo")
@interface MapviewInfo : ViewInfo
/// 초기 위치
@property (nonatomic, readonly, strong) MapPoint * _Nonnull defaultPosition;
/// 초기 레벨
@property (nonatomic, readonly) NSInteger defaultLevel;
@end


@interface MapviewInfo (SWIFT_EXTENSION(KakaoMapsSDK))
/// Initializer
/// \param viewName view의 이름
///
/// \param appName Cocoa에 등록된 app 이름. 따로 등록된 내용이 없을 경우 “openmap” 사용.
///
/// \param viewInfo viewInfo의 이름.
///
/// \param defaultPosition 초기 위치(MapView인 경우). 기본값은 서울시청.
///
/// \param defaultLevel 초기 레벨(MapView인 경우). 기본값은 17.
///
/// \param enabled 초기 활성화 여부. 기본값은 true.
///
- (nonnull instancetype)initWithViewName:(NSString * _Nonnull)viewName appName:(NSString * _Nonnull)appName viewInfoName:(NSString * _Nonnull)viewInfoName defaultPosition:(MapPoint * _Nullable)defaultPosition defaultLevel:(NSInteger)defaultLevel enabled:(BOOL)enabled;
@end


/// PanoramaView에 표시할 Marker 클래스.
SWIFT_CLASS("_TtC12KakaoMapsSDK14PanoramaMarker")
@interface PanoramaMarker : NSObject
/// PanoramaMarker의 타입
/// seealso:
/// PanoramaMarkerType
@property (nonatomic, readonly) PanoramaMarkerType markerType;
/// PanoramaMarker가 표시될 방향의 pan 값
@property (nonatomic, readonly) double pan;
/// PanoramaMarker가 표시될 방향의 tilt 값
@property (nonatomic, readonly) double tilt;
/// PanoramaMarker가 표시될 위치
@property (nonatomic, readonly, strong) MapPoint * _Nullable position;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PoiIconStyle;
@class PoiTextStyle;

/// 특정레벨에 적용될 라벨스타일을 지정하는 클래스.
/// PoiStyle을 하나 이상의 PerLevelPoiStyle로 구성할 수 있다.
/// PerLevelPoiStyle에 지정된 레벨에서부터 하위의 PerLevelStyle이 지정된 레벨이 되기전까지 적용된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK16PerLevelPoiStyle")
@interface PerLevelPoiStyle : NSObject
/// initializer
/// \param iconStyle Poi의 IconStyle.
///
/// \param textStyle Poi의 TextStyle
///
/// \param padding padding
///
/// \param level 해당 Style이 표출되기 시작할 레벨. 특정 레벨에서 해당 표출 레벨의 iconStyle, 혹은 textStyle이 추가되지 않은 경우, Poi 심볼이나 텍스트가 표시되지 않는다.
///
- (nonnull instancetype)initWithIconStyle:(PoiIconStyle * _Nonnull)iconStyle textStyle:(PoiTextStyle * _Nonnull)textStyle padding:(float)padding level:(NSInteger)level OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param iconStyle Poi의 IconStyle
///
/// \param padding padding
///
/// \param level 해당 Style이 표출되기 시작할 레벨
///
- (nonnull instancetype)initWithIconStyle:(PoiIconStyle * _Nonnull)iconStyle padding:(float)padding level:(NSInteger)level OBJC_DESIGNATED_INITIALIZER;
/// Poi의 IconStyle
/// seealso:
/// PoiIconStyle
@property (nonatomic, readonly, strong) PoiIconStyle * _Nonnull iconStyle;
/// Poi의 TextStyle
/// seealso:
/// PoiTextStyle
@property (nonatomic, readonly, strong) PoiTextStyle * _Nullable textStyle;
/// padding
@property (nonatomic, readonly) float padding;
/// Style이 표출되기 시작할 레벨
@property (nonatomic, readonly) NSInteger level;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolygonStyle Unit 클래스.
/// Level별 PolygonStyle을 구성할 때 사용한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK20PerLevelPolygonStyle")
@interface PerLevelPolygonStyle : NSObject
/// initializer
/// \param color PolygonShape의 색깔
///
/// \param storkeWidth PolygonShape의 외곽선 두께
///
/// \param storkeColor PolygonShape의 외곽선 색깔
///
/// \param level 해당 단위 스타일이 표출 될 레벨
///
- (nonnull instancetype)initWithColor:(UIColor * _Nonnull)color strokeWidth:(NSUInteger)strokeWidth strokeColor:(UIColor * _Nonnull)strokeColor level:(NSInteger)level OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param color PolygonShape의 색깔
///
/// \param level 해당 단위 스타일이 표출 될 레벨
///
- (nonnull instancetype)initWithColor:(UIColor * _Nonnull)color level:(NSInteger)level;
/// Shape의 색깔.
@property (nonatomic, readonly, strong) UIColor * _Nonnull color;
/// Shape의 외곽선 두께. 지정하지 않을 경우 0
@property (nonatomic, readonly) NSUInteger strokeWidth;
/// Shape의 외곽선 색깔. 지정하지 않을 경우 투명.
@property (nonatomic, readonly, strong) UIColor * _Nonnull strokeColor;
/// 해당 스타일이 표출될 레벨 .
@property (nonatomic, readonly) NSInteger level;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PerLevelPolylineStyle의 단위 클래스
/// level별 PolylineStyle을 구성할 때 사용한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK21PerLevelPolylineStyle")
@interface PerLevelPolylineStyle : NSObject
/// Initializer
/// \param bodyColor Polyline의 body 색상
///
/// \param bodyWidth Polyline의 body 두께
///
/// \param strokeColor Polyline의 외곽선 색깔
///
/// \param storkeWidth Polyline의 외곽선 두께
///
/// \param level 해당 단위스타일이 표출될 레벨
///
- (nonnull instancetype)initWithBodyColor:(UIColor * _Nonnull)bodyColor bodyWidth:(NSUInteger)bodyWidth strokeColor:(UIColor * _Nonnull)strokeColor strokeWidth:(NSUInteger)strokeWidth level:(NSInteger)level OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param bodyColor Polyline의 body 색상
///
/// \param bodyWidth Polyline의 body 두께
///
/// \param level 해당 단위스타일이 표출될 레벨
///
- (nonnull instancetype)initWithBodyColor:(UIColor * _Nonnull)bodyColor bodyWidth:(NSUInteger)bodyWidth level:(NSInteger)level;
/// Polyline의 Body 색깔.
@property (nonatomic, readonly, strong) UIColor * _Nonnull bodyColor;
/// Polyline의 Body 두께
@property (nonatomic, readonly) NSUInteger bodyWidth;
/// Polyline의 외곽선 색깔
@property (nonatomic, readonly, strong) UIColor * _Nonnull strokeColor;
/// Polyline의 외곽선 두께
@property (nonatomic, readonly) NSUInteger strokeWidth;
/// 해당 단위 스타일이 표출될 레벨
@property (nonatomic, readonly) NSInteger level;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PerLevelRouteStyle 단위 클래스.
/// Level별 Route Style을 구성할 때 사용한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK18PerLevelRouteStyle")
@interface PerLevelRouteStyle : NSObject
/// Initializer
/// \param width Route Width
///
/// \param color rotue Color
///
/// \param strokeWidth Route의 외곽선 두께
///
/// \param strokeColor Route의 외곽선 색깔
///
/// \param level 해당 단위 스타일이 표출될 레벨
///
/// \param patternIndex 추가한 패턴의 인덱스
///
- (nonnull instancetype)initWithWidth:(NSUInteger)width color:(UIColor * _Nonnull)color strokeWidth:(NSUInteger)strokeWidth strokeColor:(UIColor * _Nonnull)strokeColor level:(NSInteger)level patternIndex:(NSInteger)patternIndex OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param width Route Width
///
/// \param color rotue Color
///
/// \param level 해당 단위 스타일이 표출될 레벨
///
/// \param patternIndex 추가한 패턴의 인덱스
///
- (nonnull instancetype)initWithWidth:(NSUInteger)width color:(UIColor * _Nonnull)color level:(NSInteger)level patternIndex:(NSInteger)patternIndex;
/// Route의 두께.
@property (nonatomic, readonly) NSUInteger width;
/// Route의 색깔
@property (nonatomic, readonly, strong) UIColor * _Nonnull color;
/// Route의 외곽선 두께
@property (nonatomic, readonly) NSUInteger strokeWidth;
/// Route의 외곽선 색깔
@property (nonatomic, readonly, strong) UIColor * _Nonnull strokeColor;
/// 스타일이 표출될 레벨
@property (nonatomic, readonly) NSInteger level;
/// 추가한 패턴의 인덱스
@property (nonatomic, readonly) NSInteger patternIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PerLevelWaveTextStyle을 표시하기 위한 클래스
/// 하나의 WaveTextStyle을 하나 이상의 PerLevelWaveTextStyle로 구성할 수 있다.
/// PerLevelWaveTextStyle에 지정된 레벨에서부터 하위의 PerLevelWaveTextStyle이 지정된 레벨이 되기전까지 적용된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK21PerLevelWaveTextStyle")
@interface PerLevelWaveTextStyle : NSObject
/// Initializer
/// \param textStyle WaveText의 TextStyle
///
/// \param level 해당 스타일이 표시될 레벨
///
- (nonnull instancetype)initWithTextStyle:(TextStyle * _Nonnull)textStyle level:(NSInteger)level OBJC_DESIGNATED_INITIALIZER;
/// WaveText의 TextStyle
/// seealso:
/// TextStyle
@property (nonatomic, readonly, strong) TextStyle * _Nonnull textStyle;
/// Style이 표출될 level
/// PerLevelWaveTextStyle 단독으로는 사용되지 않으며, WaveTextStyle을 생성할 때 사용된다.
/// seealso:
/// WaveTextStyle
@property (nonatomic, readonly) NSInteger level;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 지도상에 Poi를 그리기 위한 클래스
/// Poi를 추가하기 위해서는 먼저 KakaoMap에 LabelLayer를 추가한 뒤, 해당 Layer에 Poi를 추가할 수 있다.
/// show, hide, style 변경이 가능하며, Poi마다 개별 badge를 추가할 수 있다.
/// 이동, 또는 회전을 하는 애니메이션이 가능하다. 이동 애니메이션중에 다른 애니메이션 동작을 할 경우 기존 이동 애니메이션이 멈춘다. 회전 애니메이션 중에 다른 회전 애니메이션을 할 경우 기존 애니메이션이 멈춘다.
/// Poi는 사용자가 직접 생성할 수 없으며, PoiOptions class를 이용하여 Layer에 추가하면 해당 Object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK3Poi")
@interface Poi : NSObject <Label>
/// Poi를 보여준다.
- (void)show;
/// Poi를 표시하고, 해당 위치로 이동한다.
/// \param callback Poi위치로 카메라 이동이 끝났을 때, 호출할 callback ( optional)
///
- (void)showWithAutoMoveWithCallback:(void (^ _Nullable)(void))callback;
/// Poi를 숨긴다.
- (void)hide;
/// Poi의 Style을 변경한다.
/// LabelManager에 등록한 PoiStyle의 키를 이용하여 Style을 변경한다.
/// \param styleID 변경할 Style의 ID
///
/// \param enableTransition Style 변경시 trasition 효과 적용 여부
///
- (void)changeStyleWithStyleID:(NSString * _Nonnull)styleID enableTransition:(BOOL)enableTransition;
/// Poi의 text와 style을 변경한다.
/// Poi의 text와 style을 바꿀 때 사용한다.
/// \param texts 바꾸고자 하는 PoiText
///
/// \param styleID 변경할 styleID.
///
/// \param enableTransition 변경시 trasition 효과 적용 여부
///
- (void)changeTextAndStyleWithTexts:(NSArray<PoiText *> * _Nonnull)texts styleID:(NSString * _Nonnull)styleID enableTransition:(BOOL)enableTransition;
/// 개별 Poi에 Badge를 추가한다.
/// seealso:
/// PoiBadge
/// \param badge 추가할 Poi Badge
///
- (void)addBadge:(PoiBadge * _Nonnull)badge;
/// 개별 Poi에 여러개의 Badge를 추가한다.
/// seealso:
/// PoiBadge
/// \param badges 추가할 Poi Badge 배열
///
- (void)addBadges:(NSArray<PoiBadge *> * _Nonnull)badges;
/// Poi에 추가된 뱃지를 지운다.
/// Poi에 등록된 Badge ID를 이용하여 지운다.
/// note:
/// PoiStyle에 추가되어있는 In-Style Badge는 스타일에 종속되므로, 해당 함수로 지울 수 없다.
/// \param badgeID 지우고자하는 badge의 ID
///
- (void)removeBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi에 등록된 Badge를 일괄 지운다.
/// note:
/// PoiStyle에 추가되어있는 In-Style Badge는 스타일에 종속되므로, 해당 함수를 호출해도 지워지지 않는다.
- (void)removeAllBadge;
/// Poi에 등록되어있는 Badge를 보여준다.
/// \param badgeID 보여주고자 하는 badge의 ID
///
- (void)showBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi에 등록되어있는 Badge들을 보여준다.
/// \param badgeIDs 보여주고자 하는 badge의 ID 배열
///
- (void)showBadgesWithBadgeIDs:(NSArray<NSString *> * _Nonnull)badgeIDs;
/// Poi에 등록되어있는 Badge를 숨긴다.
/// \param badgeID 숨기고자 하는 badge의 ID
///
- (void)hideBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi에 등록되어있는 Badge들을 숨긴다.
/// \param badgeIDs 숨기고자 하는 badge의 ID 배열
///
- (void)hideBadgesWithBadgeIDs:(NSArray<NSString *> * _Nonnull)badgeIDs;
/// Poi의 In-Style badge를 보여준다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 badge를 보여준다.
/// \param badgeID 보여주고자 하는 In-Style badge의 ID
///
- (void)showStyleBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi의 In-Style badge를 모두 보여준다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 모든 badge를 보여준다.
- (void)showAllStyleBadges;
/// Poi의 In-Style badge를 숨긴다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 badge를 숨긴다.
/// \param badgeID 숨기고자 하는 In-Style badge의 ID
///
- (void)hideStyleBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi의 In-Style badge를 모두 숨긴다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 모든 badge를 숨긴다.
- (void)hideAllStyleBadges;
/// Poi를 지정한 위치로 옮긴다
/// Poi를 지정한 위치로 지정한 시간동안 이동시킨다.
/// \param position 이동시킬 위치
///
/// \param duration 애니메이션 시간
///
- (void)moveAt:(MapPoint * _Nonnull)position duration:(NSUInteger)duration;
/// Poi를 지정한 각도로 회전시킨다.
/// Poi를 지정한 각도로 지정한 시간동안 회전시킨다. 현재 방향을 기준으로 회전하는것이 아니라, 절대회전방위로 이동한다.
/// 회전중에 setOrientation()이 호출되면, 멈춘다.
/// \param roll 회전시킬 각도
///
/// \param duration 애니메이션 시간
///
- (void)rotateAt:(double)roll duration:(NSUInteger)duration;
/// Poi가 특정지점들을 따라서 움직이게 한다.
/// Path를 지정해서 Poi가 해당 path를 따라 움직이게 한다. 단, Poi의 각도는 변하지 않고 지정한 Path를 따라 움직이기만 한다.
/// 이동중에 setPosition / moveAt이 호출되면 멈춘다.
/// \param points Poi가 따라서 움직일 각도
///
/// \param duration 애니메이션 시간
///
/// \param cornerRadius Path중 코너를 통과할 때 부드러운 이동 효과를 주기 위한 곡선으로 처리하는 길이
///
/// \param jumpTreshold 해당 함수 실행중에 새로운 경로가 들어왔을때 현재위치~새 경로 시작점간에 거리에서 점프를 할지에 대한 임계값.
///
- (void)moveOnPath:(NSArray<MapPoint *> * _Nonnull)points duration:(NSUInteger)duration cornerRadius:(float)cornerRadius jumpThreshold:(float)jumpThreshold;
/// Poi가 특정지점들을 따라서 회전하면서 움직이게 한다.
/// Path를 지정해서 Poi가 해당 path를 따라 회전하면서 움직이게 한다. path의 각도에 따라 Poi도 같이 회전한다.
/// \param points Poi가 따라서 움직일 path
///
/// \param baseRadian path가 1개뿐이거나, 진행방향의 역방향으로 path가 들어와 방향을 알 수 없을 때 가이드가 될 radian 값.
///
/// \param duration 애니메이션 시간
///
/// \param cornerRadius Path중 코너를 통과할 때 부드러운 이동 효과를 주기 위한 곡선으로 처리하는 길이
///
/// \param jumpTreshold 해당 함수 실행중에 새로운 경로가 들어왔을때 현재위치~새 경로 시작점간에 거리에서 점프를 할지에 대한 임계값.
///
- (void)moveAndRotateOnPath:(NSArray<MapPoint *> * _Nonnull)points baseRadian:(float)baseRadian duration:(NSUInteger)duration cornerRadius:(float)cornerRadius jumpThreshold:(float)jumpThreshold;
/// 현재 Poi의 position을 공유할 Poi를 추가한다/
/// 파라미터의 Poi가 현재 Poi의 위치만을 따라간다.
/// \param poi 현재 poi의 position을 공유할 poi
///
- (void)sharePositionWithPoi:(Poi * _Nonnull)poi;
/// 현재 Poi와 지정된 poi간에 더이상 position을 공유하지 않게한다.
/// \param poi position공유를 하지 않을 poi
///
- (void)removeSharePositionWithPoi:(Poi * _Nonnull)poi;
/// 현재 Poi의 transform을 공유할 Poi를 추가한다.
/// 파라미터의 Poi가 현재 객체 Poi의 transform을 따라간다.
/// \param poi 현재 poi의 transform을 공유할 poi
///
- (void)shareTransformWithPoi:(Poi * _Nonnull)poi;
/// 현재 Poi와 지정된 poi간에 더이상 transform을 공유하지 않게한다.
/// \param poi transform공유를 하지 않을 poi
///
- (void)removeShareTransformWithPoi:(Poi * _Nonnull)poi;
/// 현재 Poi의 transform을 공유할 Shape를 추가한다.
/// 파라미터의 Shape가 현재 객체 Poi의 transform을 따라간다.
/// \param shape 현재 poi의 transform을 공유할 shape
///
- (void)shareTransformWithShape:(id <Shape> _Nonnull)shape;
/// 현재 Poi와 지정된 shape간에 더이상 transform을 공유하지 않게한다.
/// \param shape transform공유를 하지 않을 shape
///
- (void)removeShareTransformWithShape:(id <Shape> _Nonnull)shape;
/// Poi가 속한 LayerID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// Poi의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull itemID;
/// Poi의 렌더링 우선순위
/// rank값을 새로 assign하면, Poi의 rank가 업데이트 된다.
@property (nonatomic) NSInteger rank;
/// Poi의 clickable 여부. 생성 옵션에서 따로 지정하지 않는 경우, default는 false로 설정된다.
/// 새로운 값을 assign하여 clickable 여부를 바꿀 수 있다.
@property (nonatomic) BOOL clickable;
/// Poi의 위치
/// 새로운 position값으로 assign하면, Poi의 position값이 변경된다.
@property (nonatomic, strong) MapPoint * _Nonnull position;
/// Poi의 Orientation(radian)
/// 새로운 orientation값으로 assign하면, Poi의 Orientation값이 변경된다.
@property (nonatomic) double orientation;
/// Poi가 현재 뷰에 보여지고 있는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// Poi가 그려진 위치로부터 pixelOffset을 적용한다.
/// left/top 방향은 -, right/bottom 방향은 +로 offset을 지정할 수 있다.
@property (nonatomic) CGPoint pixelOffset;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Poi에 위에서 아래로 떨어지는 Drop Animation 효과를 주는 클래스.
/// Animator를 생성해서 Animator에 효과를 주고자 하는 poi를 넣고, animator를 동작시키는 방식이다.
/// Animator는 사용자가 직접 생성할 수 없으며, LabelManager를 통해서만 생성한 객체를 받아서 사용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK11PoiAnimator")
@interface PoiAnimator : NSObject <Animator>
/// Animator를 동작시킨다.
/// Animator에 추가된 Poi가 하나도 없을 경우, 동작하지 않는다. start를 호출한 이후에는 Animator에 Poi를 추가하거나 지울 수 없다. 추가하고자 하는 경우, stop을 호출하고 추가해야한다.
/// start 호출 이후 애니메이션이 끝나면 Animator에 추가된 Poi는 비워지므로, 다시 start를 호출하려면 Poi를 추가해야한다.
/// Poi Interface에 있는 애니메이션은 animator가 start되면 모두 멈춘다.
- (void)start;
/// Animator 동작을 멈춘다.
/// stop이 호출되면 애니메이션이 끝난것으로 간주되어 Animator에 속한 Poi는 모두 비워지므로, Animator를 다시 동작시키려면 다시 Poi를 Animator에 추가해야한다.
- (void)stop;
/// Animator 의 종료 콜백을 지정한다. Start 된 애니메이션이 종료되거나 stop이 호출되면 지정한 callback 이 호출된다. nil 로 지정해서 기존에 지정했던 callback을 제거할 수 있다. 기본값 nil.
/// \param callback Animator에 추가할 종료 콜백.
///
- (void)setStopCallback:(void (^ _Nullable)(id <Animator> _Nullable))callback;
/// Animator에 Poi를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 Poi를 추가한다. start() 를 호출한 이후에는 애니메이션이 끝나기 전까지 poi를 추가할 수 없다.
/// \param poi Animator에 추가할 poi
///
- (void)addPoi:(Poi * _Nonnull)poi;
/// Animator에 여러개의 Poi를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 Poi를 추가한다. start() 를 호출한 이후에는 애니메이션이 끝나기 전까지 poi를 추가할 수 없다.
/// \param pois Animator에 추가할 poi 배열
///
- (void)addPois:(NSArray<Poi *> * _Nonnull)pois;
/// Animator에 추가한 poi를 모두 지운다.
/// start() 호출 이후에는 동작하지 않는다.
- (void)clearAllPois;
/// 추가한 animatorID
@property (nonatomic, readonly, copy) NSString * _Nonnull animatorID;
/// Animator 시작 여부
@property (nonatomic, readonly) BOOL isStart;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PoiBadge 클래스
/// Poi에 Poi icon 심볼이미지외에 추가 이미지를 표시하고자 할 경우 사용할 수 있다.
/// Poi에 개별로 지정하거나 PoiIconStyle에 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8PoiBadge")
@interface PoiBadge : NSObject
/// initializer
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     badgeID: 추가할 badge의 ID
///   </li>
///   <li>
///     image: badge의 image
///   </li>
///   <li>
///     offset: Badge가 위치할 offset
///   </li>
///   <li>
///     zOrder: Badge의 zOrder. 뱃지의 배치 순서를 결정한다. 값이 클수록 더 위에 그려진다.
///   </li>
/// </ul>
- (nonnull instancetype)initWithBadgeID:(NSString * _Nonnull)badgeID image:(UIImage * _Nullable)image offset:(CGPoint)offset zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// badge의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull badgeID;
/// 추가한 badge의 offset
@property (nonatomic, readonly) CGPoint offset;
/// badge의 Image
@property (nonatomic, readonly, strong) UIImage * _Nullable image;
/// badge의 zOrder. 해당 값으로 badge의 배치 순서를 바꿀 수 있다.
/// 값이 큰 Badge가 더 위에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PoiIconStyle Class.
/// Poi의 Icon Style을 정의한다.
/// Poi의 심 볼이미지, AnchorPoint등을 정의한다.
/// Poi가 나타나거나 사라질 때, Icon의 애니메이션 효과인 transition type을 정의할 수 있다.
/// 또한 Icon에 종속되는 Badge를 Style로 정의할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12PoiIconStyle")
@interface PoiIconStyle : NSObject
/// Initializer
/// \param symbol Poi의 심볼이미지
///
/// \param anchorPoint Symbol Image의 AnchorPoint. default값은 (0.5, 0.5)
///
/// \param transition Poi가 show/hide 할 때 애니메이션 효과 타입
///
/// \param enableEntranceTransition 레벨변경시 스타일이 변할 때, 지정한 transition효과 적용여부. show()/hide()는 해당 값과 관계없이 transition 효과가 적용된다.
///
/// \param enableExitTransition 레벨변경시 스타일이 변할 때, 지정한 transition 효과 적용 여부. show()/hide()는 해당 값과 관계없이 transition 효과가 적용된다.
///
/// \param badges IconStyle에 종속되는 Badge. 여러개의 Poi에 badge가 포함된 똑같은 스타일을 사용하면 일괄적으로 뱃지가 표시된다.
///
- (nonnull instancetype)initWithSymbol:(UIImage * _Nullable)symbol anchorPoint:(CGPoint)anchorPoint transition:(struct PoiTransition)transition enableEntranceTransition:(BOOL)enableEntranceTransition enableExitTransition:(BOOL)enableExitTransition badges:(NSArray<PoiBadge *> * _Nullable)badges OBJC_DESIGNATED_INITIALIZER;
/// Poi의 심볼이미지
@property (nonatomic, readonly, strong) UIImage * _Nullable symbol;
/// AnchorPoint
@property (nonatomic, readonly) CGPoint anchorPoint;
/// Poi가 show/hide하거나, 레벨변경에 의해 스타일이 변할 때 심볼에 적용되는 애니메이션 효과 정의
@property (nonatomic, readonly) struct PoiTransition transition;
/// 레벨변경에 의해 스타일이 변할 때, transition 효과 적용 여부. false로 설정할 경우 설정한 transition이 적용되지 않는다.
/// 해당 값과 관계없이 Poi가 show()로 화면에 표시될 때는 기존에 설정한 transition대로 동작한다.
/// 기본값은 true.
@property (nonatomic, readonly) BOOL enableEntranceTransiion;
/// 레벨변경에 의해 스타일이 변할 때, transition 효과 적용 여부. false로 설정할 경우 설정한 transition이 적용되지 않는다.
/// 해당 값과 관계없이 Poi가 hide()로 화면에서 사라질 때는 기존에 설정한 transition대로 동작한다.
/// 기본값은 true.
@property (nonatomic, readonly) BOOL enableExitTransition;
/// Poi IconStyle에 종속되는 뱃지
/// 여러개의 Poi에 badge가 포함된 똑같은 스타일을 사용하면 일괄적으로 뱃지가 표시된다.
@property (nonatomic, readonly, copy) NSArray<PoiBadge *> * _Nullable badges;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Poi 생성 옵션 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK10PoiOptions")
@interface PoiOptions : NSObject
/// initializer
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     styleID: 사용할 PoiStyle ID
///   </li>
/// </ul>
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     styleID: 사용할 PoiStyle ID
///   </li>
///   <li>
///     poiID: poi 고유 ID
///   </li>
/// </ul>
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID poiID:(NSString * _Nonnull)poiID;
/// PoiID. 지정하지 않을 경우 자동으로 부여된다.
@property (nonatomic, readonly, copy) NSString * _Nullable itemID;
/// Poi의 styleID
@property (nonatomic, copy) NSString * _Nonnull styleID;
/// Poi의 렌더링 우선순위
@property (nonatomic) NSInteger rank;
/// Poi의 클릭가능 여부
@property (nonatomic) BOOL clickable;
/// Poi의 transformType. 총 4가지 타입이 존재한다.
/// seealso:
/// PoiTransformType
@property (nonatomic) PoiTransformType transformType;
/// Poi에 추가할 텍스트를 지정한다.
/// seealso:
/// PoiText
/// \param text Poi에 표시될 text
///
- (void)addText:(PoiText * _Nonnull)text;
/// Poi에 추가할 텍스트 목록
///
/// returns:
/// Poi에 표시될 text
- (NSArray<PoiText *> * _Nonnull)texts SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PoiStyle을 지정하는 클래스.
/// 1개 이상의 PerLevelPoiStyle로 구성된다.
/// LabelManager를 통해 Style을 등록한다. 등록된 style의 ID를 Poi에 지정해주면, Poi가 해당 스타일로 생성된다.
/// 혹은 등록된 styleID로 Poi의 스타일을 변경할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8PoiStyle")
@interface PoiStyle : NSObject
/// initializer
/// <ul>
///   <li>
///     parameters
///     <ul>
///       <li>
///         styleID: PoiStyle의 ID
///       </li>
///       <li>
///         styles: PoiStyle을 구성할 단위레벨별 PerLevelPoiStyle 배열
///       </li>
///     </ul>
///   </li>
/// </ul>
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID styles:(NSArray<PerLevelPoiStyle *> * _Nonnull)styles OBJC_DESIGNATED_INITIALIZER;
/// 추가된 PerLevelPoiStyle 배열
@property (nonatomic, readonly, copy) NSArray<PerLevelPoiStyle *> * _Nonnull styles;
/// PoiStyleID.
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Poi에 표시할 PoiText Class
/// Poi에 표시될 하나의 라인을 정의한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK7PoiText")
@interface PoiText : NSObject
/// initializer
/// \param text Poi에 표시할 text
///
/// \param styleIndex 적용한 PoiTextStyle내에서 TextLine의 인덱스. 인덱스가 생성해둔 PoiTextStyle의 크기를 넘어갈 경우, 가장 마지막에 추가한 styleIndex로 표시된다.
///
- (nonnull instancetype)initWithText:(NSString * _Nonnull)text styleIndex:(NSUInteger)styleIndex OBJC_DESIGNATED_INITIALIZER;
/// Poi에 표시될 Text
@property (nonatomic, readonly, copy) NSString * _Nonnull text;
/// 적용한 PoiTextStyle내에서 TextLine의 인덱스
@property (nonatomic, readonly) NSUInteger styleIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PoiTextLineStyle 클래스
/// PoiText 하나마다 PoiTextLineStyle을 지정할 수 있다.
/// 예를 들어, Poi에 PoiText를 2개 이상 넣고자 하는 경우, 각 PoiText마다 PoiTextStyle에 생성한 PoiTextLineStyle의 인덱스를 지정하여 특정 텍스트 스타일로 표시할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK16PoiTextLineStyle")
@interface PoiTextLineStyle : NSObject
/// initializer
/// default TextStyle과 center Layout 으로 지정된다.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// TextStyle
@property (nonatomic, strong) TextStyle * _Nonnull textStyle;
@end


/// PoiTextStyle class.
/// Poi에 Text를 넣을 경우, 이 Text의 Style을 정의하는 클래스.
/// 한개 이상의 PoiTextLineStyle로 구성된다. 하나의 Poi에 여러라인의 텍스트를 넣고 각 텍스트 라인마다 스타일을 다르게 주고자 하는 경우 두개 이상의 PoiTextLineStyle을 생성하여 PoiTextStyle을 구성할 수 있다.
/// Poi가 나타나거나 사라질 때, transition Type을 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12PoiTextStyle")
@interface PoiTextStyle : NSObject
/// Initailizer
/// \param transition Poi가 show/hide 할 때 애니메이션 효과
///
/// \param enableEntranceTransition 레벨변경시 스타일이 변할 때, 지정한 transition효과 적용여부. show()/hide()는 해당 값과 관계없이 transition 효과가 적용된다.
///
/// \param enableExitTransition 레벨변경시 스타일이 변할 때, 지정한 transition 효과 적용 여부. show()/hide()는 해당 값과 관계없이 transition 효과가 적용된다.
///
/// \param textLineStyles Poi의 Text Line별 스타일
///
- (nonnull instancetype)initWithTransition:(struct PoiTransition)transition enableEntranceTransition:(BOOL)enableEntranceTransition enableExitTransition:(BOOL)enableExitTransition textLineStyles:(NSArray<PoiTextLineStyle *> * _Nonnull)textLineStyles OBJC_DESIGNATED_INITIALIZER;
/// Poi가 show/hide하거나, 레벨변경에 의해 스타일이 변할 때 텍스트에 적용되는 애니메이션 효과 정의
/// seealso:
/// PoiTransition
@property (nonatomic, readonly) struct PoiTransition transition;
/// 레벨변경에 의해 스타일이 변할 때, transition 효과 적용 여부. false로 설정할 경우 설정한 transition이 적용되지 않는다.
/// 해당 값과 관계없이 Poi가 show()로 화면에 표시될 때는 기존에 설정한 transition대로 동작한다.
/// 기본값은 true.
@property (nonatomic, readonly) BOOL enableEntranceTransiion;
/// 레벨변경에 의해 스타일이 변할 때, transition 효과 적용 여부. false로 설정할 경우 설정한 transition이 적용되지 않는다.
/// 해당 값과 관계없이 Poi가 hide()로 화면에서 사라질 때는 기존에 설정한 transition대로 동작한다.
/// 기본값은 true.
@property (nonatomic, readonly) BOOL enableExitTransition;
/// Poi의 라인별 텍스트 스타일.
/// Poi에 멀티 라인의 텍스트를 넣을 경우, TextLine마다 TextLineStyle을 인덱스로 지정할 수 있다.
/// Poi에 두개 이상의 PoiText를 넣고, 각 PoiText에 생성한 PoiTextLineStyle의의 index를 지정한다.
@property (nonatomic, readonly, copy) NSArray<PoiTextLineStyle *> * _Nonnull textLineStyles;
/// text layouts(for obj-c)
- (NSArray<NSNumber *> * _Nonnull)textLayouts SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolygonShape를 구성할 때 사용하는 Polygon 클래스.
/// 폴리곤은 단독으로 Map에 추가할 수 없으며, Shape에 종속되는 객체이다.
/// 하나의 외곽선과 hole을 넣어서 구성할 수 있다. 외곽선 point인 exterior ring과 폴리곤 내부 홀을 표시하는 holes로 구성된다.
/// exteriorRing, 즉 외곽선은 시계방향으로 CGPoint를 넣어야 하고, hole은 시계반대방향으로 CGPoint를 넣어야한다.
/// Polygon의 Point는 basePosition을 기준으로 한 실수 타입의  CGPoint 정점으로 구성한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK7Polygon")
@interface Polygon : NSObject
/// initializer
/// \param exteriorRing Polygon의 외곽선
///
/// \param holes Polygon의 hole 배열. hole이 없을경우 nil로 지정
///
/// \param styleIndex PolygonStyleSet에서 사용할 PolygonStyle 인덱스
///
- (nonnull instancetype)initWithExteriorRing:(NSArray<NSValue *> * _Nonnull)exteriorRing holes:(NSArray<NSArray<NSValue *> *> * _Nullable)holes styleIndex:(NSUInteger)styleIndex OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param exteriorRing Polygon의 외곽선
///
/// \param hole Polygon의 하나의 hole. hole이 없을경우 nil로 지정
///
/// \param styleIndex PolygonStyleSet에서 사용할 PolygonStyle 인덱스
///
- (nonnull instancetype)initWithExteriorRing:(NSArray<NSValue *> * _Nonnull)exteriorRing hole:(NSArray<NSValue *> * _Nullable)hole styleIndex:(NSUInteger)styleIndex;
/// Polygon의 외곽선.
/// 시계방향의 CGPoint 배열로 구성한다.
@property (nonatomic, readonly, copy) NSArray<NSValue *> * _Nonnull exteriorRing;
/// Polygon의 holes
/// 0개 이상으로 구성되며, 반시계방향의 CGPoint 배열로 구성한다.
@property (nonatomic, readonly, copy) NSArray<NSArray<NSValue *> *> * _Nullable holes;
/// PolygonStyleSet에서 사용할 표출 스타일 인덱스를 지정한다.
@property (nonatomic, readonly) NSUInteger styleIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 지도상에 특정 영역을 2d Polygon으로 표시하는 PolygonShape 클래스.
/// basePosition을 기준으로 정점을 구성한다.
/// PolygonShape를 추가하기 위해서는 먼저 KakaoMap에 ShapeLayer를 추가한 뒤, 해당 Layer에 PolygonShape를 추가할 수 있다.
/// show, hide, style변경 및 이동/회전이 가능하다.
/// PolygonShape는 사용자가 직접 생성할 수 없으며, PolygonShapeOptions class를 이용하여 Layer에 추가하면 해당 object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12PolygonShape")
@interface PolygonShape : NSObject <Shape>
/// PolygonShape를 보여준다.
- (void)show;
/// PolygonShape를 숨긴다.
- (void)hide;
/// PolygonShape의 style과 Data를 변경한다.
/// PolygonShape의 Style과 PolygonShape가 표시하는 polgyon Data를 변경하고자 할 때 사용한다.
/// 단, polygon Data를 바꿀때는 해당 PolygonShape 객체가 가리키는 본질이 변하지 않을때만 사용한다.
/// 즉 전혀 다른 PolygonShape 객체일때는 PolygonShape를 하나 더 만드는것을 권장한다.
/// \param styleID 변경할 styleID
///
/// \param polygons 업데이트 할 폴리곤 데이터.
///
- (void)changeStyleAndDataWithStyleID:(NSString * _Nonnull)styleID polygons:(NSArray<Polygon *> * _Nonnull)polygons;
/// shape가 속한 layerID
@property (nonatomic, readonly, copy) NSString * _Nullable layerID;
/// ShapeID.
@property (nonatomic, readonly, copy) NSString * _Nonnull shapeID;
/// Shape의 base Position
@property (nonatomic, readonly, strong) MapPoint * _Nonnull basePosition;
/// PolygonShape의 position
/// 새로운 position값으로 assign 할 경우, PolygonShape의 position값이 update된다.
@property (nonatomic, strong) MapPoint * _Nonnull position;
/// PolygonShape의 현재 orientation값
/// 새로운 orientation값으로 assign할 경우, PolygonShape의 orientation이 변경된다.
@property (nonatomic) double orientation;
/// PolygonShape가 현재 지도에 표시되는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolygonShape생성 옵션 클래스.
/// PolygonShape는 지도상의 특정 2d polygon을 표시할 때 사용한다. basePosition을 기준점으로 오프셋 좌표인 CGPoint 로 이루어진 하나 이상의 폴리곤으로 구성된다.
/// CGPoint로 이루어진 폴리곤을 받아 위경도 좌표계에 폴리곤을 표시한다.
/// PolygonShape에 속한 Polygon마다 StyleSet을 이용하여 다르게 표출할 수도 있다.
/// PolylineShape의 id를 별도로 지정하지 않는 경우, 내부적으로 자동으로 부여한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK19PolygonShapeOptions")
@interface PolygonShapeOptions : NSObject
/// initializer
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 값이 클수록 더 위에 그려진다.
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param shapeID Shape의 ID
///
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 값이 클수록 더 위에 그려진다.
///
- (nonnull instancetype)initWithShapeID:(NSString * _Nonnull)shapeID styleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// Shape의 ID
@property (nonatomic, readonly, copy) NSString * _Nullable shapeID;
/// Shape가 표출될 StyleID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
/// Shape의 렌더링 우선순위.
/// 높을수록 더 위에 그려지며, Shape type끼리만 유효하다.
/// 즉, zOrder = 0 인 Shape는 zOrder = 1 인 shape보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
/// shape의 base position.
@property (nonatomic, strong) MapPoint * _Nonnull basePosition;
/// Shape에 속한 폴리곤.
/// 1개 이상의 폴리곤으로 구성된다.
/// seealso:
/// Polygon
@property (nonatomic, copy) NSArray<Polygon *> * _Nonnull polygons;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolygonStyle 클래스.
/// PolygonShape의 스타일을 지정하기 위해 사용한다. 한 개 이상의 PerLevelPolygonStyle로 구성된다.
/// PerLevelPolygonStyle Unit 클래스를 추가하여 레벨별로 표출할 스타일을 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12PolygonStyle")
@interface PolygonStyle : NSObject
/// initializer
/// \param styles PolygonStyle을 구성할 단위레벨별 PerLevelPolygonStyle 배열
///
- (nonnull instancetype)initWithStyles:(NSArray<PerLevelPolygonStyle *> * _Nonnull)styles OBJC_DESIGNATED_INITIALIZER;
/// 추가한 ShapeStyle 배열
@property (nonatomic, readonly, copy) NSArray<PerLevelPolygonStyle *> * _Nonnull styles;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolygonStyleSet 클래스
/// Shape내부에 여러개의 폴리곤이 있을 때, PolygonStyle은 하나의 스타일을 적용하게 되면 여러개의 폴리곤에 일괄적으로 똑같은 스타일이 적용된다.
/// 반면 PolygonStyleSet은 PolygonShape 내부에 여러개의 폴리곤이 있을때, 각 폴리곤마다 다른 스타일을 적용할 수 있다.
/// 즉, 하나의 스타일을 추가하더라도 폴리곤마다 다르게 표출될 수 있게 정의할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK15PolygonStyleSet")
@interface PolygonStyleSet : NSObject
/// initializer
/// \param styleSetID StyleSet ID
///
- (nonnull instancetype)initWithStyleSetID:(NSString * _Nonnull)styleSetID OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// <ul>
///   <li>
///     parameters
///     <ul>
///       <li>
///         styleSetID: StyleSet ID
///       </li>
///       <li>
///         styles: PolygonStyleSet을 구성할 PolygonStyle 배열
///       </li>
///     </ul>
///   </li>
/// </ul>
- (nonnull instancetype)initWithStyleSetID:(NSString * _Nonnull)styleSetID styles:(NSArray<PolygonStyle *> * _Nonnull)styles;
/// styleSet에 추가 될 LevelStyle을 추가한다.
/// \param style 추가할 ShapeLevelStyle
///
- (void)addStyle:(PolygonStyle * _Nonnull)style;
/// styleSet ID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleSetID;
/// 추가할 ShapeStyles
@property (nonatomic, readonly, copy) NSArray<PolygonStyle *> * _Nonnull styles;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolylineShape를 구성할 때 사용하는 Polyline 클래스
/// 폴리라인은 단독으로 Map에 추가할 수 없으며, Shape에 종속되는 객체이다.
/// basePosition을 기준점으로 하는 2개 이상의 CGPoint로 만들어진 라인으로 구성된다. 폴리라인의 캡 스타일도 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8Polyline")
@interface Polyline : NSObject
/// Initializer
/// \param line Polyline을 구성하는 CGPoint 배열
///
/// \param styleIndex Polyline에 적용할 PolylineStyleSet에 속한 PolylineStyle의 index
///
- (nonnull instancetype)initWithLine:(NSArray<NSValue *> * _Nonnull)line styleIndex:(NSUInteger)styleIndex OBJC_DESIGNATED_INITIALIZER;
/// 2개 이상의 CGPoint로 구성된다.
@property (nonatomic, readonly, copy) NSArray<NSValue *> * _Nonnull line;
/// ShapeStyleSet에서 사용할 표출 인덱스를 지정한다.
@property (nonatomic, readonly) NSUInteger styleIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 지도상에 특정 선형을 2d Polyline으로 표시하는  PolylineShape 클래스.
/// basePosition을 기준으로 정점을 구성한다
/// PolylineShape를 추가하기 위해서는 먼저 KakaoMap에 ShapeLayer를 추가한 뒤, 해당 Layer에 PolylineShape를 추가할 수 있다.
/// show, hide, style변경 및 이동/회전이 가능하다.
/// PolylineShape는 사용자가 직접 생성할 수 없으며, PolylineShapeOptions class를 이용하여 Layer에 추가하면 해당 Object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK13PolylineShape")
@interface PolylineShape : NSObject <Shape>
/// PolylineShape를 보여준다.
- (void)show;
/// PolylineShape를 숨긴다.
- (void)hide;
/// PolylineShape의 style과 Data를 변경한다.
/// PolylineShape의 style과 표시하는 polyline Data를 변경하고자 할 때 사용한다. 단, polyline Data를 바꿀때는 해당 PolylineShape 객체가 가리키는 본질이 변하지 않을때만 사용한다. 즉 전혀 다른 PolylineShape 객체일때는 PolylineShape를 하나 더 만드는것을 권장한다.
/// \param styleID 변경할 styleID
///
/// \param lines 업데이트 할 폴리라인 데이터.
///
- (void)changeStyleAndDataWithStyleID:(NSString * _Nonnull)styleID lines:(NSArray<Polyline *> * _Nonnull)lines;
/// Shape가 속한 layerID
@property (nonatomic, readonly, copy) NSString * _Nullable layerID;
/// Shape의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull shapeID;
/// Shape의 base Position
@property (nonatomic, readonly, strong) MapPoint * _Nonnull basePosition;
/// PolylineShape의 position
/// 새로운 값을 assign 하면, 해당 PolylineShape의 position이 업데이트된다.
@property (nonatomic, strong) MapPoint * _Nonnull position;
/// PolylineShape의 Orientation (radian)
/// 새로운 orientation값을 assign하면, PolylineShape의 orientation 값이 업데이트된다.
@property (nonatomic) double orientation;
/// PolylineShape가 현재 지도에 표시되는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolylineShape생성 옵션 클래스
/// PolylineShape는 지도상의 특정 2d polyline을 표시할 때 사용한다. basePosition을 기준점으로 오프셋 좌표인 CGPoint로 이루어진 하나 이상의 폴리라인으로 구성된다.
/// CGPoint로 이루어진 폴리라인을 받아 위경도 좌표계에 폴리라인을 표시한다.
/// Style은 PolylineShape에 속한 Polyline마다 StyleSet을 이용하여 다르게 표출할수도 있다.
/// PolylineShape의 id를 별도로 지정하지 않는 경우, 내부적으로 자동으로 부여한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK20PolylineShapeOptions")
@interface PolylineShapeOptions : NSObject
/// initializer
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 높을수록 더 위에 그려진다.
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param shapeID Shape의 ID
///
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 높을수록 더 위에 그려진다.
///
- (nonnull instancetype)initWithShapeID:(NSString * _Nonnull)shapeID styleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// Shape의 ID
@property (nonatomic, readonly, copy) NSString * _Nullable shapeID;
/// Shape가 표출될 StyleID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
/// Shape의 렌더링 우선순위.
/// 높을수록 더 위에 그려지며, Shape type끼리만 유효하다.
/// 즉, zOrder = 0 인 Shape는 zOrder = 1 인 shape보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
/// shape의 base position
@property (nonatomic, strong) MapPoint * _Nonnull basePosition;
/// Shape에 속한 Polyline 배열
/// 1개 이상의 폴리라인으로 구성된다.
/// seealso:
/// Polyline
@property (nonatomic, copy) NSArray<Polyline *> * _Nonnull polylines;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolylineStyle 클래스.
/// PolylineShape를 레벨별로 다른 스타일로 표출하고자 할 때 사용한다.
/// PerLevelPolylineStyle Unit 클래스를 추가하여 레벨별로 표출할 스타일을 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK13PolylineStyle")
@interface PolylineStyle : NSObject
/// initializer
/// \param styles PolylineStyle을 구성할 단위레벨별 PerLevelPolylineStyle 배열
///
- (nonnull instancetype)initWithStyles:(NSArray<PerLevelPolylineStyle *> * _Nonnull)styles OBJC_DESIGNATED_INITIALIZER;
/// 추가한 PerLevelPolylineStyle 배열
@property (nonatomic, readonly, copy) NSArray<PerLevelPolylineStyle *> * _Nonnull styles;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolylineStyleSet 클래스
/// Shape 내부에 여러개의 Polyline이 존재할 경우, PolylineStyle은 Shape 내부 여러개의 폴리라인에 똑같은 스타일로 일괄적으로 적용된다.
/// 반면 PolylineStyleSet은 PolylineShape 내부에 여러개의 폴리라인이 있을 때, 각 폴리라인마다 다른 스타일을 적용할 수 있다.
/// 즉, 하나의 스타일을 추가하더라도 폴리곤마다 다르게 표출할 수 있도록 정의할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK16PolylineStyleSet")
@interface PolylineStyleSet : NSObject
/// Initializer
/// \param styleSetID styleSet ID
///
- (nonnull instancetype)initWithStyleSetID:(NSString * _Nonnull)styleSetID OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param styleSetID styleSet ID
///
/// \param styles PolylineStyleSet을 구성할 PolylineStyle 배열
///
/// \param capType Polyline에 시작/끝지점에 표시될 capType 지정. 스타일셋에 등록된 모든 PolylineStyle은 일괄적으로 이 capType이 적용된다.
///
- (nonnull instancetype)initWithStyleSetID:(NSString * _Nonnull)styleSetID styles:(NSArray<PolylineStyle *> * _Nonnull)styles capType:(PolylineCapType)capType;
/// styleSet에 추가될 LevelStyle을 추가한다.
/// \param style 추가할 style
///
- (void)addStyle:(PolylineStyle * _Nonnull)style;
/// styleSet ID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleSetID;
/// 추가할 shapeStyles
@property (nonatomic, readonly, copy) NSArray<PolylineStyle *> * _Nonnull styles;
/// 해당 스타일을 적용한 Polyline의 시작/끝지점에 표시될 capType
/// seealso:
/// PolylineCapType
@property (nonatomic, readonly) PolylineCapType capType;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Primitive 정점을 구성하는 유틸리티 클래스
/// Circle, Rectangle을 구성할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10Primitives")
@interface Primitives : NSObject
/// wgs84 좌표계 상의 두 점 사이의 거리를 구한다.
/// \param p1 첫번째 점
///
/// \param p2 두번째 점
///
///
/// returns:
/// 두 점 사이의 거리(meter)
+ (double)distanceWithP1:(MapPoint * _Nonnull)p1 p2:(MapPoint * _Nonnull)p2 SWIFT_WARN_UNUSED_RESULT;
/// CirclePoint를 가져온다.
/// \param radius Circle의 반지름(meter)
///
/// \param numPoints circle을 구성할 포인트 개수.
///
/// \param cw 시계방향으로 구성할지에 대한 여부. false인경우 시계반대방향으로 리턴된다.
///
///
/// returns:
/// Circle형태의 CGPoint 배열
+ (NSArray<NSValue *> * _Nonnull)getCirclePointsWithRadius:(double)radius numPoints:(NSInteger)numPoints cw:(BOOL)cw SWIFT_WARN_UNUSED_RESULT;
/// CirclePoint를 가져온다.
/// \param radius Circle의 반지름(meter)
///
/// \param numPoints circle을 구성할 포인트 개수.
///
/// \param cw 시계방향으로 구성할지에 대한 여부. false인경우 시계반대방향으로 리턴된다.
///
/// \param center CirclePoint를  지도 좌표계로 생성하기 위해 중심점을 지정
///
///
/// returns:
/// Circle형태의 MapPoint배열
+ (NSArray<MapPoint *> * _Nonnull)getCirclePointsWithRadius:(double)radius numPoints:(NSInteger)numPoints cw:(BOOL)cw center:(MapPoint * _Nonnull)center SWIFT_WARN_UNUSED_RESULT;
/// RectanglePoint를 가져온다.
/// \param width Rectangle의 너비(meter)
///
/// \param height Rectnagle의 높이(meter)
///
/// \param cw 시계방향으로 구성할지에 대한 여부. false인경우 시계반대방향으로 리턴된다.
///
///
/// returns:
/// Rectangle형태의 CGPoint 배열
+ (NSArray<NSValue *> * _Nonnull)getRectanglePointsWithWidth:(double)width height:(double)height cw:(BOOL)cw SWIFT_WARN_UNUSED_RESULT;
/// RectanglePoint를 가져온다.
/// \param width Rectangle의 너비(meter)
///
/// \param height Rectnagle의 높이(meter)
///
/// \param cw 시계방향으로 구성할지에 대한 여부. false인경우 시계반대방향으로 리턴된다.
///
/// \param center Rectangle Point를  지도 좌표계로 생성하기 위해 중심점을 지정
///
///
/// returns:
/// Circle형태의 MapPoint 배열
+ (NSArray<MapPoint *> * _Nonnull)getRectanglePointsWithWidth:(double)width height:(double)height cw:(BOOL)cw center:(MapPoint * _Nonnull)center SWIFT_WARN_UNUSED_RESULT;
/// startPoint ~ endPoint까지 Curve Point를 생성한다.
/// \param startPoint 시작 point
///
/// \param endPoint 끝 point
///
/// \param isLeft 시작-끝을 기준으로 왼쪽으로 휘어지는 커브인지에 대한 여부. false인경우 오른쪽으로 휘어지는 커브 point를 생성한다.
///
///
/// returns:
/// 생성한 곡선 MapPoint 배열
+ (NSArray<MapPoint *> * _Nonnull)getCurvePointsWithStartPoint:(MapPoint * _Nonnull)startPoint endPoint:(MapPoint * _Nonnull)endPoint isLeft:(BOOL)isLeft SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class RoadviewLookAt;
@protocol RoadviewEventDelegate;

/// 로드뷰를 그리기 위한 클래스.
/// 로드뷰는 바로 그려지지 않고, 로드뷰지점 데이터를 요청하여 데이터가 수신되면 그려진다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8Roadview")
@interface Roadview : ViewBase
/// 로드뷰를 요청한다.
/// 요청 결과에 따라 이벤트가 발생된다.
/// \param position 로드뷰를 요청할 지점 위치.
///
/// \param panoID 파노라마 ID.
///
/// \param markers 로드뷰에 표시할 마커들. 없을 경우 nil.
///
/// \param lookAt 초기 로드뷰 진입시 바라볼 방향. 지정하지 않을 경우 nil. 지정하지 않을 경우 정북 수평방향을 바라본다.
///
- (void)requestRoadviewWithPosition:(MapPoint * _Nonnull)position panoID:(NSString * _Nullable)panoID markers:(NSArray<PanoramaMarker *> * _Nullable)markers lookAt:(RoadviewLookAt * _Nullable)lookAt;
/// 로드뷰 뷰와 연결된 지도 뷰를 지정한다.
/// 지도 뷰와 연결하면 지도 뷰가 회전하면 로드뷰 뷰도 회전하고, 로드뷰 지점 이동에 따라 지도 뷰도 이동한다.
/// \param viewName 연결할 지도 뷰의 이름. 해당 이름의 지도뷰가 없을 경우 아무 동작 없음.
///
- (void)linkMapView:(NSString * _Nonnull)viewName;
/// 로드뷰 뷰와 연결된 지도 뷰를 해제한다.
- (void)unlinkMapView;
/// 뷰를 다시 그린다.
- (void)refresh;
/// 로고의 위치를 지정한다.
/// 로고는 SpriteGUI 와 같은 방식으로 화면상의 특정위치에 고정적으로 표시되므로, 다른 GUI 와 겹치는 현상을 피하기 위해 로고의 위치를 이동시키는 데 사용한다.
/// 위치 지정방식은 SpriteGUI와 동일하다.
/// \param origin 로고의 alignment
///
/// \param position alignment 기준점으로부터의 offset
///
- (void)setLogoPositionWithOrigin:(struct GuiAlignment)origin position:(CGPoint)position;
/// 로드뷰 카메라의 pan값
@property (nonatomic, readonly) double pan;
/// 로드뷰 카메라의 tilt값
@property (nonatomic, readonly) double tilt;
/// 뷰의 활성화 상태
/// <code>true</code>인 경우 렌더링이 실행되며,<code>false</code>인 경우 렌더링을 하지 않는다.
@property (nonatomic) BOOL isEnabled;
/// 로드뷰 이벤트 delegate를 지정한다.
@property (nonatomic, strong) id <RoadviewEventDelegate> _Nullable eventDelegate;
@end



/// Roadview의 이벤트 delegate.
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK21RoadviewEventDelegate_")
@protocol RoadviewEventDelegate
@optional
/// 로드뷰의 크기가 변경되었을 때 발생.
/// \param roadview Roadview
///
- (void)roadviewDidResized:(Roadview * _Nonnull)roadview;
/// 파노라마가 갱신되었을 때 발생.
/// \param panoId 갱신된 파노라마 ID
///
- (void)panoramaUpdated:(NSString * _Nonnull)panoId;
/// 포커스 변경시 발생.
/// \param roadview Roadview
///
/// \param focus 포커스 상태
///
- (void)roadviewFocusDidChangedWithRoadview:(Roadview * _Nonnull)roadview focus:(BOOL)focus;
@required
/// 로드뷰 요청 결과 수신시 발생.
/// \param roadview Roadview
///
/// \param panoID 파노라마 ID
///
/// \param position 파노라마 지점 위치
///
- (void)roadviewResultDidReceivedWithRoadview:(Roadview * _Nonnull)roadview panoID:(NSString * _Nonnull)panoID position:(MapPoint * _Nonnull)position;
@optional
/// 로드뷰 요청 결과 결과없음 수신시 발생.
/// \param roadview Roadview
///
- (void)noRoadviewResult:(Roadview * _Nonnull)roadview;
/// 로드뷰 요청 실패시 발생.
/// \param roadview Roadview
///
- (void)roadviewRequestDidFailed:(Roadview * _Nonnull)roadview;
/// 잘못된 요청 (ex. index범위 밖의 과거사진 요청).
/// \param roadview Roadview
///
- (void)invalidRoadviewRequest:(Roadview * _Nonnull)roadview;
/// 로드뷰의 영역이 클릭되었을 때 호출.
/// \param roadview Roadview
///
/// \param point 클릭된 위치
///
- (void)roadviewDidTappedWithRoadview:(Roadview * _Nonnull)roadview point:(CGPoint)point;
@end


/// 로드뷰 viewInfo. Roadview로 view가 생성된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12RoadviewInfo")
@interface RoadviewInfo : ViewInfo
@end


@interface RoadviewInfo (SWIFT_EXTENSION(KakaoMapsSDK))
- (nonnull instancetype)initWithViewName:(NSString * _Nonnull)viewName viewInfoName:(NSString * _Nonnull)viewInfoName enabled:(BOOL)enabled;
@end


/// 로드뷰가 화면에 표시될 때 카메라가 바라보는 방향을 지정하기 위한 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK14RoadviewLookAt")
@interface RoadviewLookAt : NSObject
/// Initializer
/// \param pan 카메라 회전각(radian, 정북기준 시계방향).
///
/// \param tilt 카메라 기울임각(radian, 지평선과 평행 기준, 양수값이 지면방향)
///
- (nonnull instancetype)initWithPan:(double)pan tilt:(double)tilt OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param position 카메라가 바라볼 위치
///
- (nonnull instancetype)initWithPosition:(MapPoint * _Nonnull)position OBJC_DESIGNATED_INITIALIZER;
/// 카메라 회전각(radian, 정북기준 시계방향).
@property (nonatomic, readonly) double pan;
/// 카메라 기울임각(radian, 지평선과 평행 기준, 양수값이 지면방향)
@property (nonatomic, readonly) double tilt;
/// 카메라가 바라볼 위치
@property (nonatomic, readonly, strong) MapPoint * _Nullable position;
/// RoadviewLookAt Type.
@property (nonatomic, readonly) RoadviewLookAtType lookAtType;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class RouteSegment;

/// 맵에 표시되는 Route를 나타내는 클래스.
/// Route는 Polyline/MapPolyline 과 마찬가지로 선을 그리는 기능을 하지만 경로선을 표현하기 위한 기능을 추가로 가지고 있다.
/// 예를 들면 레벨별로 디테일 조절 처리가 들어간다. 즉, 상위 레벨일수록 RoutePoints가 rough하게 표시되며, 하위레벨일수록 자세하게 표시된다.
/// 따라서 맵에 경로를 표시할 때 사용하기에 적절하다. show/hide/style 변경 등이 가능하다.
/// 하나 이상의 RouteSegment로 이루어진다. Route는 레벨별로 디테일 조절 처리가 들어간다.
/// Route를 추가하기 위해서는 먼저 KakaoMap에 RouteLayer를 추가한 뒤, 해당 Layer에 Route를 추가한다.
/// Route는 사용자가 직접 생성할 수 없으며, RouteLayer를 통해 해당 Object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK5Route")
@interface Route : NSObject
/// Route를 보여준다.
- (void)show;
/// Route를 숨긴다.
- (void)hide;
/// Route의 style과 Data를 변경한다.
/// Route의 Style과 함께 Route가 표시하는 RouteSegment Data를 변경하고자 할 때 사용한다. 단, RouteSegment Data를 바꿀때는 해당 Route 객체가 가리키는 본질이 변하지 않을때만 사용한다. 즉 전혀 다른 Route 객체일때는 Route를 하나 더 만드는것을 권장한다.
/// ex. 경로 탐색 결과를 보여주고, 교통 정보가 업데이트 되어서 스타일과 segment가 바뀌어야 하는 경우.
/// ex. 경로 탐색 결과를 여러개 보여주고, disabled route <-> enabled route 로 style 전환이 필요한 경우.
/// \param styleID 변경할 styleID
///
/// \param segments 변경할 route segments data.
///
- (void)changeStyleAndDataWithStyleID:(NSString * _Nonnull)styleID segments:(NSArray<RouteSegment *> * _Nonnull)segments;
/// Route의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull routeID;
/// Route가 속한 Layer의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// Route의 렌더링 우선순위. 값이 클수록 위에 그려진다.
/// 새로운 zOrder로 assgin하면, 해당 Route의 zOrder가 업데이트된다.
/// zOrder = 0인 Route는 zOrder = 1 인 Route보다 아래에 그려진다.
@property (nonatomic) NSInteger zOrder;
/// Route가 표출되고있는지에 대한 여부를 가져온다.
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class RouteOptions;

/// Route객체를 관리하는 단위인 RouteLayer 클래스.
/// Route를 추가/삭제 등 관리할 수 있으며, 일종의 그룹처럼 관리가 가능하다.
/// 사용자가 직접 객체를 생성할 수 없으며, RouteManager를 통해 객체를 간접적으로 생성할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10RouteLayer")
@interface RouteLayer : NSObject
/// 현재 layer에 속한 Route를 일괄적으로 지운다.
- (void)clearAllRoutes;
/// 현재 Layer에 Route를 추가한다.
/// 하나의 레이어안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// seealso:
/// RouteSegment
/// \param option 추가할 segment의 option.
///
/// \param callback Route 추가가 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성한 Route 객체
- (Route * _Nullable)addRouteWithOption:(RouteOptions * _Nonnull)option callback:(void (^ _Nullable)(Route * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정 Route를 제거한다.
/// \param routeID 제거할 routeID
///
/// \param callback Route제거가 완료되었을 때, 호출할 callback(optional)
///
- (void)removeRouteWithRouteID:(NSString * _Nonnull)routeID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 특정 Route를 제거한다.
/// \param routeIDs 제거할 routeID 배열
///
/// \param callback Route제거가 완료되었을 때, 호출할 callback(optional)
///
- (void)removeRoutesWithRouteIDs:(NSArray<NSString *> * _Nonnull)routeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 특정 Route를 보여준다.
/// \param routeIDs 보여줄 routeID 배열
///
- (void)showRoutesWithRouteIDs:(NSArray<NSString *> * _Nonnull)routeIDs;
/// 현재 Layer에 속한 특정 Route를 숨긴다.
/// \param routeIDs 숨길 routeID 배열
///
- (void)hideRoutesWithRouteIDs:(NSArray<NSString *> * _Nonnull)routeIDs;
/// 현재 Layer에 속한 Route를 가져온다.
/// \param routeID 가져올 routeID
///
///
/// returns:
/// ID에 해당하는 Route객체. 없을경우 nil
- (Route * _Nullable)getRouteWithRouteID:(NSString * _Nonnull)routeID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 다수의 Route를 가져온다.
/// \param routeIDs 가져올 routeID 배열
///
///
/// returns:
/// ID에 해당하는 Route객체 배열. 없을경우 nil
- (NSArray<Route *> * _Nullable)getRoutesWithRouteIDs:(NSArray<NSString *> * _Nonnull)routeIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 레이어에 속한 모든 Route를 가져온다.
///
/// returns:
/// 현재 Layer에 추가되어있는 모든 Route 객체 배열
- (NSArray<Route *> * _Nullable)getAllRoutes SWIFT_WARN_UNUSED_RESULT;
/// RouteLayer ID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// RouteLayer의 visible 상태.
/// layer의 on/off 상태를 나타내며, layer에 속한 객체의 show/hide는 별도로 동작시켜야한다.
/// 즉, layer의 visible이 true여도 layer에 속한 객체의 show를 호출해야 보이고, visible이 false라면 layer에 속한 객체는 화면에 표시되지 않는다.
@property (nonatomic) BOOL visible;
/// RouteLayer의 렌더링 우선순위
/// 값이 클수록 위에 그려진다. 같은 RouteLayer끼리만 유효하다.
/// 즉, zOrder = 0 인 RouteLayer에 속한 Route는 zOrder = 1 인 RouteLayer에 속한 Route보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class RouteStyleSet;

/// KakaoMap에서 Route 객체를 관리하기 위한 클래스
/// RotueLayer의 추가/삭제 등의 관리와 Route를 표시하기 위한 Style 추가가 가능하다.
/// KakaoMap에 종속적이므로 KakaoMap이 삭제된 뒤에도 사용하지 않도록 주의하여야 한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12RouteManager")
@interface RouteManager : NSObject
/// RouteStyleSet을 추가한다.
/// Route가 여러개의 RouteSegment로 구성되는 경우, 하나의 스타일셋으로 segment별로 다르게 표시할 수 있다. 같은 styleID로 추가하더라도 overwrite되지 않는다.
/// seealso:
/// RouteStyle
/// \param styleSet 추가할 RouteStyleSet
///
- (void)addRouteStyleSet:(RouteStyleSet * _Nonnull)styleSet;
/// RouteLayer를 추가한다.
/// Route관리할 수 있는 단위인 RouteLayer를 추가한다. 이미 KakaoMap에 추가되어있는 ID와 동일한 layer를 추가하고자 하는 경우, 기존 객체를 리턴한다.
/// \param layerID 추가할 routeLayer ID
///
/// \param zOrder layer의 렌더링 우선순위. 값이 높을수록 위에 그려진다.
///
///
/// returns:
/// 생성한 RouteLayer 객체
- (RouteLayer * _Nullable)addRouteLayerWithLayerID:(NSString * _Nonnull)layerID zOrder:(NSInteger)zOrder SWIFT_WARN_UNUSED_RESULT;
/// KakaoMap에 추가한 RouteLayer를 가져온다.
/// \param layerID 가져올 RouteLayer ID
///
///
/// returns:
/// ID에 해당하는 routerLayer 객체. 없을경우 nil 리턴
- (RouteLayer * _Nullable)getRouteLayerWithLayerID:(NSString * _Nonnull)layerID SWIFT_WARN_UNUSED_RESULT;
/// KakaoMap에 추가한 RouteLayer를 제거한다.
/// \param layerID 제거할 layer ID
///
- (void)removeRouteLayerWithLayerID:(NSString * _Nonnull)layerID;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Route를 생성하기 위한 Route 생성 옵션 클래스.
SWIFT_CLASS("_TtC12KakaoMapsSDK12RouteOptions")
@interface RouteOptions : NSObject
/// Initializer
/// \param styleID RouteStyleSet ID
///
/// \param zOrder Route 렌더링 우선순위. 값이 클수록 위에 그려진다.
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param routeID Route 고유 ID
///
/// \param styleID RouteStyleSet ID
///
/// \param zOrder Route 렌더링 우선순위. 값이 클수록 위에 그려진다.
///
- (nonnull instancetype)initWithRouteID:(NSString * _Nonnull)routeID styleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// Route ID. 생성시 별도로 지정하지 않는 경우, 내부적으로 id를 자동으로 부여한다.
@property (nonatomic, readonly, copy) NSString * _Nullable routeID;
/// Route가 사용할 styleSet ID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
/// Route 렌더링 우선순위
/// 값이 클수록 위에 그려진다. 같은 Route끼리만 유효하다.
/// 즉, zOrder = 0 인 Route는 zOrder = 1 인 Route보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
/// Route를 구성하는 RouteSegment 배열.
/// Route는 하나 이상의 RouteSegment로 이루어진다. RouteSegment는 두개 이상의 정점으로 이루어지며, 각 Segment마다 StyleSet의 index를 부여하여 RouteSegment단위로 스타일을 다르게 표시할 수 있다.
/// seealso:
/// RouteSegment
@property (nonatomic, copy) NSArray<RouteSegment *> * _Nonnull segments;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// RoutePattern 클래스
/// Route에 표시할 패턴을 정의하는 클래스.
SWIFT_CLASS("_TtC12KakaoMapsSDK12RoutePattern")
@interface RoutePattern : NSObject
/// Initializer
/// \param pattern 사용할 패턴 이미지
///
/// \param distance 패턴이 표시되는 간격
///
/// \param symbol 반복적으로 그려지는 패턴 외에, 한번 표시되어 segment의 속성을 표현하는 심볼
///
/// \param pinStart 패턴의 시작지점을 고정할지에 대한 여부
///
/// \param pinEnd 패턴의 끝지점을 고정할지에 대한 여부
///
- (nonnull instancetype)initWithPattern:(UIImage * _Nonnull)pattern distance:(float)distance symbol:(UIImage * _Nullable)symbol pinStart:(BOOL)pinStart pinEnd:(BOOL)pinEnd OBJC_DESIGNATED_INITIALIZER;
/// 사용할 패턴 이미지
@property (nonatomic, readonly, strong) UIImage * _Nullable pattern;
/// 패턴 이미지 외에 패턴의 속성을 표시할 심볼
@property (nonatomic, readonly, strong) UIImage * _Nullable symbol;
/// 패턴이 표시되는 간격
@property (nonatomic, readonly) float distance;
/// 패턴이 시작지점에 고정적으로 그려지게 하는 여부
@property (nonatomic, readonly) BOOL pinStart;
/// 패턴이 끝지점에 고정적으로 그려지게 하는 여부
@property (nonatomic, readonly) BOOL pinEnd;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Route를 나타내는 RouteSegment 클래스.
/// Route는 하나 이상의 segment로 구성되고, Segment는 두 개 이상의 라인 포인트로 이루어지며, 모든 라인 포인트를 순서대로 연결한 선으로 그려진다.
/// 각 RouteSegment별로 다른 styleIndex를 적용하여 다르게 표시할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12RouteSegment")
@interface RouteSegment : NSObject
/// Initializer
/// \param points Segment를 구성하는 라인 포인트 배열
///
/// \param styleIndex Segment를 표시할 style의 인덱스
///
- (nonnull instancetype)initWithPoints:(NSArray<MapPoint *> * _Nonnull)points styleIndex:(NSUInteger)styleIndex OBJC_DESIGNATED_INITIALIZER;
/// 라인 포인트 배열
@property (nonatomic, readonly, copy) NSArray<MapPoint *> * _Nonnull points;
/// segment를 표시할 스타일 인덱스
@property (nonatomic, readonly) NSUInteger styleIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// RouteStyle 클래스.
/// Route의 style을 지정하기 위해 사용한다. 한개 이상의 PerLevelRouteStyle 로 구성된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10RouteStyle")
@interface RouteStyle : NSObject
/// initializer
/// \param styles RouteStyle을 구성할 단위레벨별 PerLevelRouteStyle 배열
///
- (nonnull instancetype)initWithStyles:(NSArray<PerLevelRouteStyle *> * _Nonnull)styles OBJC_DESIGNATED_INITIALIZER;
/// 추가한 PerLevelRouteStyle 배열
@property (nonatomic, readonly, copy) NSArray<PerLevelRouteStyle *> * _Nonnull styles;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// RouteStyleSet 클래스
/// Route를 구성하는 여러개의 RouteSegment마다 다른 스타일을 적용하고자 할 때 사용한다. StyleSet에 추가한 스타일의 인덱스를 RouteSegment마다 지정할 수 있다.
/// 또한 RouteSegment마다 사용하고자 하는 Route Pattern 또한 해당 클래스에서 추가 할 수 있다. 패턴도 style과 마찬가지로 인덱스로 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK13RouteStyleSet")
@interface RouteStyleSet : NSObject
/// Initializer
/// \param styleID StyleID
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param styleID StyleSet ID
///
/// \param styles RouteStyleSet을 구성할 RouteStyle 배열
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID styles:(NSArray<RouteStyle *> * _Nonnull)styles;
/// styleSet에 추가할 LevelStyle을 추가한다.
/// seealso:
/// RouteStyle
/// \param style 추가할 RouteStyle
///
- (void)addStyle:(RouteStyle * _Nonnull)style;
/// StyleSet에 RoutePattern을 추가한다.
/// seealso:
/// RoutePattern
/// \param pattern 추가하고자 하는 패턴
///
- (void)addPattern:(RoutePattern * _Nonnull)pattern;
/// styleSet ID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleSetID;
/// 추가한 RouteStyle 배열
@property (nonatomic, readonly, copy) NSArray<RouteStyle *> * _Nonnull styles;
/// 추가한 RoutePattern의 배열
@property (nonatomic, readonly, copy) NSArray<RoutePattern *> * _Nonnull patterns;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class ScaleAlphaAnimationKeyFrame;

/// AnimationEffect중 Animation 시간동안 지정된 Keyframe 에 따라 회전 변환을 수행하는 애니메이션 효과.
/// Poi에 적용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK25ScaleAlphaAnimationEffect")
@interface ScaleAlphaAnimationEffect : KeyFrameAnimationEffect
/// Initializer
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// 애니메이션 키프레임을 추가한다.
/// \param frame 추가할 키프레임.
///
- (void)addKeyframe:(ScaleAlphaAnimationKeyFrame * _Nonnull)frame;
@end


/// ScaleAlphaAnimation 을 구성하기 위해 하나의 keyframe을 구성하기 위한 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK27ScaleAlphaAnimationKeyFrame")
@interface ScaleAlphaAnimationKeyFrame : AnimationKeyFrame
/// Initializer
/// \param scale 확대변환 값. 1.0 기준 확대축소값.
///
/// \param alpha 투명도 값 0.0 ~ 1.0
///
/// \param interpolation 프레임 시간, 보간 방법.
///
- (nonnull instancetype)initWithScale:(struct Vector2)scale alpha:(float)alpha interpolation:(struct AnimationInterpolation)interpolation OBJC_DESIGNATED_INITIALIZER;
/// 투명도 값. 0.0~1.0
@property (nonatomic) float alpha;
/// 확대축소변환. 1.0 기준 확대값.
@property (nonatomic) struct Vector2 scale;
@end

@class ScaleAnimationKeyFrame;

/// AnimationEffect중 Animation 시간동안 지정된 Keyframe 에 따라 회전 변환을 수행하는 애니메이션 효과.
/// Poi에 적용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK20ScaleAnimationEffect")
@interface ScaleAnimationEffect : KeyFrameAnimationEffect
/// Initializer
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// 애니메이션 키프레임을 추가한다.
/// \param frame 추가할 키프레임.
///
- (void)addKeyframe:(ScaleAnimationKeyFrame * _Nonnull)frame;
@end


/// ScaleAnimation 을 구성하기 위해 하나의 keyframe을 구성하기 위한 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK22ScaleAnimationKeyFrame")
@interface ScaleAnimationKeyFrame : AnimationKeyFrame
/// Initializer
/// \param scale 확대변환 값. 1.0 기준 확대축소값.
///
/// \param interpolation 프레임 시간, 보간 방법.
///
- (nonnull instancetype)initWithScale:(struct Vector2)scale interpolation:(struct AnimationInterpolation)interpolation OBJC_DESIGNATED_INITIALIZER;
/// 확대축소변환. 1.0 기준 확대값.
@property (nonatomic) struct Vector2 scale;
@end



/// ShapeAnimation을 생성할 때 Animation Effect 종류를 정의하는 프로토콜.
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK20ShapeAnimationEffect_")
@protocol ShapeAnimationEffect
/// 애니메이션의 지속시간,  프레임간의 보간 방법등을 지정
@property (nonatomic) struct AnimationInterpolation interpolation;
/// 애니메이션 종료시 대상 객체를 숨길지 여부를 지정.
@property (nonatomic) BOOL hideAtStop;
/// 애니메이션 재생 횟수.
@property (nonatomic) NSUInteger playCount;
@end


/// Shape에 애니메이션 효과를 주기 위한 Animator 클래스.
/// Animator를 생성해서 애니메이션 효과를 주고자 하는 Shape를 Animator에 넣어서 animator를 동작시키는 방식이다.
/// Animator는 사용자가 직접 생성할 수 없으며, ShapeManager를 통해서만 생성한 객체를 받아서 사용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK13ShapeAnimator")
@interface ShapeAnimator : NSObject <Animator>
/// Animator를 동작시킨다.
/// Animator에 추가된 Shape가 없으면 start함수는 동작하지 않는다. start를 호출한 이후에는 Animator에   Shape를 추가하거나 지울 수 없다.
/// 추가하고자 하는 경우, stop을 호출하고 추가해야한다.
/// start 호출 이후 애니메이션이 끝나면 Animator에 추가된 Shape는 비워지므로, 다시 start를 호출하려면 Shape를 추가해야한다.
/// Shape Interface에 있는 이동/회전등의 동작은 Animator가 start되면 멈춘다.
- (void)start;
/// Animator의 동작을 멈춘다.
/// stop이 호출되면 다시 애니메이션이 끝난것으로 간주되어 Animator에 속한 Shape는 모두 비워지므로, Animator를 다시 동작시키리면 다시 Shape를 Animator에 추가해야한다.
- (void)stop;
/// Animator 의 종료 콜백을 지정한다. Start 된 애니메이션이 종료되거나 stop이 호출되면 지정한 callback 이 호출된다. nil 로 지정해서 기존에 지정했던 callback을 제거할 수 있다. 기본값 nil.
/// \param callback Animator에 추가할 종료 콜백.
///
- (void)setStopCallback:(void (^ _Nullable)(id <Animator> _Nullable))callback;
/// Animator에 MapPolygonShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 MapPolygonShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 MapPolygonShape를 추가할 수 없다.
/// \param shape Animator에 추가할 MapPolygonShape
///
- (void)addMapPolygonShape:(MapPolygonShape * _Nonnull)shape;
/// Animator에 여러개의 MapPolygonShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 MapPolygonShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 MapPolygonShape를 추가할 수 없다.
/// \param shapes Animator에 추가할 MapPolygonShape 배열
///
- (void)addMapPolygonShapes:(NSArray<MapPolygonShape *> * _Nonnull)shapes;
/// Animator에 PolygonShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 PolygonShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 PolygonShape를 추가할 수 없다.
/// \param shape Animator에 추가할 PolygonShape
///
- (void)addPolygonShape:(PolygonShape * _Nonnull)shape;
/// Animator에 여러개의 PolygonShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 PolygonShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 PolygonShape를 추가할 수 없다.
/// \param shapes Animator에 추가할 PolygonShape 배열
///
- (void)addPolygonShapes:(NSArray<PolygonShape *> * _Nonnull)shapes;
/// Animator에 MapPolylineShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 MapPolylineShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 MapPolylineShape를 추가할 수 없다.
/// \param shape Animator에 추가할 MapPolylineShape
///
- (void)addMapPolylineShape:(MapPolylineShape * _Nonnull)shape;
/// Animator에 여러개의 MapPolylineShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 MapPolylineShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 MapPolylineShape를 추가할 수 없다.
/// \param shapes Animator에 추가할 MapPolylineShape 배열
///
- (void)addMapPolylineShapes:(NSArray<MapPolylineShape *> * _Nonnull)shapes;
/// Animator에 PolylineShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 PolylineShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 PolylineShape를 추가할 수 없다.
/// \param shape Animator에 추가할 PolylineShape
///
- (void)addPolylineShape:(PolylineShape * _Nonnull)shape;
/// Animator에 여러개의 PolylineShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 PolylineShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 PolylineShape를 추가할 수 없다.
/// \param shapes Animator에 추가할 PolylineShape 배열
///
- (void)addPolylineShapes:(NSArray<PolylineShape *> * _Nonnull)shapes;
/// Animator에 추가한 shape를 모두 지운다.
/// start() 호출 이후에는 동작하지 않는다.
- (void)clearAllShapes;
/// 추가한 animatorID
@property (nonatomic, readonly, copy) NSString * _Nonnull animatorID;
/// Animator 동작이 완료되고 나면 Animator에 추가된 폴리곤을 사라지게 할 지에 대한 여부
@property (nonatomic) BOOL hideAtStop;
/// Animator 시작 여부
@property (nonatomic, readonly) BOOL isStart;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Shape를 관리하는 단위인 ShapeLayer 클래스.
/// Shape를 추가/삭제 등 관리할 수 있으며, 일종의 그룹처럼 관리가 가능하다.
/// 사용자가 직접 객체를 생성할 수 없으며, LabelManager를 통해 객체를 간접적으로 생성할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10ShapeLayer")
@interface ShapeLayer : NSObject
/// ShapeLayer의 visible 상태.
/// layer의 on/off 상태를 나타내며, layer에 속한 객체의 show/hide는 별도로 동작시켜야한다.
/// 즉, layer의 visible이 true여도 layer에 속한 객체의 show를 호출해야 보이고, visible이 false라면 layer에 속한 객체는 화면에 표시되지 않는다.
@property (nonatomic) BOOL visible;
/// 현재 레이어에 속한 모든 PolygonShape, MapPolygonShape를 표시한다.
- (void)showAllPolygonShapes;
/// 현재 레이어에 속한 모든 PolygonShape, MapPolygonShape를 숨긴다.
- (void)hideAllPolygonShapes;
/// 현재 레이어에 속한 모든 PolylineShape, MapPolylineShape를 표시한다.
- (void)showAllPolylineShapes;
/// 현재 레이어에 속한 모든 PolylineShape, MapPolylineShape를 숨긴다..
- (void)hideAllPolylineShapes;
/// 현재 레이어에 속한 모든 Shape를 표시한다.
- (void)showAllShapes;
/// 현재 레이어에 속한 모든 Shape를 숨긴다.
- (void)hideAllShapes;
/// 현재 layer에 있는 모든 item을 일괄적으로 지운다.
- (void)clearAllShapes;
/// 현재 Layer에 MapPolygonShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 MapPolygonShape 옵션
///
/// \param callback MapPolygonShape객체가 생성이 완료됐을 때 호출할 콜백함수(optional)
///
///
/// returns:
/// 생성된 MapPolygonShape 객체
- (MapPolygonShape * _Nullable)addMapPolygonShape:(MapPolygonShapeOptions * _Nonnull)shapeOptions callback:(void (^ _Nullable)(MapPolygonShape * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 다수의 MapPolygonShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 MapPolygonShape 옵션 배열
///
/// \param callback 생성한 다수의 MapPolygonShape가 모두 생성이 완료되었을 때, 호출할 콜백함수(optional)
///
///
/// returns:
/// 생성된 MapPolygonShape 객체 배열
- (NSArray<MapPolygonShape *> * _Nullable)addMapPolygonShapes:(NSArray<MapPolygonShapeOptions *> * _Nonnull)shapeOptions callback:(void (^ _Nullable)(NSArray<MapPolygonShape *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정 MapPolygonShape를 지운다.
/// \param shapeID Layer에서 제거할 MapPolygonShape Id
///
/// \param callback Layer에서 해당 Shape제거가 완료되었을 때, 호출할 콜백함수(optional)
///
- (void)removeMapPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 다수의 MapPolygonShape를 지운다.
/// \param shapeID Layer에서 제거할 MapPolygonShape Id 배열
///
/// \param callback Layer에서 id에 해당하는 모든 shape제거가 완료되었을 때, 호출할 콜백함수(optional)
///
- (void)removeMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 특정 MapPolygonShape를 보여준다.
/// \param shapeIDs 보여줄 MapPolygonShape ID 배열
///
- (void)showMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 특정 MapPolygonShape를 숨긴다.
/// \param shapeIDs 숨길 MapPolygonShape ID 배열
///
- (void)hideMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 MapPolygonShape를 가져온다.
/// \param shapeID 가져올 MapPolygonShape ID
///
///
/// returns:
/// ID에 해당하는 MapPolygonShape 객체, 없을경우 nil.
- (MapPolygonShape * _Nullable)getMapPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 다수의 MapPolygonShape를 가져온다.
/// \param shapeIDs 가져올 MapPolygonShape ID 배열
///
///
/// returns:
/// ID에 해당하는 MapPolygonShape 객체 배열, 없을경우 nil.
- (NSArray<MapPolygonShape *> * _Nullable)getMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 MapPolygonShape를 가져온다.
///
/// returns:
/// 현재 Layer에 추가된 MapPolygonShape 배열
- (NSArray<MapPolygonShape *> * _Nullable)getAllMapPolygonShapes SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 PolygonShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 PolygonShape 옵션
///
/// \param callback PolygonShape객체가 생성이 완료됐을 때 호출할 콜백함수(optional)
///
///
/// returns:
/// 생성된 PolygonShape 객체
- (PolygonShape * _Nullable)addPolygonShape:(PolygonShapeOptions * _Nonnull)shapeOptions callback:(void (^ _Nullable)(PolygonShape * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 다수의 PolygonShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 PolygonShape 옵션 배열
///
/// \param callback PolygonShape객체가 생성이 완료됐을 때 호출할 콜백함수(optional)
///
///
/// returns:
/// 생성된 Shape 객체 배열
- (NSArray<PolygonShape *> * _Nullable)addPolygonShapes:(NSArray<PolygonShapeOptions *> * _Nonnull)shapeOptions callback:(void (^ _Nullable)(NSArray<PolygonShape *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정 PolygonShape를 지운다.
/// \param shapeID Layer에서 제거할 PolygonShape Id
///
/// \param callback Layer에서 해당 Shape제거가 완료되었을 때, 호출할 콜백함수(optional)
///
- (void)removePolygonShapeWithShapeID:(NSString * _Nonnull)shapeID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 다수의 PolygonShape를 지운다.
/// \param shapeID Layer에서 제거할 PolygonShape Id 배열
///
/// \param callback Layer에서 id에 해당하는 모든 shape제거가 완료되었을 때, 호출할 콜백함수(optional)
///
- (void)removePolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 특정 PolygonShape를 보여준다.
/// \param shapeIDs 보여줄 PolygonShape ID 배열
///
- (void)showPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 특정 PolygonShape를 숨긴다.
/// \param shapeIDs 숨길 PolygonShape ID 배열
///
- (void)hidePolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 PolygonShape를 가져온다.
/// \param shapeID 가져올 PolygonShape ID
///
///
/// returns:
/// ID에 해당하는 PolygonShape 객체, 없을경우 nil.
- (PolygonShape * _Nullable)getPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 다수의 PolygonShape를 가져온다.
/// \param shapeIDs 가져올 PolygonShape ID 배열
///
///
/// returns:
/// ID에 해당하는 PolygonShape 객체 배열, 없을경우 nil.
- (NSArray<PolygonShape *> * _Nullable)getPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 PolygonShape를 가져온다.
///
/// returns:
/// 현재 Layer에 추가된 PolygonShape 배열
- (NSArray<PolygonShape *> * _Nullable)getAllPolygonShapes SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 MapPolylineShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 객체를 리턴한다.
/// \param shapeOptions 생성할 MapPolylineShape 옵션
///
/// \param callback 생성한 MapPolylineShape 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 MapPolylineShape 객체
- (MapPolylineShape * _Nullable)addMapPolylineShape:(MapPolylineShapeOptions * _Nonnull)shapeOptions callback:(void (^ _Nullable)(MapPolylineShape * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 다수의 MapPolylineShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 MapPolylineShape 옵션
///
/// \param callback 생성한 MapPolylineShape 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 MapPolylineShape객체 배열
- (NSArray<MapPolylineShape *> * _Nullable)addMapPolylineShapes:(NSArray<MapPolylineShapeOptions *> * _Nonnull)shapeOptions callback:(void (^ _Nullable)(NSArray<MapPolylineShape *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정 MapPolylineShape를 지운다.
/// \param shapeID Layer에서 제거할 MapPolylineShape ID
///
/// \param callback Layer에서 지정한 MapPolylineShape가 지워졌을 때, 호출할 callback(optional)
///
- (void)removeMapPolylineShapeWithShapeID:(NSString * _Nonnull)shapeID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 다수의 MapPolylineShape를 지운다.
/// \param shapeIDs Layer에서 제거할 MapPolylineShape ID 배열
///
/// \param callback Layer에서 지정한 MapPolylineShape가 모두 지워졌을 때, 호출할 callback(optional)
///
- (void)removeMapPolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 특정 MapPolylineShape를 보여준다.
/// \param shapeIDs 보여줄 MapPolylineShape ID 배열
///
- (void)showMapPolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 특정 MapPolylineShape를 숨긴다.
/// \param shapeIDs 숨길 MapPolylineShape ID 배열
///
- (void)hideMapPolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 MapPolylineShape를 가져온다.
/// \param shapeIDs 가져올 MapPolylineShape
///
///
/// returns:
/// ID에 해당하는 MapPolylineShape 객체. 없을 경우 nil
- (MapPolylineShape * _Nullable)getMapPolylineShapeWithShapeID:(NSString * _Nonnull)shapeID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 다수의 MapPolylineShape를 가져온다.
/// \param shapeIDs 가져올 MapPolylineShape ID
///
///
/// returns:
/// ID에 해당하는 MapPolylineShape 객체. 없을 경우 nil
- (NSArray<MapPolylineShape *> * _Nullable)getMapPolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 MapPolylineShape를 가져온다.
///
/// returns:
/// 현재 Layer에 추가되어있는 모든 MapPolylineShape 객체 배열
- (NSArray<MapPolylineShape *> * _Nullable)getAllMapPolylineShapes SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 PolylineShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 객체를 리턴한다.
/// \param shapeOptions 생성할 PolylineShape 옵션
///
/// \param callback 생성한 MapPolylineShape 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 PolylineShape 객체
- (PolylineShape * _Nullable)addPolylineShape:(PolylineShapeOptions * _Nonnull)shapeOptions callback:(void (^ _Nullable)(PolylineShape * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 다수의 PolylineShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 PolylineShape 옵션
///
/// \param callback 생성한 MapPolylineShape 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 PolylineShape 객체 배열
- (NSArray<PolylineShape *> * _Nullable)addPolylineShapes:(NSArray<PolylineShapeOptions *> * _Nonnull)shapeOptions callback:(void (^ _Nullable)(NSArray<PolylineShape *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정 PolylineShape를 지운다.
/// \param shapeID Layer에서 제거할 PolylineShape ID
///
- (void)removePolylineShapeWithShapeID:(NSString * _Nonnull)shapeID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 다수의 PolylineShape를 지운다.
/// \param shapeIDs Layer에서 제거할 PolylineShape ID 배열
///
/// \param callback Layer에서 지정한 PolylineShape가 모두 지워졌을 때, 호출할 callback(optional)
///
- (void)removePolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 특정 PolylineShape를 보여준다.
/// \param shapeIDs 보여줄 PolylineShape ID 배열
///
- (void)showPolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 특정 PolylineShape를 숨긴다.
/// \param shapeIDs 숨길 PolylineShape ID 배열
///
- (void)hidePolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 PolylineShape를 가져온다.
/// \param shapeIDs 가져올 PolylineShapeID
///
///
/// returns:
/// ID에 해당하는 PolylineShape 객체. 없을 경우 nil
- (PolylineShape * _Nullable)getPolylineShapeWithShapeID:(NSString * _Nonnull)shapeID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 다수의 PolylineShape를 가져온다.
/// \param shapeIDs 가져올 PolylineShapeID
///
///
/// returns:
/// ID에 해당하는 PolylineShape 객체. 없을 경우 nil
- (NSArray<PolylineShape *> * _Nullable)getPolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 PolylineShape를 가져온다.
///
/// returns:
/// 현재 Layer에 추가되어있는 모든 PolylineShape 객체 배열
- (NSArray<PolylineShape *> * _Nonnull)getAllPolylineShapes SWIFT_WARN_UNUSED_RESULT;
/// ShapeLayer의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// ShapeLayer의 렌더링 우선순위.
/// 높은 zOrder의 Layer에 속한 Shape가 더 위에 그려지며, ShapeLayer type끼리만 유효하다.
/// 즉, zOrder = 0 인 ShapeLayer에 속한 Shape는 zOrder = 1 인 ShapeLayer에 속한 Shape보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// KakaoMap에서 사용자 shape를 사용하고 관리하기 위한 클래스
/// ShapeLayer의 추가/삭제 등의 관리와 shape의 style, animator추가가 가능하다.
/// KakaoMap에 종속적이므로 KakaoMap이 삭제된 뒤에도 사용하지 않도록 주의하여야 한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12ShapeManager")
@interface ShapeManager : NSObject
/// PolygonStyleSet을 추가한다.
/// PolygonShape의 Polygon이 여러개인 경우, Polygon마다 다른 스타일을 설정할 수 있다. 같은 styleID로 추가하더라도 overwrite되지 않는다.
/// seealso:
/// PolygonStyleSet
/// \param styles 추가할 PolygonStyleSet
///
- (void)addPolygonStyleSet:(PolygonStyleSet * _Nonnull)styles;
/// PolylineStyleSet을 추가한다.
/// PolylineShape의 Polyline이 여러개인 경우, Polyline마다 다른 스타일을 설정할 수 있다. 같은 styleID로 추가하더라도 overwrite되지 않는다.
/// seealso:
/// PolylineStyleSet
/// \param styles 추가할 PolylineStyleSet
///
- (void)addPolylineStyleSet:(PolylineStyleSet * _Nonnull)styles;
/// ShapeLayer를 추가한다.
/// Shape를 관리할 수 있는 단위인 ShapeLayer를 추가한다. 이미 KakaoMap에 추가되어있는 ID와 동일한 layer를 추가하고자 하는 경우, 기존 객체를 리턴한다.
/// seealso:
/// ShapeLayerPassType
/// \param layerID 추가할 shapeLayerID
///
/// \param zOrder layer의 렌더링 우선순위. 높을수록 위에 그려진다.
///
/// \param passType ShapeLayer의 passType. 해당 레이어에 추가한 Shape가 그려지는 순서를 지정할 수 있다.
///
///
/// returns:
/// 생성한 ShapeLayer 객체
- (ShapeLayer * _Nullable)addShapeLayerWithLayerID:(NSString * _Nonnull)layerID zOrder:(NSInteger)zOrder passType:(ShapeLayerPassType)passType SWIFT_WARN_UNUSED_RESULT;
/// KakaoMap에 추가한 ShapeLayer를 가져온다.
/// \param layerID 가져올 shapeLayerID
///
///
/// returns:
/// ID에 해당하는 shapeLayer객체. 없을경우 nil 리턴
- (ShapeLayer * _Nullable)getShapeLayerWithLayerID:(NSString * _Nonnull)layerID SWIFT_WARN_UNUSED_RESULT;
/// KakaoMap에 추가한 ShaeLayer를 제거한다.
/// \param layerID 제거할 layer의 ID
///
- (void)removeShapeLayerWithLayerID:(NSString * _Nonnull)layerID;
/// ShapeAnimator를 추가한다.
/// ShapeAnimator 객체는 사용자가 직접 생성할 수 없으며, Manager를 통해서만 생성이 가능하다. 이미 존재하는 AnimatorID로는 overwrite되지 않는다.
/// seealso:
/// AnimationInterpolation
/// seealso:
/// WaveAnimationEffect
/// \param animatorID ShapeAnimator ID
///
/// \param effect ShapeAnimationEffect type의 애니메이션 효과 지정
///
///
/// returns:
/// 생성된 Animator 객체
- (ShapeAnimator * _Nullable)addShapeAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID effect:(id <ShapeAnimationEffect> _Nonnull)effect SWIFT_WARN_UNUSED_RESULT;
/// 추가한 ShapeAnimator 객체를 제거한다.
/// \param animatorID 제거할 animatorID
///
- (void)removeShapeAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID;
/// 추가되어있는 모든 ShapeAnimaotr를 제거한다.
- (void)clearAllShapeAnimators;
/// 추가한 ShapeAnimator 객체를 가져온다.
/// \param animatorID 가져올 AnimatorID
///
///
/// returns:
/// animatorID에 해당하는 ShapeAnimator 객체. 존재하지 않을 경우 nil 리턴
- (ShapeAnimator * _Nullable)getShapeAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// SpriteGui Class
/// 기본적으로 main layout을 가지고 있으며, mainLayout에 GuiComponent를 활용하여 원하는 GUI를 구성한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK9SpriteGui")
@interface SpriteGui : GuiBase
/// initializer
/// SpriteGui 생성시 별도로 지정하지 않으면 default layout은 vertical layout으로 지정된다.
/// \param name Gui 이름
///
- (nonnull instancetype)init:(NSString * _Nonnull)name OBJC_DESIGNATED_INITIALIZER;
/// mainLayout에 Child component를 추가한다.
/// \param component GuiComponent
///
- (void)addChild:(GuiComponentBase * _Nonnull)component;
/// mainLayout에 추가된 component 중 하나를 가져온다.
/// \param componentId GuiComponent Id
///
///
/// returns:
/// Id에 해당하는 GuiComponent. 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// mainLayout의 childComponent 배치 방향. Vertical 혹은 Horizontal
@property (nonatomic) LayoutArrangement arrangement;
/// main Layout에 Gui 컴포넌트의 구분선 표시 여부
@property (nonatomic) BOOL showSplitLine;
/// main Layout에 Gui 컴포넌트의 구분선 컬러
@property (nonatomic, strong) UIColor * _Nonnull splitLineColor;
/// main Layout에 Gui 컴포넌트의 구분선 두께
@property (nonatomic) NSInteger splitLineWidth;
/// mainLayout의 배경 컬러
@property (nonatomic, strong) UIColor * _Nonnull bgColor;
/// Gui의 main layout
@property (nonatomic, readonly, strong) GuiLayout * _Nonnull main;
/// Gui가 그려질 origin을 지정한다. 이 origin을 기준점으로 position이 적용된다.
/// 값을 세팅하면, 별도의 updateGui() 호출 없이도 바로 반영된다.
@property (nonatomic) struct GuiAlignment origin;
/// origin으로 부터의 Position을 지정한다.
/// 값을 세팅하면, 별도의 updateGui() 호출 없이도 바로 반영된다.
@property (nonatomic) CGPoint position;
/// SpriteGu를 회전시킬 orientation 값
/// 값을 세팅하면, 별도의 updateGui() 호출 없이도 바로 반영된다.
@property (nonatomic) double orientation;
@end


/// SpriteGuiLayer - 화면상에 고정되는 형태의 GUI 들을 담는 Layer
SWIFT_CLASS("_TtC12KakaoMapsSDK14SpriteGuiLayer")
@interface SpriteGuiLayer : NSObject
/// SpriteGuiLayer의 visible 상태.
/// layer의 on/off 상태를 나타내며, layer에 속한 객체의 show/hide는 별도로 동작시켜야한다.
/// 즉, layer의 visible이 true여도 layer에 속한 객체의 show를 호출해야 보이고, visible이 false라면 layer에 속한 객체는 화면에 표시되지 않는다.
@property (nonatomic) BOOL visible;
/// 추가한 모든 SpriteGui를 지운다.
- (void)clear;
/// SpriteGui를 현재 레이어에 추가한다.
/// SpriteGui를 레이어에 추가하기 전까지는 화면에 표시되지 않는다.
/// 같은 이름으로 중복으로 추가할 수 없다.
/// \param gui 추가할 SpriteGui 객체
///
- (void)addSpriteGui:(SpriteGui * _Nonnull)gui;
/// SpriteGui를 현재 레이어에서 제거한다.
/// \param gui 제거할 SpriteGui 객체
///
- (void)removeSpriteGui:(SpriteGui * _Nonnull)gui;
/// guiName을 Key로 갖는 SpriteGui를 현재 레이어에서 제거한다.
/// \param guiName 제거할 SpriteGui의 guiName
///
- (void)removeSpriteGuiWithGuiName:(NSString * _Nonnull)guiName;
/// SpriteGuiLayer에 추가되어있는 SpriteGui를 guiName을 Key로 가져온다.
/// \param guiName 가져올 SpriteGui의 guiName
///
///
/// returns:
/// 이름에 해당하는 SpriteGui. 없을경우 nil
- (SpriteGui * _Nullable)getSpriteGuiWithGuiName:(NSString * _Nonnull)guiName SWIFT_WARN_UNUSED_RESULT;
/// SpriteGuiLayer에 특정 guiName을 가진 SpriteGui가 존재하는지 체크한다.
/// \param guiName 추가되어있는지 확인할 SpriteGui guiName
///
///
/// returns:
/// 존재 여부. 이미 추가되어있는 guiName의 경우 true, 아니면 false를 리턴한다.
- (BOOL)isSpriteGuiExistWithGuiName:(NSString * _Nonnull)guiName SWIFT_WARN_UNUSED_RESULT;
/// SpriteGuiLayer에 추가한 모든 SpriteGui를 가져온다.
///
/// returns:
/// 추가된 모든 SpriteGui 객체 배열
- (NSArray<SpriteGui *> * _Nullable)getAllSpriteGuis SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 글씨 색, 외곽선 색, 폰트 크기, 외곽선 두께 등의 스타일 속성을 지정하는 클래스.
SWIFT_CLASS("_TtC12KakaoMapsSDK9TextStyle")
@interface TextStyle : NSObject
/// Initializer
/// \param fontSize font 크기
///
/// \param fontColor font 컬러
///
/// \param strokeThickness font 외곽선 두께
///
/// \param strokeColor font 외곽선 색깔
///
/// \param font 사용할 font 이름
///
/// \param charSpace 자간. 0~4 사이값을 권장
///
/// \param lineSpace 행간
///
/// \param aspectRatio 장평
///
- (nonnull instancetype)initWithFontSize:(NSUInteger)fontSize fontColor:(UIColor * _Nonnull)fontColor strokeThickness:(NSUInteger)strokeThickness strokeColor:(UIColor * _Nonnull)strokeColor font:(NSString * _Nonnull)font charSpace:(NSInteger)charSpace lineSpace:(float)lineSpace aspectRatio:(float)aspectRatio OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param fontSize font 크기
///
/// \param fontColor font 컬러
///
- (nonnull instancetype)initWithFontSize:(NSUInteger)fontSize fontColor:(UIColor * _Nonnull)fontColor;
/// 글씨의 색
@property (nonatomic, readonly, strong) UIColor * _Nonnull fontColor;
/// 글씨 외곽선 색
@property (nonatomic, readonly, strong) UIColor * _Nonnull strokeColor;
/// 글씨 크기
@property (nonatomic, readonly) NSUInteger fontSize;
/// 글씨 외곽선의 두께
@property (nonatomic, readonly) NSUInteger strokeThickness;
/// 폰트
@property (nonatomic, readonly, copy) NSString * _Nonnull font;
/// 자간
@property (nonatomic, readonly) NSInteger charSpace;
/// 행간
@property (nonatomic, readonly) float lineSpace;
/// 장평
@property (nonatomic, readonly) float aspectRatio;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// KakaoMap 오브젝트의 tracking을 관리하는 클래스
/// 설정한 오브젝트의 position, orientation을 카메라가 따라간다.
/// 한번에 하나의 객체만 tracking 가능하며, tracking중에 다른 객체를 tracking하고자 할 경우 stop을 호출해야 다른 객체를 tracking 할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK15TrackingManager")
@interface TrackingManager : NSObject
/// 지정한 poi의 tracking을 시작한다.
/// \param poi tracking하고자하는 poi 객체
///
- (void)startTrackingPoi:(Poi * _Nonnull)poi;
/// 현재 tracking하고 있는 객체의 tracking을 멈춘다.
- (void)stopTracking;
/// 지정한 객체의 tracking을 위치만 추적할것인지,  객체 회전값도 추적할것인지를 지정한다.
/// 기본적으로 위치만 추적하며 true로 설정할 경우 객체의 회전값도 카메라가 tracking한다.
@property (nonatomic) BOOL isTrackingRoll;
/// 현재 tracking mode인지에 대한 여부.
/// 특정 obejct를 tracking하여 position및 orientation을 카메라가 따라가는중일경우, true 리턴.
/// 한번에 하나의 객체만 tracking할 수 있으므로 해당 값이 true일 경우 또 다른 객체를 트래킹 할 수 없다.
@property (nonatomic, readonly) BOOL isTracking;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class TransformAnimationKeyFrame;

/// AnimationEffect중 Animation 시간동안 지정된 Keyframe 에 따라 이동, 회전, 확대 변환을 수행하는 애니메이션 효과.
/// Poi에 적용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK24TransformAnimationEffect")
@interface TransformAnimationEffect : KeyFrameAnimationEffect
/// Initializer
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// 애니메이션 키프레임을 추가한다.
/// \param frame 추가할 키프레임.
///
- (void)addKeyframe:(TransformAnimationKeyFrame * _Nonnull)frame;
@end


/// TransformAnimation 을 구성하기 위해 하나의 keyframe을 구성하기 위한 클래스
/// 회전, 확대축소, 이동 변환 및 투명도 값으로 구성된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK26TransformAnimationKeyFrame")
@interface TransformAnimationKeyFrame : AnimationKeyFrame
/// Initializer
/// \param translation 이동할 픽셀단위값. 화면 scale 값이 곱해져서 적용됨.
///
/// \param rotation 회전 변환값. 시계 방향 radian 값.
///
/// \param scale 확대변환 값. 1.0 기준 확대축소값.
///
/// \param alpha 투명도 값. 0.0~1.0
///
/// \param interpolation 프레임 시간, 보간 방법.
///
- (nonnull instancetype)initWithTranslation:(struct Vector2)translation rotation:(float)rotation scale:(struct Vector2)scale alpha:(float)alpha interpolation:(struct AnimationInterpolation)interpolation OBJC_DESIGNATED_INITIALIZER;
/// 회전변환, 시계 방향 radian 값.
@property (nonatomic) float rotation;
/// 확대축소변환. 1.0 기준 확대값.
@property (nonatomic) struct Vector2 scale;
/// 픽셀 이동변환. 이동할 픽셀단위값. 화면 scale 값이 곱해져서 적용됨.
@property (nonatomic) struct Vector2 translation;
/// 투명도 값. 0.0~1.0
@property (nonatomic) float alpha;
@end




/// WaveAnimation에서 레벨별로 정의되는 속성.
SWIFT_CLASS("_TtC12KakaoMapsSDK17WaveAnimationData")
@interface WaveAnimationData : NSObject
/// Initializer
/// <ul>
///   <li>
///     parameters
///     <ul>
///       <li>
///         startAlpha: 애니메이션이 시작할 때 Shape의 알파값
///       </li>
///       <li>
///         endAlpha: 애니메이션이 끝날 때 Shape의 알파값
///       </li>
///       <li>
///         startRadius: 애니메이션이 시작할때 Shape의 스케일 값(px)
///       </li>
///       <li>
///         endRadius: 애니메이션이 끝날 때 Shape의 스케일 값(px)
///       </li>
///       <li>
///         level: 애니메이션이 적용될 레벨
///       </li>
///     </ul>
///   </li>
/// </ul>
- (nonnull instancetype)initWithStartAlpha:(float)startAlpha endAlpha:(float)endAlpha startRadius:(float)startRadius endRadius:(float)endRadius level:(NSInteger)level OBJC_DESIGNATED_INITIALIZER;
/// 애니메이션이 시작될때의 알파값
@property (nonatomic, readonly) float startAlpha;
/// 애니메이션이 끝날때의 알파값
@property (nonatomic, readonly) float endAlpha;
/// 애니메이션이 시작될때의 스케일
@property (nonatomic, readonly) float startRadius;
/// 애니메이션이 끝날때의 스케일
@property (nonatomic, readonly) float endRadius;
/// 애니메이션 적용 레벨
@property (nonatomic, readonly) NSInteger level;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// ShapeAnimationEffect중 Animation시간 동안 알파값과 크기(scale)을 변경하는 애니메이션 효과 클래스.
/// 레벨별로 시작/끝 알파값과 크기를 다르게 정의할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK19WaveAnimationEffect")
@interface WaveAnimationEffect : NSObject <ShapeAnimationEffect>
/// Initializer
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param datas WaveAnimationData 의 배열
///
- (nonnull instancetype)initWithDatas:(NSArray<WaveAnimationData *> * _Nonnull)datas OBJC_DESIGNATED_INITIALIZER;
/// WaveAnimation을 레벨별로 정의한다.
/// 레벨별로 애니메이션이 시작할 때, 끝날때의 알파값과 스케일(px)을 지정할 수 있다.
/// 정의에 따라 애니메이션 시간 동안 Shape의  Fade In/Out과 확대/축소 등을 정의할 수 있다.
/// \param startAlpha 애니메이션이 시작할 때 Shape의 알파값
///
/// \param endAlpha 애니메이션이 끝날 때 Shape의 알파값
///
/// \param startRadius 애니메이션이 시작할때 Shape의 스케일 값(px)
///
/// \param endRadius 애니메이션이 끝날 때 Shape의 스케일 값(px)
///
/// \param level 애니메이션이 적용될 레벨
///
- (void)addAnimationDataWithStartAlpha:(float)startAlpha endAlpha:(float)endAlpha startRadius:(float)startRadius endRadius:(float)endRadius level:(NSInteger)level;
/// 정의한 WaveAnimation Data
@property (nonatomic, readonly, copy) NSArray<WaveAnimationData *> * _Nonnull datas;
/// 애니메이션 지속 시간, 보간방법  지정
@property (nonatomic) struct AnimationInterpolation interpolation;
/// 애니메이션 재생 횟수.
@property (nonatomic) NSUInteger playCount;
/// 애니메이션 종료 시 애니메이터에 속한 객체들을 숨길지에 대한 여부.
/// true로 설정하면 애니메이션이 종료되면 객체들이 화면에서 자동으로 사라진다.
@property (nonatomic) BOOL hideAtStop;
@end


/// WaveText class
/// 지도상에 흐르는 글씨를 표현하기 위한 클래스. Poi는 한 점을 표시하기 위해 사용되고, WaveText는 지도상에 여러개의 점을 표시하기 위해 사용한다.
/// WaveText를 지도상에 추가하기 위해서는 먼저  KakaoMap에 LabelLayer를 추가한 뒤, 해당 Layer에 WaveText를 추가할 수 있다.
/// WaveText 객체는 사용자가 직접 생성할 수 없으며, WaveTextOptions Class를 이용하여 Layer에 추가하면 해당 Object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8WaveText")
@interface WaveText : NSObject <Label>
/// WaveText를 보여준다.
- (void)show;
/// WaveText를 숨긴다.
- (void)hide;
/// WaveText의 Style을 바꾼다.
/// LabelManager에 등록한 WaveTextStyle의 키를 이용하여 Style을 변경한다.
/// \param styleID 변경할 Style의 ID
///
/// \param enableTransition 스타일 변경시 transition효과 적용 여부.
///
- (void)changeStyleWithStyleID:(NSString * _Nonnull)styleID enableTransition:(BOOL)enableTransition;
/// WaveText의 text와 Data를 바꾼다.
/// WaveText의 text와 style을 바꿀 때 사용한다.
/// \param text 바꾸고자 하는 WaveText의 text
///
/// \param styleID 변경할 styleID.
///
- (void)changeTextAndStyleWithText:(NSString * _Nonnull)text styleID:(NSString * _Nonnull)styleID;
/// WaveText가 추가된 ViewBase
@property (nonatomic, readonly, strong) ViewBase * _Nullable view;
/// WaveText가 속한 LayerID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// WaveText의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull itemID;
/// WaveText가 현재 뷰에 보여지고 있는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// WaveText 생성 옵션 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK15WaveTextOptions")
@interface WaveTextOptions : NSObject
/// initializer
/// \param styleID 사용할 WaveTextStyle ID
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param styleID 사용할 WaveTextStyleID
///
/// \param waveTextID waveTextID 지정. 지정하지 않을 경우 자동으로 부여된다.
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID waveTextID:(NSString * _Nonnull)waveTextID OBJC_DESIGNATED_INITIALIZER;
/// WaveTextID. 지정하지 않을 경우 자동으로 부여된다.
@property (nonatomic, readonly, copy) NSString * _Nullable itemID;
/// WaveText의 styleID
@property (nonatomic, copy) NSString * _Nonnull styleID;
/// WaveText의 렌더링 우선순위
@property (nonatomic) NSUInteger rank;
/// WaveText의 text
@property (nonatomic, copy) NSString * _Nonnull text;
/// WaveText가 표시 될 points
@property (nonatomic, copy) NSArray<MapPoint *> * _Nullable points;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// WaveTextStyle을 지정하는 클래스.
/// WaveText를 레벨별로 다른 스타일로 표출하고 싶은 경우, PerLevelWaveTextStyle에 스타일 표출 레벨을 지정한 후 일종의 styleSet인 WaveTextStyle을 생성하여 사용한다.
/// LabelManager를 통해 Style을 등록한다. 등록된 style의 ID를 WaveText에 지정해주면, WaveText가 해당 스타일로 생성된다.
/// 혹은 등록된 styleID로 WaveText의 스타일을 변경할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK13WaveTextStyle")
@interface WaveTextStyle : NSObject
/// initializer
/// \param styleID WaveTextStyle의 ID
///
/// \param styles WaveTextStyle을 구성할 단위레벨별 PerLevelWaveTextStyle 배열
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID styles:(NSArray<PerLevelWaveTextStyle *> * _Nonnull)styles OBJC_DESIGNATED_INITIALIZER;
/// 추가된 PerLevelWaveTextStyle
@property (nonatomic, readonly, copy) NSArray<PerLevelWaveTextStyle *> * _Nonnull styles;
/// WaveTextStyle ID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
#ifndef KAKAOMAPSSDK_SWIFT_H
#define KAKAOMAPSSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreFoundation;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#import <KakaoMapsSDK/KakaoMapsSDK.h>

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="KakaoMapsSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

/// Poi 의 애니메이션 효과 지정 인터페이스
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK18PoiAnimationEffect_")
@protocol PoiAnimationEffect
/// 애니메이션 종료시 해당 poi를 숨길지 여부
@property (nonatomic) BOOL hideAtStop;
/// 애니메이션 종료시 해당 poi를 제거할지 여부
@property (nonatomic) BOOL removeAtStop;
@end


/// 키프레임으로 구성되는 애니메이션 효과
SWIFT_CLASS("_TtC12KakaoMapsSDK23KeyFrameAnimationEffect")
@interface KeyFrameAnimationEffect : NSObject <PoiAnimationEffect>
/// Initializer
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// 애니메이션 종료 시 애니메이터에 속한 객체들을 숨길지에 대한 여부.
/// true로 설정하면 애니메이션이 종료되면 객체들이 화면에서 자동으로 사라진다.
@property (nonatomic) BOOL hideAtStop;
/// 애니메이션 종료 시 애니메이터에 속한 객체들을 제거할지에 대한 여부.
/// true로 설정하면 애니메이션이 종료되면 객체들이 제거된다.
@property (nonatomic) BOOL removeAtStop;
/// 애니메이션 종료 후 초기상태로 원복 여부.
@property (nonatomic) BOOL resetToInitialState;
@end

@class AlphaAnimationKeyFrame;

/// AnimationEffect중 Animation 시간동안 지정된 Keyframe 에 따라 회전 변환을 수행하는 애니메이션 효과.
/// Poi에 적용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK20AlphaAnimationEffect")
@interface AlphaAnimationEffect : KeyFrameAnimationEffect
/// Initializer
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// 애니메이션 키프레임을 추가한다.
/// \param frame 추가할 키프레임.
///
- (void)addKeyframe:(AlphaAnimationKeyFrame * _Nonnull)frame;
@end


/// 키프레임 애니메이션을 구성하기 위한 keyframe
SWIFT_CLASS("_TtC12KakaoMapsSDK17AnimationKeyFrame")
@interface AnimationKeyFrame : NSObject
/// 애니메이션 지속 시간, 프레임 보간방법 지정
@property (nonatomic) struct AnimationInterpolation interpolation;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// AlphaAnimation 을 구성하기 위해 하나의 keyframe을 구성하기 위한 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK22AlphaAnimationKeyFrame")
@interface AlphaAnimationKeyFrame : AnimationKeyFrame
/// Initializer
/// \param alpha 투명도 값. 0.0~1.0
///
/// \param interpolation 프레임 시간, 보간 방법.
///
- (nonnull instancetype)initWithAlpha:(float)alpha interpolation:(struct AnimationInterpolation)interpolation OBJC_DESIGNATED_INITIALIZER;
/// 투명도 값. 0.0~1.0
@property (nonatomic) float alpha;
@end


@class NSString;

/// Animator protocol
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK8Animator_")
@protocol Animator
/// 애니메이션 시작
- (void)start;
/// 애니메이션 정지
- (void)stop;
/// 애니메이션 정지 콜백 지정
- (void)setStopCallback:(void (^ _Nullable)(id <Animator> _Nullable))callback;
/// 애니메이터 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull animatorID;
/// 애니메이션 시작 여부
@property (nonatomic, readonly) BOOL isStart;
@end

@class MapPoint;

/// 지도상의 사각형 범위를 나타내는 클래스. 서남쪽, 북동쪽 좌표를 각각 좌하단, 우상단으로 하는 정방형 범위를 의미한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8AreaRect")
@interface AreaRect : NSObject
/// Initializer
/// \param southWest 서남쪽 MapPoint
///
/// \param northEast 동북쪽 MapPoint
///
- (nonnull instancetype)initWithSouthWest:(MapPoint * _Nonnull)southWest northEast:(MapPoint * _Nonnull)northEast OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param points AreaRect의 범위에 포함되어야 할 MapPoint들
///
- (nonnull instancetype)initWithPoints:(NSArray<MapPoint *> * _Nonnull)points OBJC_DESIGNATED_INITIALIZER;
/// 두 AreaRect의 범위를 합친 AreaRect를 구한다.
/// \param rect1 첫 번째 AreaRect
///
/// \param rect2 두 번째 AreaRect
///
///
/// returns:
/// 두 AreaRect의 범위를 합친 새 AreaRect
+ (AreaRect * _Nonnull)union:(AreaRect * _Nonnull)rect1 :(AreaRect * _Nonnull)rect2 SWIFT_WARN_UNUSED_RESULT;
/// AreaRect의 중심점
///
/// returns:
/// AreaRect의 중심점
- (MapPoint * _Nonnull)center SWIFT_WARN_UNUSED_RESULT;
/// AreaRect의 서남쪽 포인트
@property (nonatomic, strong) MapPoint * _Nonnull southWest;
/// AreaRect의 동북쪽 포인트
@property (nonatomic, strong) MapPoint * _Nonnull northEast;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 카메라 위치를 지정하기 위한 클래스. 사용편의를 위해 카메라의 좌표가 아니라 카메라 시야범위의 중심점 위치 및 각도로 표현한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK14CameraPosition")
@interface CameraPosition : NSObject <NSCopying>
/// Initializer
/// \param target 카메라가 바라보는 지점의 MapPoint
///
/// \param height 카메라 높이(m)
///
/// \param rotation 카메라 회전각 (radian, 정북기준 시계방향)
///
/// \param tilt 카메라 기울임각 (radian, 수직방향 기준)
///
- (nonnull instancetype)initWithTarget:(MapPoint * _Nonnull)target height:(double)height rotation:(double)rotation tilt:(double)tilt OBJC_DESIGNATED_INITIALIZER;
/// 객체 복사를 위한 함수
/// \param zone zone
///
///
/// returns:
/// new copied object
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// 카메라가 바라보는 지점에 대한 MapPoint
@property (nonatomic, readonly, strong) MapPoint * _Nonnull targetPoint;
/// 카메라 높이(m)
@property (nonatomic, readonly) double height;
/// 카메라 회전각(radian, 정북기준 시계방향)
@property (nonatomic, readonly) double rotation;
/// 카메라 기울임각(radian, 수직방향 기준)
@property (nonatomic, readonly) double tilt;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 카메라의 위치 및 각도 변화량을 지정하는 클래스. 카메라가 이동할 위치나 각도를 지정하는 것이 아니라, 얼마나 이동할지(ex. 10도씩 시계방향으로 회전)를 지정하고자 할 때 사용한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK15CameraTransform")
@interface CameraTransform : NSObject <NSCopying>
/// Initializer
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Initializer.
/// \param deltaPos 카메라가 바라보는 위치 변화량
///
/// \param deltaHeight 카메라 높이 변화량
///
/// \param deltaRotation 카메라 회전각 변화량
///
/// \param deltaTilt 카메라 기울임각 변화량
///
- (nonnull instancetype)initWithDeltaPos:(struct CameraTransformDelta)deltaPos deltaHeight:(double)deltaHeight deltaRotation:(double)deltaRotation deltaTilt:(double)deltaTilt OBJC_DESIGNATED_INITIALIZER;
/// 객체 복사를 위한 함수.
/// \param zone zone
///
///
/// returns:
/// new copied object
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// 카메라가 바라보는 위치 변화량.
@property (nonatomic) struct CameraTransformDelta deltaPos;
/// 카메라 높이 변화량
@property (nonatomic) double deltaHeight;
/// 카메라의 회전각 변화량
@property (nonatomic) double deltaRotation;
/// 카메라 기울임각 변화량을 지정
@property (nonatomic) double deltaTilt;
@end

@class KakaoMap;

/// 카메라의 위치 및 각도를 조작하기 위한 클래스.
SWIFT_CLASS("_TtC12KakaoMapsSDK12CameraUpdate")
@interface CameraUpdate : NSObject
/// KakaoMap의 현재 카메라 위치 및 각도로 CameraUpdate를 생성한다.
/// \param mapView KakaoMap객체
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithMapView:(KakaoMap * _Nonnull)mapView SWIFT_WARN_UNUSED_RESULT;
/// CameraPosition으로 지정된 위치로 이동하는 CameraUpdate를 생성한다.
/// \param cameraPosition 카메라 위치 및 각도를 지정한 CameraPosition
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithCameraPosition:(CameraPosition * _Nonnull)cameraPosition SWIFT_WARN_UNUSED_RESULT;
/// AreaRect로 지정된 범위가 화면에 최대한 가득 차게 보이도록 이동하는 CameraUpdate를 생성한다.
/// \param area 화면에 보일 범위를 지정하는 AreaRect
///
/// \param levelLimit 레벨을 지정하면 카메라가 지정한 레벨까지만 확대되도록 제한함. -1 일 경우 제한하지 않음. 기본값 -1.
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithArea:(AreaRect * _Nonnull)area levelLimit:(NSInteger)levelLimit SWIFT_WARN_UNUSED_RESULT;
/// Target위치를 바라보도록 이동하는 CameraUpdate를 생성한다.
/// \param target 카메라가 바라볼 위치
///
/// \param mapView 이동할 카메라가 속한 KakaoMap
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithTarget:(MapPoint * _Nonnull)target mapView:(KakaoMap * _Nonnull)mapView SWIFT_WARN_UNUSED_RESULT;
/// 카메라 방향을 지정한 각도 및 기울기로 움직이는 CameraUpdate를 생성한다.
/// <ul>
///   <li>
///     retunrs: 생성된 CameraUpdate
///   </li>
/// </ul>
/// \param rotation 카메라 회전각
///
/// \param tilt 카메라 기울임각
///
+ (CameraUpdate * _Nonnull)makeWithRotation:(double)rotation tilt:(double)tilt mapView:(KakaoMap * _Nonnull)mapView SWIFT_WARN_UNUSED_RESULT;
/// target위치를 지정된 줌 레벨에서 바라보도록 이동하는 CameraUpdate를 생성한다.
/// \param target 카메라가 바라볼 위치
///
/// \param zoomLevel 줌 레벨
///
/// \param mapView 이동할 카메라가 속한 KakaoMap
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithTarget:(MapPoint * _Nonnull)target zoomLevel:(NSInteger)zoomLevel mapView:(KakaoMap * _Nonnull)mapView SWIFT_WARN_UNUSED_RESULT;
/// target위치를 지정된 줌 레벨에서 rotation만큼 회전 및 tilt만큼 기울어진 상태로 바라보도록 이동하는 CameraUpdate를 생성한다.
/// \param target 카메라가 바라볼 위치
///
/// \param zoomLevel 줌 레벨
///
/// \param rotation 카메라의 회전 각도
///
/// \param tilt 카메라의 기울어짐 각도
///
/// \param mapView 카메라가 속한 KakaoMap
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithTarget:(MapPoint * _Nonnull)target zoomLevel:(NSInteger)zoomLevel rotation:(double)rotation tilt:(double)tilt mapView:(KakaoMap * _Nonnull)mapView SWIFT_WARN_UNUSED_RESULT;
/// 지정된 줌 레벨로 이동하는 CameraUpdate를 생성한다.
/// <ul>
///   <li>
///     paramter zoomLevel: 줌 레벨
///   </li>
/// </ul>
/// \param mapView 카메라가 속한 KakaoMap
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithZoomLevel:(NSInteger)zoomLevel mapView:(KakaoMap * _Nonnull)mapView SWIFT_WARN_UNUSED_RESULT;
/// 카메라를 현재 위치로부터 transform으로 지정된 만큼 이동하는 CameraUpdate를 생성한다.
/// \param transform 카메라의 이동량
///
///
/// returns:
/// 생성된 CameraUpdate
+ (CameraUpdate * _Nonnull)makeWithTransform:(CameraTransform * _Nonnull)transform SWIFT_WARN_UNUSED_RESULT;
/// CameraUpdate의 종류.
@property (nonatomic, readonly) CameraUpdateType type;
/// 지정된 CameraPosition.  CameraPosition을 이용해 생성되었을 경우에만 유효하다.
@property (nonatomic, readonly, strong) CameraPosition * _Nullable cameraPosition;
/// 지정된 CameraTransform. CameraTransfrom을 이용해 생성되었을 경우에만 유효하다.
@property (nonatomic, readonly, strong) CameraTransform * _Nullable cameraTransform;
/// 지정된 AreaRect. AreaRect를 이용해 생성되었을 경우에만 유효하다.
@property (nonatomic, readonly, strong) AreaRect * _Nullable area;
/// 지정된 확대레벨 제한값
@property (nonatomic, readonly) NSInteger levelLimit;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PolygonStyleSet;
@class MapPolygonShapeOptions;
@class MapPolygonShape;
@class PolygonShapeOptions;
@class PolygonShape;
@class UIColor;
@protocol ShapeAnimationEffect;
@class ShapeAnimator;

/// 지도 뷰 전체를 어둡게 가리는 DimScreen 클래스.
/// KakaoMap에 종속되어 있으며 사용자가 별도로 생성할 수 없다. KakaoMap 인터페이스로 DimScreend의 On/Off가 가능하다.
/// screen에 원하는대로 Shape를 추가하여 특정 부분만 하이라이트 효과를 줄 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK9DimScreen")
@interface DimScreen : NSObject
/// PolygonStyleSet을 추가한다.
/// PolygonShape의 Polygon이 여러개인 경우, Polygon마다 다른 스타일을 설정할 수 있다. 같은 styleID로 추가하더라도 overwrite되지 않는다.
/// seealso:
/// PolygonStyleSet
/// \param styles 추가할 PolygonStyleSet
///
- (void)addPolygonStyleSet:(PolygonStyleSet * _Nonnull)styles;
/// DimScreen에 MapPolygonShape를 추가한다.
/// 중복ID로는 추가할 수 없으며, 기존에 같은 아이디의 Shape가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOption 생성할 MapPolygonShape 옵션
///
/// \param callback MapPolygonShape객체가 생성이 완료됐을 때 호출할 콜백함수(optional)
///
///
/// returns:
/// 생성된 MapPolygonShape 객체
- (MapPolygonShape * _Nullable)addHighlightMapPolygonShape:(MapPolygonShapeOptions * _Nonnull)shapeOption callback:(void (^ _Nullable)(MapPolygonShape * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// DimScreen에 다수의 MapPolygonShape를 추가한다.
/// 중복ID로는 추가할 수 없으며, 기존에 같은 아이디의 Shape가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 MapPolygonShape 옵션 배열
///
/// \param callback MapPolygonShape객체가 모두 생성이 완료됐을 때 호출할 콜백함수(optional)
///
///
/// returns:
/// 생성된 MapPolygonShape 객체 배열
- (NSArray<MapPolygonShape *> * _Nullable)addHighlightMapPolygonShapes:(NSArray<MapPolygonShapeOptions *> * _Nonnull)shapeOptions callback:(void (^ _Nullable)(NSArray<MapPolygonShape *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 DimScreen에 속한 MapPolygonShape를 가져온다.
/// \param shapeID 가져올 MapPolygonShape ID
///
///
/// returns:
/// ID에 해당하는 MapPolygonShape 객체, 없을경우 nil.
- (MapPolygonShape * _Nullable)getHighlightMapPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID SWIFT_WARN_UNUSED_RESULT;
/// 현재 DimScreen에 속한 다수의 MapPolygonShape를 가져온다.
/// \param shapeIDs 가져올 MapPolygonShape ID 배열
///
///
/// returns:
/// ID에 해당하는 MapPolygonShape 객체 배열, 없을경우 nil.
- (NSArray<MapPolygonShape *> * _Nullable)getHighlightMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 DimScreen에 속한 모든 MapPolygonShape를 가져온다.
///
/// returns:
/// 현재 DimScreen에 추가된 MapPolygonShape 배열
- (NSArray<MapPolygonShape *> * _Nullable)getAllHighlightMapPolygonShapes SWIFT_WARN_UNUSED_RESULT;
/// 현재 DimScreen에서 특정 MapPolygonShape를 지운다.
/// \param shapeID DimScreen에서 제거할 MapPolygonShape Id
///
/// \param callback DimScreen에서 해당 Shape제거가 완료되었을 때, 호출할 콜백함수(optional)
///
- (void)removeHighlightMapPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID callback:(void (^ _Nullable)(void))callback;
/// 현재 DimScreen에서 다수의 MapPolygonShape를 지운다.
/// \param shapeID DimScreen에서 제거할 MapPolygonShape Id 배열
///
/// \param callback DimScreen에서 id에 해당하는 모든 shape제거가 완료되었을 때, 호출할 콜백함수(optional)
///
- (void)removeHighlightMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 DimScreen에 속한 특정 MapPolygonShape를 보여준다.
/// \param shapeIDs 보여줄 MapPolygonShape ID 배열
///
- (void)showHighlightMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 DimScreen에 속한 특정 MapPolygonShape를 숨긴다.
/// \param shapeIDs 숨길 MapPolygonShape ID 배열
///
- (void)hideHighlightMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// DimScreen에 PolygonShape를 추가한다.
/// 이미 추가한 ID로 추가할 수 없으며, 이 경우 기존의 객체가 리턴된다.
/// \param shaepOption DimScreen에 추가할 PolygonShapeOptions
///
/// \param callback DimScreen에 객체 추가가 완료되었을 때, 호출할 콜백함수(optional)
///
///
/// returns:
/// 추가된 PolygonShape 객체
- (PolygonShape * _Nullable)addHighlightPolygonShape:(PolygonShapeOptions * _Nonnull)shapeOption callback:(void (^ _Nullable)(PolygonShape * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// DimScreen에 여러개의 PolygonShape를 추가한다.
/// 이미 추가한 ID로 추가할 수 없으며, 이 경우 기존의 객체가 리턴된다.
/// \param shaepOptions DimScreen에 추가할 PolygonShapeOptions 배열
///
/// \param callback DimScreen에 객체 추가가 모두 완료되었을 때, 호출할 콜백함수(optional)
///
///
/// returns:
/// 추가된 PolygonShape 객체 배열
- (NSArray<PolygonShape *> * _Nullable)addHighlightPolygonShapes:(NSArray<PolygonShapeOptions *> * _Nonnull)shapeOptions callback:(void (^ _Nullable)(NSArray<PolygonShape *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// DimScreen에 추가된 PolygonShape를 가져온다.
/// \param shapeID 가져올 PolygonShape ID
///
///
/// returns:
/// shapeID에 해당하는 Shape객체. 없을경우 nil 리턴
- (PolygonShape * _Nullable)getHighlightPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID SWIFT_WARN_UNUSED_RESULT;
/// DimScreen에 추가된 다수의 PolygonShape를 가져온다.
/// \param shapeIDs 가져올 PolygonShape ID 배열
///
///
/// returns:
/// shapeID에 해당하는 PolygonShape객체 배열. 없을경우 nil 리턴
- (NSArray<PolygonShape *> * _Nullable)getHighlightPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs SWIFT_WARN_UNUSED_RESULT;
/// DimScreen에 추가된 모든 PolygonShape를 가져온다.
///
/// returns:
/// DimScreen에 추가된 모든 PolygonShape 객체 배열
- (NSArray<PolygonShape *> * _Nullable)getAllHighlightPolygonShapes SWIFT_WARN_UNUSED_RESULT;
/// DimScreen에 추가된 특정 PolygonShape를 지운다.
/// \param shapeID 지울 PolygonShape ID
///
/// \param callback 제거가 완료되었을 때, 호출할 callback 함수(optional)
///
- (void)removeHighlightPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID callback:(void (^ _Nullable)(void))callback;
/// DimScreen에 추가된 다수의 PolygonShape를 지운다.
/// \param shapeIDs 지울 PolygonShape ID 배열
///
/// \param callback 제거가 완료되었을 때, 호출할 callback 함수(optional)
///
- (void)removeHighlightPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 DimScreen에 속한 특정 PolygonShape를 보여준다.
/// \param shapeIDs 보여줄 PolygonShape ID 배열
///
- (void)showHighlightPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 DimScreen에 속한 특정 PolygonShape를 숨긴다.
/// \param shapeIDs 숨길 PolygonShape ID 배열
///
- (void)hideHighlightPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// DimScreen에 추가된 모든 Shape를 지운다.
- (void)clearAllHighlightShapes;
/// DimScreen의 활성화 상태를 지정한다.
/// <code>true</code>설정 시 DimScreen이 활성화 되어 표시된다. <code>false</code> 설정시 DimScreen이 비활성화된다.
@property (nonatomic) BOOL isEnabled;
/// DimScreen의 컬러값
/// 값을 설정하면 DimScreen의 컬러가 업데이트된다.
@property (nonatomic, strong) UIColor * _Nonnull color;
/// DimScreen이 덮을 레이어 범위
/// seealso:
/// DimScreenCover
@property (nonatomic) DimScreenCover cover;
/// ShapeAnimator를 추가한다.
/// ShapeAnimator 객체는 사용자가 직접 생성할 수 없으며, Manager를 통해서만 생성이 가능하다. 이미 존재하는 AnimatorID로는 overwrite되지 않는다.
/// seealso:
/// AnimationInterpolation
/// seealso:
/// WaveTextAnimation
/// \param animatorID ShapeAnimator ID
///
/// \param effect 레벨별 애니메이션 효과 지정
///
///
/// returns:
/// 생성된 Animator 객체
- (ShapeAnimator * _Nullable)addShapeAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID effect:(id <ShapeAnimationEffect> _Nonnull)effect SWIFT_WARN_UNUSED_RESULT;
/// 추가한 ShapeAnimator 객체를 제거한다.
/// \param animatorID 제거할 animatorID
///
- (void)removeShapeAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID;
/// 추가되어있는 모든 ShapeAnimaotr를 제거한다.
- (void)clearAllShapeAnimators;
/// 추가한 ShapeAnimator 객체를 가져온다.
/// \param animatorID 가져올 AnimatorID
///
///
/// returns:
/// animatorID에 해당하는 ShapeAnimator 객체. 존재하지 않을 경우 nil 리턴
- (ShapeAnimator * _Nullable)getShapeAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// InfoWindowAnimation을 생성할 때 Animation Effect 종류를 정의하는 프로토콜
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK25InfoWindowAnimationEffect_")
@protocol InfoWindowAnimationEffect
/// 애니메이션의 지속시간, 반복 회수, 프레임간의 보간 방법등을 지정
@property (nonatomic) struct AnimationInterpolation interpolation;
/// 애니메이션 종료시 대상 객체를 숨길지 여부를 지정.
@property (nonatomic) BOOL hideAtStop;
/// 애니메이션 재생 횟수.
@property (nonatomic) NSUInteger playCount;
@end


/// AnimationEffect중 Animation 시간동안 특정 pixel값만큼 위에서 아래로 떨어지는 애니메이션 효과 클래스.
/// Poi와 InfoWindow Animator에 적용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK19DropAnimationEffect")
@interface DropAnimationEffect : NSObject <InfoWindowAnimationEffect, PoiAnimationEffect>
/// Initializer
/// \param pixelHeight Drop Animation시 떨어지는 pixel Height
///
- (nonnull instancetype)initWithPixelHeight:(float)pixelHeight OBJC_DESIGNATED_INITIALIZER;
/// Drop Animation시 떨어지는 pixel height
@property (nonatomic, readonly) float pixelHeight;
/// 애니메이션 지속 시간, 반복 횟수 등 세부사항 지정
@property (nonatomic) struct AnimationInterpolation interpolation;
/// 애니메이션 종료 시 애니메이터에 속한 객체들을 숨길지에 대한 여부.
/// true로 설정하면 애니메이션이 종료되면 객체들이 화면에서 자동으로 사라진다.
@property (nonatomic) BOOL hideAtStop;
/// 애니메이션 종료 시 애니메이터에 속한 객체들을 제거할지에 대한 여부.
/// true로 설정하면 애니메이션이 종료되면 객체들이 제거된다.
@property (nonatomic) BOOL removeAtStop;
/// 애니메이션 재생 횟수.
@property (nonatomic) NSUInteger playCount;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// GuiComponent의 베이스 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK16GuiComponentBase")
@interface GuiComponentBase : NSObject
/// initialzier
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Component의 childComponent를 가져온다.
/// \param componentId 가져오고자 하는 componentID
///
///
/// returns:
/// ID에 해당하는 child component. 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// Component의 padding(pixel)
/// 컴포넌트 기준으로 상하좌우로 여백값을 줄 수 있으며, 컴포넌트 본래 사이즈 + padding값이 해당 컴포넌트의 최종 크기가 된다.
/// padding값을 별도로 지정하지 않는 경우, 컴포넌트의 최종 크기는 본래 사이즈가 된다.
@property (nonatomic) struct GuiPadding padding;
/// component의 origin
/// component 자체의 원점 위치를 조절한다. root component에만 적용된다.
@property (nonatomic) struct GuiAlignment origin;
/// component의 align
/// Gui내에서 컴포넌트가 차지하는 최종 공간에서 컴포넌트의 정렬 위치.
@property (nonatomic) struct GuiAlignment align;
/// GuiComponent의 타입
@property (nonatomic, readonly) GuiComponentType type;
/// GuiComponent의 Id
@property (nonatomic, readonly, copy) NSString * _Nonnull componentId;
@end

@class UIImage;

/// gif처럼 여러장의 이미지로 구성된 애니메이션을 보여주는 component 클래스
/// 애니메이션을 구성하는 이미지는 모두 같은 크기, 같은 포맷이어야 한다.
/// 하나의 child component를 가질 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK16GuiAnimatedImage")
@interface GuiAnimatedImage : GuiComponentBase
/// initializer
/// \param componentId Component ID
///
- (nonnull instancetype)init:(NSString * _Nonnull)componentId OBJC_DESIGNATED_INITIALIZER;
/// 애니메이션 이미지들을 추가한다. 각 이미지들이 animation의 keyframe image가 된다.
/// \param images 애니메이션 이미지
///
- (void)addImages:(NSArray<UIImage *> * _Nonnull)images;
/// GuiAnimatedImage의 child Component를 가져온다.
/// child component가 GuiLayout component로 구성되어 있어도 componentId로 가져올 수 있다.
/// \param componentId 가져올 component의 Id
///
///
/// returns:
/// componentID에 해당하는 component. 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// AnimatedImage 컴포넌트의 애니메이션을 실행시킨다.
- (void)start;
/// AnimatedImage 컴포넌트의 애니메이션을 멈춘다.
- (void)stop;
/// AnimatedImage 컴포넌트의 애니메이션을 재시작시킨다.
- (void)resume;
/// AnimatedImage 컴포넌트의 애니메이션을 일시정지한다..
- (void)pause;
/// 애니메이션의 이미지들을 가져온다.
@property (nonatomic, readonly, copy) NSArray<UIImage *> * _Nonnull images;
/// 애니메이션 이미지 사이즈를 지정한다. 지정하지 않을경우 원본 크기를 사용한다.
@property (nonatomic) struct GuiSize imageSize;
/// 애니메이션 1회 재생 시간을 지정한다.
@property (nonatomic) NSUInteger duration;
/// 애니메이션 반복 횟수를 지정한다.
/// 애니메이션 재생을 시작하면 지정한 회수만큼 반복 재생된다.
/// 너무 긴 시간동안 애니메이션을 재생하면 배터리 사용량이 크게 늘어날 수 있다.
/// 무한반복 혹은 짧은 반복횟수를 여러번 반복하는것은 권장하지 않는다.
@property (nonatomic) NSUInteger playCount;
/// GuiAnimatedImage Component에 추가되는 child component
/// GuiLayout 컴포넌트를 넣어서 여러개의 Component를 구성할 수도 있다.
@property (nonatomic, strong) GuiComponentBase * _Nullable child;
@end

@protocol GuiEventDelegate;

/// Gui 베이스 클래스
/// Gui는 특성상 culling 이 되지 않으므로, 지도상의 특정 위치에 그려져서 화면에 그려지는 영역 밖에 있더라도 실제로 그려진다.
/// 그러므로 다수의 Gui를 추가하게 되면 엔진 부하를 야기할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK7GuiBase")
@interface GuiBase : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Gui를 그린다.
- (void)show;
/// Gui를 숨긴다.
- (void)hide;
/// Gui가 그려지고 있던 경우 갱신하여 새로 그린다. 한번 Gui를 그린 상태에서 속성을 변경하고자 하는 경우, 이 함수를 호출해야 반영된다.
- (void)updateGui;
/// childComponent를 가져온다.
/// \param componentId 가져올 컴포넌트의 Id
///
///
/// returns:
/// ComponentId에 해당하는 GuiComponent. 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// Gui의 name
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// GuiEventDelegate를 지정한다.
@property (nonatomic, strong) id <GuiEventDelegate> _Nullable delegate;
/// Gui의 렌더링 우선순위를 지정한다. 값을 세팅하면, 따로 updateGui() 호출 없이도 바로 반영된다.
/// zOrder는 같은 Gui타입끼리만 유효하며, zOrder 값이 클수록 더 위에 그려진다.
/// 즉, zOrder가 0인 Gui는 zOrder가 1인 Gui보다 아래에 그려진다.
@property (nonatomic) NSInteger zOrder;
/// Gui 표출 여부
@property (nonatomic, readonly) BOOL isShow;
@end


/// Gui에 Image를 그리기 위한 component 클래스.
/// 이미지는 크기를 지정하지 않으면 원본 크기로 그려지고 지정하면 지정된 크기대로 그려진다(배경이미지로 사용되는 경우는 component의 크기로 그려짐).
/// 하나의 child component를 가질 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8GuiImage")
@interface GuiImage : GuiComponentBase
/// initializer
/// \param componentId componentID
///
- (nonnull instancetype)init:(NSString * _Nonnull)componentId OBJC_DESIGNATED_INITIALIZER;
/// GuiImage의 child Component를 가져온다.
/// child component가 GuiLayout component로 구성되어 있어도 componentId로 가져올 수 있다.
/// \param componentId 가져올 component의 Id
///
///
/// returns:
/// componentID에 해당하는 component. 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// 사용될 이미지
@property (nonatomic, strong) UIImage * _Nullable image;
/// 사용될 이미지의 사이즈. 크기를 지정하지 않으면 원본 사이즈로 사용된다.
@property (nonatomic) struct GuiSize imageSize;
/// imageStretch를 지정하면 리사이즈될 때 나인패치 이미지 형태로 리사이즈 되어 그려진다.
@property (nonatomic) struct GuiEdgeInsets imageStretch;
/// GuiImage Component에 추가되는 child component
/// GuiLayout 컴포넌트를 넣어서 여러개의 Component를 구성할 수도 있다.
@property (nonatomic, strong) GuiComponentBase * _Nullable child;
@end


/// 버튼 Component 클래스. 사용자로부터 탭 이벤트를 받을 수 있다.
/// 한 개의 child component를 가질 수 있다. Child component로 GuiLayout을 사용하면 여러 개의 child를 추가할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK9GuiButton")
@interface GuiButton : GuiImage
/// initailizer
/// \param componentId Component ID
///
- (nonnull instancetype)init:(NSString * _Nonnull)componentId OBJC_DESIGNATED_INITIALIZER;
/// button pressed Image 지정
@property (nonatomic, strong) UIImage * _Nullable pressedImage;
/// button pressed Image Size 지정. 지정하지 않을경우 원본사이즈 유지
@property (nonatomic) struct GuiSize pressedImageSize;
@end


@class NSMutableArray;

/// 여러개의 child를 가질 수 있는 GuiComponentGroup 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK17GuiComponentGroup")
@interface GuiComponentGroup : GuiComponentBase
/// 현재 컴포넌트에 child component를 추가한다.
/// \param component 추가하고자 하는 child component
///
- (void)addChild:(GuiComponentBase * _Nonnull)component;
/// 현재 컴포넌트의 child component를 가져온다.
/// \param componentId 가져오고자 하는 child component Id
///
///
/// returns:
/// componentId에 해당하는 child component, 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// 현재 컴포넌트의 child component를 지운다..
/// \param componentId 지우고자 하는 child component Id
///
- (void)removeChild:(NSString * _Nonnull)componentId;
/// 현재 컴포넌트가 childComponent를 가지고 있는지 체크한다.
///
/// returns:
/// 현재 컴포넌트가 child를 가지고있을경우 true, 아니면 false
@property (nonatomic, readonly) BOOL hasChildren;
/// 현재 컴포넌트가 갖는 child component Array
///
/// returns:
/// child component 배열
@property (nonatomic, readonly, strong) NSMutableArray * _Nonnull children;
@end


/// Gui에서 발생하는 이벤트에 대한 delegate.
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK16GuiEventDelegate_")
@protocol GuiEventDelegate
@optional
/// Component 탭 이벤트
/// \param gui 탭된 Gui
///
/// \param componentName 탭된 GuiComponent의 이름
///
- (void)guiDidTapped:(GuiBase * _Nonnull)gui componentName:(NSString * _Nonnull)componentName;
/// Animation 재생상태 변경시 발생
/// \param gui 재생상태가 변경된 Gui
///
/// \param componentName Component의 이름
///
/// \param state animation state
///
- (void)guiAnimationStateDidChanged:(GuiBase * _Nonnull)gui componentName:(NSString * _Nonnull)componentName state:(AnimationState)state;
/// Gui 이동 정지 이벤트
/// \param gui Gui
///
/// \param position 위치.
///
- (void)guiMoveDidStopped:(GuiBase * _Nonnull)gui position:(MapPoint * _Nonnull)position;
@end



/// 여러개의 child component를 가지는 component 클래스.
/// child component를 가로, 혹은 세로로 배치할 수 있으며, 배치 방향에 따라 추가한 순서대로 그려진다.
/// GuiLayout의 크기는 배치된 총 child component의 전체 크기가 된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK9GuiLayout")
@interface GuiLayout : GuiComponentGroup
/// initializer
/// \param componentId component ID
///
- (nonnull instancetype)init:(NSString * _Nonnull)componentId OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param componentId componentID
///
/// \param arrangement child component 배치 방향
///
- (nonnull instancetype)init:(NSString * _Nonnull)componentId arrangement:(LayoutArrangement)arrangement OBJC_DESIGNATED_INITIALIZER;
/// layout에 추가한 child component의 배치 방향
@property (nonatomic) LayoutArrangement arrangement;
/// layout의 child component 구분선 표시 여부
@property (nonatomic) BOOL showSplitLine;
/// layout의 child component 구분선 색깔
@property (nonatomic, strong) UIColor * _Nonnull splitLineColor;
/// layout의 child component 구분선 두께
@property (nonatomic) NSInteger splitLineWidth;
/// layout의 배경 색깔
@property (nonatomic, strong) UIColor * _Nonnull bgColor;
@end

@class InfoWindowAnimator;
@class SpriteGuiLayer;
@class InfoWindowLayer;

/// 사용자 Gui를 사용하고 관리하기 위한 클래스
/// SpriteGui, InfoWIndow를 추가 및 제거 등 관리할 수 있다. InfoWindow의 경우, InfoWindow에 적용할 Animator를 추가할 수 있다.
/// ViewBase에 종속적이므로 각 ViewBase가 삭제된 뒤에도 사용하지 않도록 주의하여야 한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10GuiManager")
@interface GuiManager : NSObject
/// InfoWindowAnimator를 추가한다.
/// InfoWindowAnimator 객체는 사용자가 직접 생성할 수 없으며, GuiManager를 통해서만 생성이 가능하다. 이미 존재하는 AnimatorID로는 overwrite되지 않는다.
/// seealso:
/// InfoWindowAnimator
/// seealso:
/// AnimationInterpolation
/// \param animatorID InfoWindowAnimator ID
///
/// \param effect 애니메이션 효과 지정
///
///
/// returns:
/// 생성된 Animator 객체
- (InfoWindowAnimator * _Nullable)addInfoWindowAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID effect:(id <InfoWindowAnimationEffect> _Nonnull)effect SWIFT_WARN_UNUSED_RESULT;
/// 추가한 InfoWindowAnimator를 제거한다.
/// \param animatorID 제거할 animatorID
///
- (void)removeInfoWindowAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID;
/// 추가되어있는 모든 InfoWindowAnimator를 제거한다.
- (void)clearAllInfoWindowAnimators;
/// 추가한 InfoWindowAnimator 객체를 가져온다.
/// \param animatorID 가져올 animatorID
///
///
/// returns:
/// animatorID에 해당하는 InfoWindowAnimator 객체. 존재하지 않을 경우 nil 리턴.
- (InfoWindowAnimator * _Nullable)getInfoWindowAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID SWIFT_WARN_UNUSED_RESULT;
/// SpriteGui Layer. SpriteGui를 추가하기 위해서는 해당 레이어에 Gui를 추가한다.
@property (nonatomic, readonly, strong) SpriteGuiLayer * _Nonnull spriteGuiLayer;
/// InfoWindow Layer. InfoWindow를 추가하기 위해서는 해당 레이어에 InfoWindow를 추가한다.
@property (nonatomic, readonly, strong) InfoWindowLayer * _Nonnull infoWindowLayer;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class TextStyle;

/// Gui에 글자를 그리는 component class
SWIFT_CLASS("_TtC12KakaoMapsSDK7GuiText")
@interface GuiText : GuiComponentBase
/// initializer
/// \param componentId GuiText의 componentId
///
- (nonnull instancetype)init:(NSString * _Nonnull)componentId OBJC_DESIGNATED_INITIALIZER;
/// GuiText에 텍스트를 추가한다.
/// 여러 라인으로 추가할 수 있고, 각 라인별로 스타일을 지정할 수 있다.
/// \param text 추가하고자하는 텍스트
///
/// \param style 추가하고자하는 텍스트에 적용할 스타일
///
- (void)addTextWithText:(NSString * _Nonnull)text style:(TextStyle * _Nonnull)style;
/// Gui에 추가된 텍스트를 가져온다.
/// 여러 라인으로 추가했을 경우, 추가한 인덱스로 텍스트를 가져올 수 있다.
/// \param index 추가한 텍스트의 인덱스
///
///
/// returns:
/// 인덱스에 해당하는 텍스트
- (NSString * _Nonnull)textWithIndex:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Gui에 추가된 텍스트 스타일을 가져온다.
/// 여러 라인으로 추가했을 경우, 추가한 인덱스로 텍스트 스타일을 가져올 수 있다.
/// \param index 추가한 텍스트의 인덱스
///
///
/// returns:
/// 추가한 텍스트 인덱스의 스타일
- (TextStyle * _Nonnull)textStyleWithIndex:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Gui Text Component에 추가된 텍스트 라인 수를 가져온다
///
/// returns:
/// 텍스트 라인 수
- (NSInteger)textCount SWIFT_WARN_UNUSED_RESULT;
/// text의 특정 라인을 업데이트한다. 변경사항은 Gui의 updateGui를 호출해야 유효하다.
/// \param index 텍스트 라인 index
///
/// \param text 업데이트 할 내용
///
/// \param style 업데이트할 텍스트 스타일
///
- (void)updateTextWithIndex:(NSInteger)index text:(NSString * _Nonnull)text style:(TextStyle * _Nullable)style;
@end


/// InfoWindow class
/// 인포윈도우는 body, tail 두 부분으로 구성된다. body는 GuiImage로 구성되어 있으며, 이 GuiImage Component에 존재하는 기본 layout에 원하는 child 컴포넌트를 구성할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10InfoWindow")
@interface InfoWindow : GuiBase
/// initializer
/// \param name InfoWindow 이름
///
- (nonnull instancetype)init:(NSString * _Nonnull)name OBJC_DESIGNATED_INITIALIZER;
/// InfoWindow의 body
/// GuiImage Component이며, body에 child component를 추가할 수 있다.
@property (nonatomic, strong) GuiImage * _Nullable body;
/// InfoWindow의 tail
@property (nonatomic, strong) GuiImage * _Nullable tail;
/// InfoWindow의 body offset
/// tail의 원점(origin) 으로부터 body의 원점이 떨어진 위치.
/// InfoWindow의 tail은 원점이 position으로 지정된 위치에 놓이고 body는 body의 원점이 tail 원점으로부터 offset만큼 떨어진 위치에 놓이게 된다.
@property (nonatomic) CGPoint bodyOffset;
/// InfoWindow의 position offset
/// tail의 원점(origin) 이 position 으로 부터 떨어진 위치.
/// InfoWindow의 tail은 원점이 position으로 지정된 위치에서 position offset 만큼 떨어진 위치에 놓이고 body는 body의 원점이 tail 원점으로부터 offset만큼 떨어진 위치에 놓이게 된다.
@property (nonatomic) CGPoint positionOffset;
/// InfoWindow가 표시 될 위치. 값을 셋팅하면, 별도의 updateGui() 호출 없이도 바로 반영된다.
@property (nonatomic, strong) MapPoint * _Nullable position;
/// InfoWindow를 화면에 표시하고, InfoWinodw가 표시되는 영역으로 자동으로 이동한다.
/// \param callback 카메라 이동이 끝났을 때, 호출할 callback(optional)
///
- (void)showWithAutoMoveWithCallback:(void (^ _Nullable)(void))callback;
/// infoWindow의 child Component를 가져온다.
/// \param componentId Child component ID
///
///
/// returns:
/// componentId에 해당하는 child Component. 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// InfoWindow를 특정 위치로 지정한 시간만큼 이동시킨다.
/// \param position 이동시킬 위치
///
/// \param duration 이동시킬 시간
///
- (void)moveAt:(MapPoint * _Nonnull)position duration:(NSUInteger)duration;
- (MapPoint * _Nullable)rawPosition SWIFT_WARN_UNUSED_RESULT;
@end



/// InfoWindow에 애니메이션 효과를 주기 위한 Animator 클래스.
/// Animator를 생성해서 효과를 주고자 하는 InfoWindow를 Animator에 넣어서 animator를 동작시키는 방식이다.
/// Animator는 사용자가 직접 생성할 수 없으며, GuiManager를 통해서만 생성이 가능하다.
SWIFT_CLASS("_TtC12KakaoMapsSDK18InfoWindowAnimator")
@interface InfoWindowAnimator : NSObject <Animator>
/// Animator를 동작시킨다.
/// Animator에 추가된 InfoWindow가 없으면 start함수는 동작하지 않는다. start를 호출한 이후에는 Animator에   InfoWindow를 추가하거나 지울 수 없다. 추가하고자 하는 경우, stop을 호출하고 추가해야한다.
/// start 호출 이후 애니메이션이 끝나면 Animator에 추가된 InfoWindow는 비워지므로, 다시 start를 호출하려면 InfoWindow를 추가해야한다.
/// InfoWindow Interface에 있는 move등의 동작은 Animator가 start되면 멈춘다.
- (void)start;
/// Animator 의 종료 콜백을 지정한다. Start 된 애니메이션이 종료되거나 stop이 호출되면 지정한 callback 이 호출된다. nil 로 지정해서 기존에 지정했던 callback을 제거할 수 있다. 기본값 nil.
/// \param callback Animator에 추가할 종료 콜백.
///
- (void)setStopCallback:(void (^ _Nullable)(id <Animator> _Nullable))callback;
/// Animator의 동작을 멈춘다.
/// stop이 호출되면 다시 애니메이션이 끝난것으로 간주되어 Animator에 속한 InfoWindow는 모두 비워지므로, Animator를 다시 동작시키리면 다시 InfoWindow를 Animator에 추가해야한다.
- (void)stop;
/// Animator에 InfoWindow를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 InfoWindow를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 InfoWindow를 추가할 수 없다.
/// \param infoWindow Animator에 추가할 InfoWindow
///
- (void)addInfoWindow:(InfoWindow * _Nonnull)infoWindow;
/// Animator에 여러개의 InfoWindow를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 InfoWindow를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 InfoWindow를 추가할 수 없다.
/// \param infoWindows Animator에 추가할 InfoWindow 배열
///
- (void)addInfoWindows:(NSArray<InfoWindow *> * _Nonnull)infoWindows;
/// Animator에 추가한 InfoWindow를 모두 지운다.
/// start() 호출 이후에는 동작하지 않는다.
- (void)clearAllInfoWindows;
/// 추가한 animatorID
@property (nonatomic, readonly, copy) NSString * _Nonnull animatorID;
/// Animator 시작 여부
@property (nonatomic, readonly) BOOL isStart;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// InfoWindowLayer - InfoWindow 들을 담는 layer
SWIFT_CLASS("_TtC12KakaoMapsSDK15InfoWindowLayer")
@interface InfoWindowLayer : NSObject
/// InfoWindowLayer의 visible 상태.
/// layer의 on/off 상태를 나타내며, layer에 속한 객체의 show/hide는 별도로 동작시켜야한다.
/// 즉, layer의 visible이 true여도 layer에 속한 객체의 show를 호출해야 보이고, visible이 false라면 layer에 속한 객체는 화면에 표시되지 않는다.
@property (nonatomic) BOOL visible;
/// 추가한 모든 InfoWindow를 지운다.
- (void)clear;
/// InfoWindow를 현재 레이어에 추가한다.
/// InfoWindow를 레이어에 추가하기 전까지는 화면에 표시되지 않는다.
/// 같은 이름으로 중복으로 추가할 수 없다.
/// \param gui 추가할 InfoWindow 객체
///
- (void)addInfoWindow:(InfoWindow * _Nonnull)gui;
/// InfoWindow를 현재 레이어에서 제거한다.
/// \param gui 제거할 InfoWindow 객체
///
- (void)removeInfoWindow:(InfoWindow * _Nonnull)gui;
/// guiName을 Key로 갖는 InfoWindow를 현재 레이어에서 제거한다.
/// \param guiName 제거할 InfoWindow의 guiName
///
- (void)removeInfoWindowWithGuiName:(NSString * _Nonnull)guiName;
/// InfoWindowLayer에 추가되어있는 InfoWindow를 guiName을 Key로 가져온다.
/// \param guiName 가져올 InfoWindow의 guiName
///
///
/// returns:
/// 이름에 해당하는 InfoWindow. 없을 경우 nil.
- (InfoWindow * _Nullable)getInfoWindowWithGuiName:(NSString * _Nonnull)guiName SWIFT_WARN_UNUSED_RESULT;
/// InfoWindowLayer에 특정 guiName을 가진 InfoWindow가 존재하는지 체크한다.
/// \param guiName 추가되어있는지 확인할 InfoWindow guiName
///
///
/// returns:
/// 존재 여부. 이미 추가되어있는 guiName의 경우 true, 아니면 false를 리턴한다.
- (BOOL)isInfoWindowExistWithGuiName:(NSString * _Nonnull)guiName SWIFT_WARN_UNUSED_RESULT;
/// InfoWindowLayer에 추가한 모든 InfoWindow를 가져온다.
///
/// returns:
/// 추가된 모든 InfoWindow 객체 배열
- (NSArray<InfoWindow *> * _Nullable)getAllInfoWindows SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// API의 뷰 클래스들의 베이스 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK8ViewBase")
@interface ViewBase : NSObject <NativeEventDelegate>
/// 뷰의 이름을 가져온다.
///
/// returns:
/// 뷰의 이름
- (NSString * _Nonnull)viewName SWIFT_WARN_UNUSED_RESULT;
/// 뷰의 위치 및 크기.
/// viewRect를 지정하면, view가 위치 및 크기가 업데이트된다.
@property (nonatomic) CGRect viewRect;
/// 생성한 View의 타입을 가져온다.
@property (nonatomic, readonly) MapType mapType;
/// 제스쳐 동작 활성화 상태를 지정한다.
/// \param type 제스쳐 동작 종류.
///
/// \param enable 활성화 상태
///
- (void)setGestureEnableWithType:(GestureType)gestureType enable:(BOOL)enable;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class LabelManager;
@class ShapeManager;
@class TrackingManager;
@class RouteManager;
@protocol KakaoMapEventDelegate;

/// 지도 뷰를 위한 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK8KakaoMap")
@interface KakaoMap : ViewBase
/// 여백을 지정한다.
/// 여백을 지정하면, 지도 중심점 계산이나 애니메이션 기능과 같이 뷰 영역 계산이 필요한 부분에 반영된다.
/// 예를들어, 좌측 여백을 지정하면 화면의 중심점에 대한 위치 계산시 (좌측여백 / 2)만큼 우측으로 밀린 지점에 대한 위치로 계산한다.
/// \param insets 상하좌우 여백
///
- (void)setMargins:(UIEdgeInsets)insets;
/// 여백을 0으로 초기화한다.
- (void)resetMargins;
/// 지도 Poi 표시 여부를 설정한다.
/// \param enable true인경우, 지도판의 Poi가 표시되고, false인 경우 지도판의 Poi가 표시되지 않는다.
///
- (void)setPoiEnabled:(BOOL)enable;
/// 지도 기본 Poi(API를 통해 추가된 POI가 아닌 POI) 들의 클릭가능 여부
@property (nonatomic) BOOL poiClickable;
/// 최소 줌 레벨.
/// KakaoMap의 최소 줌 레벨을 가져온다.
@property (nonatomic, readonly) NSInteger minLevel;
/// 최대 줌 레벨.
/// KakaoMap의 최대 줌 레벨을 가져온다.
@property (nonatomic, readonly) NSInteger maxLevel;
/// 최소 카메라 레벨.
/// 카메라의 최소 줌 레벨을 가져온다. 해당 레벨보다 작은 레벨로는 카메라 줌레벨을 축소시킬 수 없다.
@property (nonatomic, readonly) NSInteger cameraMinLevel;
/// 현재 줌 레벨.
/// 현재 KakaoMap의 줌 레벨을 가져온다.
@property (nonatomic, readonly) NSInteger zoomLevel;
/// 현재 포커스 상태
/// KakaoMap의 현재 Focus 여부를 가져온다.
@property (nonatomic, readonly) BOOL isFocused;
/// 현재 지도의 상하좌우 여백 값.
/// KakaoMap의 현재 상하좌우 여백값을 가져온다.
@property (nonatomic, readonly) UIEdgeInsets margins;
/// 카메라를 cameraUpdate로 정의된 대로 즉시 이동한다.
/// 진행중이던 카메라 이동 애니메이션은 모두 종료된다.
/// seealso:
/// CameraUpdate
/// \param cameraUpdate 카메라 이동을 정의한 CameraUpdate.
///
/// \param callback 이동 완료시 호출될 callback
///
- (void)moveCamera:(CameraUpdate * _Nonnull)cameraUpdate callback:(void (^ _Nullable)(void))callback;
/// 카메라를 cameraUpdate로 정의된 대로 animationOption 에 따라 이동한다.
/// seealso:
/// CameraUpdate
/// seealso:
/// CameraAnimationOptions
/// \param cameraUpdate 카메라 이동을 정의한 CameraUpdate.
///
/// \param options 이동 애니메이션 옵션.
///
/// \param callback 이동 애니메이션 종료시 호출될 callback
///
- (void)animateCameraWithCameraUpdate:(CameraUpdate * _Nonnull)cameraUpdate options:(struct CameraAnimationOptions)options callback:(void (^ _Nullable)(void))callback;
/// 카메라의 orientation(회전, 기울임)을 0으로 초기화시킨다.
/// \param options 애니메이션 옵션.
///
/// \param callback 카메라 이동 애니메이션 종료시 호출될 callback
///
- (void)resetCameraOrientation:(struct CameraAnimationOptions)options callback:(void (^ _Nullable)(void))callback;
/// CameraAnimationOptions에 autoElevation 을 true로 지정한 애니메이션 진행시, autoElevation하는 동안 정북방향으로 카메라를 회전할지 여부를 지정한다.
/// \param enable true면 autoElevation시 정북으로 회전한다.
///
- (void)setBackToNorthDuringAutoElevation:(BOOL)enable;
/// level에 해당하는 카메라 높이를 가져온다.
/// \param level 지도 레벨
///
///
/// returns:
/// 카메라 높이(m)
- (double)heightAtLevel:(NSInteger)level SWIFT_WARN_UNUSED_RESULT;
/// 현재 KakaoMap 영역의 viewPoint에 해당하는 실제 위치를 가져온다.
/// \param viewPoint KakaoMap 뷰 범위 내의 임의의 한 지점 (x, y)
///
///
/// returns:
/// viewPoint에 해당하는 실제 위치를 나타내는 MapPoint. viewPoint가 KakaoMap의 범위 밖일 경우 잘못된 MapPoint가 return 된다.
- (MapPoint * _Nonnull)getPosition:(CGPoint)viewPoint SWIFT_WARN_UNUSED_RESULT;
/// 카메라 애니메이션 활성화 상태를 지정한다.
/// <code>true</code>로 설정하면 animateCamera 호출 시 애니메이션이 활성화 된다. <code>false</code>로 설정하면 animateCamera()를 호출해도 애니메이션 없이 즉시 이동된다.
@property (nonatomic) BOOL cameraAnimationEnabled;
/// 현재 카메라 높이(m)를 가져온다.
@property (nonatomic, readonly) double cameraHeight;
/// 현재 카메라의 회전각(radian, 정북기준 시계방향).
@property (nonatomic, readonly) double rotationAngle;
/// 현재 카메라의 기울임각(radian, 수직 방향 기준).
@property (nonatomic, readonly) double tiltAngle;
/// 지도상 표시를 지원하는 언어코드 목록을 가져온다.
///
/// returns:
/// 지원하는 언어코드의 배열
- (NSArray<NSString *> * _Nonnull)getSupportedLanguages SWIFT_WARN_UNUSED_RESULT;
/// 지도상에 표시될 언어를 설정한다.
/// 지원되는 언어만 선택가능하다. 미지원언어를 지정할 경우 무시된다.
/// \param langCode 언어 코드.(ex. ko, en, ja, zh)
///
- (void)setLanguage:(NSString * _Nonnull)langCode;
/// 건물 높이 scale을 지정한다. scale값에 따라 그려지는 건물의 높이가 조절된다.
/// \param scale 0 ~ 1 사이의 건물 높이 scale
///
@property (nonatomic) float buildingScale;
/// 지도상의 poi size를 조절한다. icon 크기도 함께 변한다.
/// default값은 Regular
@property (nonatomic) PoiScaleType poiScale;
/// 지도 위에 overlay를 표시한다.
/// \param overlay 지도위에 표시하고자 하는 overlay 이름
///
- (void)showOverlay:(NSString * _Nonnull)overlay;
/// 지도 위에 overlay를 숨긴다.
/// \param overlay 숨길 overlay 이름
///
- (void)hideOverlay:(NSString * _Nonnull)overlay;
/// 축척을 표시한다.
- (void)showScaleBar;
/// 축척을 숨긴다.
- (void)hideScaleBar;
/// 축척의 alignment와 offset을 지정한다.
/// seealso:
/// GuiAlignment
/// \param origin 축척의 origin
///
/// \param position 축척 origin으로부터의 offset(pt)
///
- (void)setScaleBarPositionWithOrigin:(struct GuiAlignment)origin position:(CGPoint)position;
/// 축척의 자동숨김 기능 활성화를 지정한다.
/// 활성화되면 축척이 보여진 뒤 일정시간 후에 자동으로 숨겨진다.
/// \param autoDisappear 자동숨김 활성화.
///
- (void)setScaleBarAutoDisappear:(BOOL)autoDisappear;
/// 축척의 FadeInOutOption을 지정한다.
/// \param option FadeInOut 옵션.
///
- (void)setScaleBarFadeInOutOption:(struct FadeInOutOptions)option;
/// 나침반을 표시한다.
- (void)showCompass;
/// 나침반을 숨긴다.
- (void)hideCompass;
/// 나침반의 alignment를 지정한다.
/// seealso:
/// GuiAlignment
/// \param origin 나침반의 alignment
///
/// \param position 나침반 alignmnet로부터의 offset(pt)
///
- (void)setCompassPositionWithOrigin:(struct GuiAlignment)origin position:(CGPoint)position;
/// 로고의 위치를 지정한다.
/// 로고는 SpriteGUI 와 같은 방식으로 화면상의 특정위치에 고정적으로 표시되므로, 다른 GUI 와 겹치는 현상을 피하기 위해 로고의 위치를 이동시키는 데 사용한다.
/// 위치 지정방식은 SpriteGUI와 동일하다.
/// \param origin 로고의 alignment
///
/// \param position alignment 기준점으로부터의 offset
///
- (void)setLogoPositionWithOrigin:(struct GuiAlignment)origin position:(CGPoint)position;
/// 제스쳐의 동작 기준점을 뷰의 가운데로 고정시킨다. 줌/회전/틸트 관련 제스쳐에만 적용된다(그 외 제스쳐는 무시함).
/// \param forGesture 제스쳐 종류
///
- (void)lockReferencePointForGesture:(GestureType)gesture;
/// 제스쳐의 동작 기준점을 뷰의 가운데 고정을 해제한다.
/// \param forGesture 제스쳐 종류
///
- (void)unlockReferencePointForGesture:(GestureType)gesture;
/// 뷰를 다시 그린다.
- (void)refresh;
/// 지도 뷰의 DimmingScreen 객체
@property (nonatomic, readonly, strong) DimScreen * _Nonnull dimScreen;
/// LabelManager
///
/// returns:
/// 이 KakaoMap의 LabelManager
- (LabelManager * _Nonnull)getLabelManager SWIFT_WARN_UNUSED_RESULT;
/// ShapeManager
///
/// returns:
/// 이 KakaoMap의 ShapeManager
- (ShapeManager * _Nonnull)getShapeManager SWIFT_WARN_UNUSED_RESULT;
/// TrackingManager
///
/// returns:
/// 이 KakaoMap의 TrackingManager
- (TrackingManager * _Nonnull)getTrackingManager SWIFT_WARN_UNUSED_RESULT;
/// RouteManager
///
/// returns:
/// 이 KakaoMap의 RouteManager
- (RouteManager * _Nonnull)getRouteManager SWIFT_WARN_UNUSED_RESULT;
/// GuiManager
///
/// returns:
/// 이 KakaoMap의 GuiManager
- (GuiManager * _Nonnull)getGuiManager SWIFT_WARN_UNUSED_RESULT;
/// 이벤트 delegate를 지정한다.
/// \param delegate event delegate
///
@property (nonatomic, strong) id <KakaoMapEventDelegate> _Nullable eventDelegate;
/// 뷰의 활성화 상태
/// <code>true</code>인 경우 렌더링이 실행되며,<code>false</code>인 경우 렌더링을 하지 않는다.
@property (nonatomic) BOOL isEnabled;
@end


@interface KakaoMap (SWIFT_EXTENSION(KakaoMapsSDK))
/// ViewInfo를 변경한다.
/// 지정된 이름의 Viewinfo를 서버로부터 가져와서 현재 뷰에 교체하여 적용한다.
/// Note: 지도용 ViewInfo만 가능.
/// \param appName 변경할 app 이름
///
/// \param viewInfoName 변경할 viewInfo 이름
///
- (void)changeViewInfoWithAppName:(NSString * _Nonnull)appName viewInfoName:(NSString * _Nonnull)viewInfoName;
@end



/// KakaoMap의 이벤트 Delegate
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK21KakaoMapEventDelegate_")
@protocol KakaoMapEventDelegate
@optional
/// 포커스가 변경되었을 때 호출.
/// \param kakaoMap KakaoMap
///
/// \param focus 변경된 포커스 상태
///
- (void)kakaoMapFocusDidChangedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap focus:(BOOL)focus;
/// KakaoMap의 크기가 변경되었을 때 호출.
/// \param kakaoMap KakaoMap
///
- (void)kakaoMapDidResized:(KakaoMap * _Nonnull)kakaoMap;
/// KakaoMap의 Margin이 변경되었을 때 호출.
/// \param kakaoMap KakaoMap
///
- (void)kakaoMapMarginDidUpdated:(KakaoMap * _Nonnull)kakaoMap;
/// KakaoMap의 영역이 탭되었을 때 호출.
/// \param kakaoMap 탭된 kakaoMap 객체
///
/// \param point 탭 위치
///
- (void)kakaoMapDidTappedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap point:(CGPoint)point;
/// Terrain Layer가 탭되면 호출.
/// \param kakaoMap 탭된 kakaoMap 객체
///
/// \param position 탭된 지점의 위치
///
- (void)terrainDidTappedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap position:(MapPoint * _Nonnull)position;
/// Terrain Layer가 길게 눌리면 발생.
/// \param kakaoMap 눌린 kakaoMap 객체
///
/// \param position 눌린 지점의 위치
///
- (void)terrainDidLongPressedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap position:(MapPoint * _Nonnull)position;
/// Poi가 탭되면 호출.
/// \param kakaoMap Poi가 속한 KakaoMap
///
/// \param layerID Poi가 속한 layerID
///
/// \param poiID Poi의 ID
///
/// \param position Poi의 위치
///
- (void)poiDidTappedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap layerID:(NSString * _Nonnull)layerID poiID:(NSString * _Nonnull)poiID position:(MapPoint * _Nonnull)position;
/// 나침반이 탭 되면 호출.
/// \param kakaoMap 나침반이 속한 KakaoMap
///
- (void)compassDidTappedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap;
/// 카메라 이동이 시작될 때 호출.
/// \param kakaoMap KakaoMap
///
/// \param by 지도 이동을 유발한 원인(사용자 제스쳐, API 호출).
///
- (void)cameraWillMoveWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap by:(MoveBy)by;
/// 지도 이동이 멈췄을 때 호출.
/// \param kakaoMap KakaoMap
///
/// \param by 지도 이동을 유발한 원인(사용자 제스쳐, API 호출).
///
- (void)cameraDidStoppedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap by:(MoveBy)by;
/// 지도의 viewInfo변경이 성공했을 때 호출
/// \param kakaoMap KakaoMap
///
/// \param viewInfoName 변경한 viewInfoName
///
- (void)onViewInfoChangedWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap viewInfoName:(NSString * _Nonnull)viewInfoName;
/// 지도의 viewInfo변경이 실패했을 때 호출
/// \param kakaoMap KakaoMap
///
/// \param viewInfoName 변경한 viewInfoName
///
- (void)onViewInfoChangeFailureWithKakaoMap:(KakaoMap * _Nonnull)kakaoMap viewInfoName:(NSString * _Nonnull)viewInfoName;
@end



/// Label protocol
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK5Label_")
@protocol Label
/// 라벨 표출
- (void)show;
/// 라벨 숨김
- (void)hide;
/// 라벨 스타일 변경
- (void)changeStyleWithStyleID:(NSString * _Nonnull)styleID enableTransition:(BOOL)enableTransition;
/// 라벨이 속한 레이어 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// 라벨 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull itemID;
/// 라벨 표출여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
@end

@class PoiOptions;
@class Poi;
@class WaveTextOptions;
@class WaveText;

/// Label 종류(Poi, WaveText)를 관리하는 단위인 LabelLayer 클래스.
/// Poi, WaveText를 추가/삭제 등 관리할 수 있으며, 일종의 그룹처럼 관리가 가능하다.
/// 사용자가 직접 객체를 생성할 수 없으며, LabelManager를 통해 객체를 간접적으로 생성할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10LabelLayer")
@interface LabelLayer : NSObject
/// LabelLayer의 visible 상태.
/// layer의 on/off 상태를 나타내며, layer에 속한 객체의 show/hide는 별도로 동작시켜야한다.
/// 즉, layer의 visible이 true여도 layer에 속한 객체의 show를 호출해야 보이고, visible이 false라면 layer에 속한 객체는 화면에 표시되지 않는다.
@property (nonatomic) BOOL visible;
/// 현재 Layer에 있는 모든 item을 일괄적으로 지운다.
/// 하나의 layer안에 Poi와 WaveText가 함께 추가가 가능하므로, 이 경우 clear를 호출게 되면 모든 Poi와 WaveText가 지워진다.
- (void)clearAllItems;
/// 현재 Layer에 있는  Exit Transition 속성을 가진 Poi를 지운다.
- (void)clearAllExitTransitionPois;
/// 현재 레이어의 clickable 속성을 지정한다.
/// \param clickable 클릭 설정 여부. 해당 레이어에 속한 모든 Poi에 적용된다.
///
- (void)setClickable:(BOOL)clickable;
/// 현재 Layer에 Poi를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// \param option 생성할 Poi의 옵션
///
/// \param at 생성할 Poi의 위치
///
/// \param callback Poi 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 Poi 객체
- (Poi * _Nullable)addPoiWithOption:(PoiOptions * _Nonnull)option at:(MapPoint * _Nonnull)position callback:(void (^ _Nullable)(Poi * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 같은 옵션을 가지는 다수의 Poi를 추가한다.
/// 같은 옵션을 가지지만 위치만 다른 Poi를 생성할 경우 사용한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// \param option 생성할 Poi의 옵션
///
/// \param at 생성할 Poi의 위치 배열
///
/// \param callback Poi 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 Poi 객체
- (NSArray<Poi *> * _Nullable)addPoisWithOption:(PoiOptions * _Nonnull)option at:(NSArray<MapPoint *> * _Nonnull)positions callback:(void (^ _Nullable)(NSArray<Poi *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 다른 옵션을 가지는 다수의 Poi를 추가한다.
/// Poi별로 다른 옵션을 가지는 경우 사용한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// warning:
/// 여러개의 옵션으로 여러개의 poi를 생성하는 경우, option과 position의 pair가 일치해야한다. 즉, position하나당 option 하나의 짝을 맞추어야 한다.
/// \param options 생성할 Poi의 옵션 배열
///
/// \param at Poi가 표시될 위치. option과 pair를 맞추어야 한다.
///
/// \param callback Poi 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 Poi 객체배열
- (NSArray<Poi *> * _Nullable)addPoisWithOptions:(NSArray<PoiOptions *> * _Nonnull)options at:(NSArray<MapPoint *> * _Nonnull)positions callback:(void (^ _Nullable)(NSArray<Poi *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정 Poi를 지운다.
/// \param poiID Layer에서 제거할 Poi Id
///
/// \param callback Poi 제거가 완료되었을 때, 호출할 callback(optional)
///
- (void)removePoiWithPoiID:(NSString * _Nonnull)poiID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 여러개의 Poi를 지운다.
/// \param poiIDs Layer에서 제거할 Poi Id 배열
///
/// \param callback Poi 제거가 완료되었을 때, 호출할 callback(optional)
///
- (void)removePoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속해있는 Poi를 모두 보여준다.
- (void)showAllPois;
/// 현재 Layer에 속해있는 Poi를 모두 숨긴다.
- (void)hideAllPois;
/// 현재 Layer에 속한 특정 Poi를 보여준다.
/// \param poiIDs 보여줄 Poi ID 배열
///
- (void)showPoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs;
/// 현재 Layer에 속한 특정 Poi를 숨긴다.
/// \param poiIDs 숨길 Poi ID 배열
///
- (void)hidePoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs;
/// 현재 Layer에 속한 Poi를 가져온다.
/// \param poiID 가져올 Poi ID
///
///
/// returns:
/// ID에 해당하는 Poi 객체, 없을경우 ni.
- (Poi * _Nullable)getPoiWithPoiID:(NSString * _Nonnull)poiID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 Poi들을 가져온다.
/// \param poiIDs 가져올 Poi ID
///
///
/// returns:
/// ID에 해당하는 Poi 객체 배열. 없을경우 ni.
- (NSArray<Poi *> * _Nullable)getPoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 Poi를 가져온다.
///
/// returns:
/// 레이어에 속한 모든 Poi.
- (NSArray<Poi *> * _Nullable)getAllPois SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 WaveText를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// \param options 생성할 WaveText의 option
///
/// \param callback WaveText 제거가 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성한 waveText 객체
- (WaveText * _Nullable)addWaveText:(WaveTextOptions * _Nonnull)options callback:(void (^ _Nullable)(WaveText * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 특정 WaveText를 지운다.
/// \param waveTextID 지우고자 하는 WaveText의 ID
///
/// \param callback WaveText 제거가 완료되었을 때, 호출할 callback(optional)
///
- (void)removeWaveTextWithWaveTextID:(NSString * _Nonnull)waveTextID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 여러개의 특정 WaveText를 지운다.
/// \param waveTextIDs 지우고자 하는 WaveText의 ID 배열
///
/// \param callback WaveText 제거가 모두 완료되었을 때, 호출할 callback(optional)
///
- (void)removeWaveTextsWithWaveTextIDs:(NSArray<NSString *> * _Nonnull)waveTextIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 모든 WaveText를 표시한다.
- (void)showAllWaveTexts;
/// 현재 Layer에 속한 모든 WaveText를 숨긴다.
- (void)hideAllWaveTexts;
/// 현재 Layer에 속한 특정 WaveText를 보여준다.
/// \param waveTextIDs 보여줄 WaveText ID 배열
///
- (void)showWaveTextsWithWaveTextIDs:(NSArray<NSString *> * _Nonnull)waveTextIDs;
/// 현재 Layer에 속한 특정 WaveText를 숨긴다.
/// \param waveTextIDs 숨길 WaveText ID 배열
///
- (void)hideWaveTextsWithWaveTextIDs:(NSArray<NSString *> * _Nonnull)waveTextIDs;
/// 현재 Layer에 속한 WaveText를 가져온다.
/// \param waveTextID 가져올 WaveText ID
///
///
/// returns:
/// ID에 해당하는 WaveText객체, 없을경우 ni.
- (WaveText * _Nullable)getWaveTextWithWaveTextID:(NSString * _Nonnull)waveTextID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 여러개의 WaveText를 가져온다.
/// \param waveTextIDs 가져올 WaveText ID배열
///
///
/// returns:
/// ID에 해당하는 WaveText객체 배열, 없을경우 ni.
- (NSArray<WaveText *> * _Nullable)getWaveTextsWithWaveTextIDs:(NSArray<NSString *> * _Nonnull)waveTextIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 waveText를 가져온다.
- (NSArray<WaveText *> * _Nullable)getAllWaveTexts SWIFT_WARN_UNUSED_RESULT;
/// layer의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// layer에 속한 Poi가 경쟁하는 방법을 지정한다.
/// Layer의 우선순위(zOrder)에 따라 Poi끼리 겹쳐졌을 때, Poi가 표시될 정책을 지정한다.
/// seealso:
/// CompetitionType
@property (nonatomic, readonly) CompetitionType competitionType;
/// Poi가 경쟁할 때, 경쟁을 하는 단위를 선택한다.
/// seealso:
/// CompetitionUnit
@property (nonatomic, readonly) CompetitionUnit competitionUnit;
/// competitionType이 same일 경우, 경쟁을 하는 기준이 된다.
/// seealso:
/// OrderingType
@property (nonatomic, readonly) OrderingType orderType;
/// layer의 렌더링 우선순위
/// zOrder는 같은 LabelLayer타입끼리만 유효하며, 기본적으로 zOrder 값이 클수록 더 높은 우선권을 가진다.
@property (nonatomic) NSInteger zOrder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// LabelLayer 생성 옵션
SWIFT_CLASS("_TtC12KakaoMapsSDK17LabelLayerOptions")
@interface LabelLayerOptions : NSObject
/// initializer
/// \param layerID layer ID
///
/// \param competitionType 다른 poi와 경쟁하는 방법
///
/// \param competitionUnit 경쟁을 하는 단위
///
/// \param orderType competitionType이 same일 때, 경쟁하는 기준
///
/// \param zOrder layer의 zOrder. 값이 클수록 위에 그려진다.
///
- (nonnull instancetype)initWithLayerID:(NSString * _Nonnull)layerID competitionType:(CompetitionType)competitionType competitionUnit:(CompetitionUnit)competitionUnit orderType:(OrderingType)orderType zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// layerID
@property (nonatomic, copy) NSString * _Nonnull layerID;
/// 다른 poi와 경쟁하는 방법을 지정한다. 해당 레이어에 속한 poi는 모두 해당 방법으로 경쟁한다.
@property (nonatomic) CompetitionType competitionType;
/// 경쟁할 때 단위를 지정한다. 해당 레이어에 속한 poi는 모두 해당 방법으로 경쟁한다.
@property (nonatomic) CompetitionUnit competitionUnit;
/// competitionType이 same일 때 경쟁하는 기준을 설정한다.
@property (nonatomic) OrderingType orderType;
/// layer의 zOrder
/// zOrder는 같은 LabelLayer타입끼리만 유효하며, zOrder 값이 클수록 더 위에 그려진다
/// 즉, zOrder가 0인 LabelLayer는에 속한 Label은 zOrder가 1인 LabelLayer에 속한 Label보다 아래에 그려진다.
@property (nonatomic) NSInteger zOrder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PoiStyle;
@class WaveTextStyle;
@class LodLabelLayerOptions;
@class LodLabelLayer;
@class PoiAnimator;

/// KakaoMap에서 사용자 Poi, LodPoi, WaveText등 Label종류를 사용하고 관리하기 위한 클래스
/// 각 Object의 레이어 관리, 스타일추가와 Poi의 Animator 추가등이 가능하다.
/// KakaoMap에 종속적이므로 KakaoMap이 삭제된 뒤에도 사용하지 않도록 주의하여야 한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12LabelManager")
@interface LabelManager : NSObject
/// PoiStyle을 추가한다.
/// 레벨별로 다른 스타일을 갖는 PoiStyle을 추가한다. 이미 추가된 styleID와 중복된 styleID로 추가할 수 없으며, overwrite되지 않는다.
/// seealso:
/// PoiStyle
/// \param style 추가할 PoiStyle
///
- (void)addPoiStyle:(PoiStyle * _Nonnull)style;
/// PoiStyle을 삭제한다.
/// \param styleID 삭제할 PoiStyle ID
///
- (void)removePoiStyle:(NSString * _Nonnull)styleID;
/// WaveTextStyle을 추가한다.
/// 레벨별로 다른 스타일을 갖는 WaveTextStyle을 추가한다. 이미 추가된 styleID와 중복된 styleID로 추가할 수 없으며, overwrite되지 않는다.
/// WaveText에는 TextStyle중 charSpace, lineSpace, aspectRatio 는 적용되지 않는다.
/// seealso:
/// WaveTextStyle
/// \param style 추가할 WaveTextStyle
///
- (void)addWaveTextStyle:(WaveTextStyle * _Nonnull)style;
/// LabelLayer를 추가한다.
/// LabelLayer는 LOD가 적용되지 않는 Label인 Poi와 WaveText를 관리하는 단위. 사용자가 LabelLayer 객체를 직접 생성할 수 없으며, LabelManager를 통해 LayerOptions으로 생성할 수 있다. 생성한 레이어에 Poi 및 WaveText를 추가&삭제할 수 있다.
/// LabelLayer, LodLabelLayer를 통합으로 관리하므로 중복 ID로 추가할 수 없으며, overwrite되지 않고 기존 Layer가 유지된다.
/// seealso:
/// LabelLayer
/// seealso:
/// LabelLayerOptions
/// \param option 추가할 LabelLayer Option
///
- (LabelLayer * _Nullable)addLabelLayerWithOption:(LabelLayerOptions * _Nonnull)option SWIFT_WARN_UNUSED_RESULT;
/// LabelLayer를 삭제한다.
/// LayerID로 Layer를 삭제한다. Layer 삭제와 동시에 Layer에 추가되어있던 Poi,WaveText도 모두 삭제된다.
/// \param layerID 삭제할 LabelLayer의 ID
///
- (void)removeLabelLayerWithLayerID:(NSString * _Nonnull)layerID;
/// LabelLayer를 모두 삭제한다.
/// KakaoMap에 등록된 모든 LabelLayer를 삭제한다. Layer 삭제와 동시에 Layer에 추가되어있던 Poi,WaveText도 모두 삭제된다.
- (void)clearAllLabelLayers;
/// 추가한 LabelLayer를 가져온다.
/// \param layerID 가져올 LabelLayer ID
///
///
/// returns:
/// LabelLayer
- (LabelLayer * _Nullable)getLabelLayerWithLayerID:(NSString * _Nonnull)layerID SWIFT_WARN_UNUSED_RESULT;
/// LodLabelLayer를 추가한다.
/// LodLabelLayer는 LOD가 적용되는 LodPoi를 관리하는 단위이다. 사용자가 LodLabelLayer 객체를 직접 생성할 수 없으며, LabelManager를 통해 LodLayerOptions으로 생성할 수 있다. 생성한 레이어에 LodPoi를 추가&삭제할 수 있다.
/// LabelLayer, LodLabelLayer를 통합으로 관리하므로 중복 ID로 추가할 수 없으며, overwrite되지 않고 기존 Layer가 유지된다.
/// seealso:
/// LodLabelLayer
/// seealso:
/// LodLabelLayerOptions
/// \param option 추가할 LodLabelLayerOptions
///
///
/// returns:
/// 추가된 LodLabelLayer.
- (LodLabelLayer * _Nullable)addLodLabelLayerWithOption:(LodLabelLayerOptions * _Nonnull)option SWIFT_WARN_UNUSED_RESULT;
/// LodLabelLayer를 삭제한다.
/// LayerID로 LodLabelLayer를 삭제한다. Layer 삭제와 동시에 Layer에 추가되어있던 LodPoi도 모두 삭제된다.
/// \param layerID 삭제할 LodLabelLayer의 ID
///
- (void)removeLodLabelLayerWithLayerID:(NSString * _Nonnull)layerID;
/// LodLabelLayer를 모두 삭제한다.
/// KakaoMap에 등록된 모든 LodLabelLayer를 삭제한다. Layer 삭제와 동시에 Layer에 추가되어있던 LodPoi도 모두 삭제된다.
- (void)clearAllLodLabelLayers;
/// 추가한 LodLabelLayer를 가져온다.
/// \param layerID 가져올 LodLabelLayer ID
///
///
/// returns:
/// LodLabelLayer
- (LodLabelLayer * _Nullable)getLodLabelLayerWithLayerID:(NSString * _Nonnull)layerID SWIFT_WARN_UNUSED_RESULT;
/// PoiAnimator를 추가한다.
/// PoiAnimator 객체는 사용자가 직접 생성할 수 없으며, Manager를 통해서만 생성 가능하다.
/// seealso:
/// PoiAnimator
/// seealso:
/// AnimationInterpolation
/// \param animatorID 추가할 animatorID
///
/// \param effect 애니메이션 효과 지정
///
///
/// returns:
/// 생성된 PoiAnimator
- (PoiAnimator * _Nullable)addPoiAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID effect:(id <PoiAnimationEffect> _Nonnull)effect SWIFT_WARN_UNUSED_RESULT;
/// 추가한 PoiAnimator를 삭제한다.
/// \param animatorID 삭제할 PoiAnimator ID
///
- (void)removePoiAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID;
/// 추가한 모든 PoiAnimator를 제거한다.
- (void)clearAllPoiAnimators;
/// 추가한 Animator를 가져온다.
/// \param animatorID animatorID
///
///
/// returns:
/// PoiAnimator
- (PoiAnimator * _Nullable)getPoiAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class LodPoi;

/// 대량의 Poi( ex. 즐겨찾기 )를 관리하는 단위인 LodLabelLayer 클래스
/// 대량의 Poi를 추가할땐 LabelLayer가 아닌 LodLabelLayer를 이용하여 경쟁처리를 하면 빠르게 Poi를 보여줄 수 있다.
/// LodLabelLayer에 추가된 LodPoi는 일반 Poi객체와는 다르게 이동/회전에 대한 인터페이스가 존재하지 않는다.
/// 사용자가 직접 객체를 생성할 수 없으며, LabelManager를 통해 객체를 간접적으로 생성할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK13LodLabelLayer")
@interface LodLabelLayer : NSObject
/// LodLabelLayer의 visible 상태.
/// layer의 on/off 상태를 나타내며, layer에 속한 객체의 show/hide는 별도로 동작시켜야한다.
/// 즉, layer의 visible이 true여도 layer에 속한 객체의 show를 호출해야 보이고, visible이 false라면 layer에 속한 객체는 화면에 표시되지 않는다.
@property (nonatomic) BOOL visible;
/// 현재 Layer에 있는 모든 item을 일괄적으로 지운다.
- (void)clearAllItems;
/// 현재 Layer에 있는  Exit Transition 속성을 가진 LodPoi를 지운다.
- (void)clearAllExitTransitionLodPois;
/// 현재 레이어의 clickable 속성을 지정한다.
/// \param clickable 클릭 설정 여부. 해당 레이어에 속한 모든 Poi에 적용된다.
///
- (void)setClickable:(BOOL)clickable;
/// 현재 Layer에 LodPoi를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// \param option 생성할 LodPoi의 옵션
///
/// \param at 생성할 LodPoi의 위치
///
/// \param callback LodPoi 생성이 완료되고나면 호출할 callback(optional)
///
///
/// returns:
/// 생성된 LodPoi 객체
- (LodPoi * _Nullable)addLodPoiWithOption:(PoiOptions * _Nonnull)option at:(MapPoint * _Nonnull)position callback:(void (^ _Nullable)(LodPoi * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 같은 옵션을 가지는 다수의 LodPoi를 추가한다.
/// 같은 옵션을 가지지만 위치만 다른 LodPoi를 생성할 경우 사용한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// \param option 생성할 LodPoi의 옵션
///
/// \param at 생성할 LodPoi의 위치 배열
///
/// \param callback LodPoi 생성이 모두 완료되고나면 호출할 callback (optional)
///
///
/// returns:
/// 생성된 LodPoi 객체
- (NSArray<LodPoi *> * _Nullable)addLodPoisWithOption:(PoiOptions * _Nonnull)option at:(NSArray<MapPoint *> * _Nonnull)positions callback:(void (^ _Nullable)(NSArray<LodPoi *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 다른 옵션을 가지는 다수의 LodPoi를 추가한다.
/// LodPoi별로 다른 옵션을 가지는 경우 사용한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할경우 기존 객체를 리턴한다.
/// warning:
/// 여러개의 옵션으로 여러개의 poi를 생성하는 경우, option과 position의 pair가 일치해야한다. 즉, position하나당 option 하나의 짝을 맞추어야 한다.
/// \param options 생성할 LodPoi의 옵션 배열
///
/// \param at 생성할 LodPoi 위치
///
/// \param callback LodPoi 생성이 모두 완료되고나면 호출할 callback (optional)
///
///
/// returns:
/// 생성된 LodPoi 객체배열
- (NSArray<LodPoi *> * _Nullable)addLodPoisWithOptions:(NSArray<PoiOptions *> * _Nonnull)options at:(NSArray<MapPoint *> * _Nonnull)positions callback:(void (^ _Nullable)(NSArray<LodPoi *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정  LodPoi를 지운다.
/// \param poiID LodLabelLayer에서 제거할 LodPoi Id
///
/// \param callback 해당 LodPoi 제거가 완료되면 호출할 callback(optional)
///
- (void)removeLodPoiWithPoiID:(NSString * _Nonnull)poiID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 여러개의 LodPoi를 지운다.
/// \param poiIDs LodLabelLayer에서 제거할 LodPoi Id 배열
///
/// \param callback 해당 LodPoi 제거가 모두 완료되면 호출할 callback(optional)
///
- (void)removeLodPoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속해있는 LodPoi를 모두 보여준다.
- (void)showAllLodPois;
/// 현재 Layer에 속해있는 모든 LodPoi를 숨긴다.
- (void)hideAllLodPois;
/// 현재 Layer에 속한 특정 LodPoi를 보여준다.
/// \param poiIDs 보여줄 LodPoi ID 배열
///
- (void)showLodPoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs;
/// 현재 Layer에 속한 특정 LodPoi를 숨긴다.
/// \param poiIDs 숨길 LodPoi ID 배열
///
- (void)hideLodPoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs;
/// 현재 Layer에 속한 LodPoi를 가져온다.
/// \param poiID 가져올 LodPoi ID
///
///
/// returns:
/// ID에 해당하는 LodPoi 객체, 없을경우 ni.
- (LodPoi * _Nullable)getLodPoiWithPoiID:(NSString * _Nonnull)poiID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 여러개의 LodPoi를 가져온다.
/// \param poiIDs 가져올 LodPoi ID 배열
///
///
/// returns:
/// ID에 해당하는 LodPoi 객체 배열, 없을경우 ni.
- (NSArray<LodPoi *> * _Nullable)getLodPoisWithPoiIDs:(NSArray<NSString *> * _Nonnull)poiIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 LodPoi를 가져온다.
///
/// returns:
/// 현재 Layer에 속한 모든 LodPod.
- (NSArray<LodPoi *> * _Nullable)getAllLodPois SWIFT_WARN_UNUSED_RESULT;
/// layer의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// layer에 속한 Poi가 경쟁하는 방법을 지정한다.
/// Layer의 우선순위(zOrder)에 따라 Poi끼리 겹쳐졌을 때, Poi가 표시될 정책을 지정한다.
/// seealso:
/// CompetitionType
@property (nonatomic, readonly) CompetitionType competitionType;
/// Poi가 경쟁할 때, 경쟁을 하는 단위를 선택한다.
/// seealso:
/// CompetitionUnit
@property (nonatomic, readonly) CompetitionUnit competitionUnit;
/// competitionType이 same일 경우, 경쟁을 하는 기준이 된다.
/// seealso:
/// OrderingType
@property (nonatomic, readonly) OrderingType orderType;
/// layer의 렌더링 우선순위
/// zOrder는 같은 LabelLayer타입끼리만 유효하며, 기본적으로 zOrder 값이 클수록 더 높은 우선권을 가진다.
@property (nonatomic) NSInteger zOrder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// LodLabelLayer 생성 옵션
SWIFT_CLASS("_TtC12KakaoMapsSDK20LodLabelLayerOptions")
@interface LodLabelLayerOptions : NSObject
/// initializer
/// \param layerID layer ID
///
/// \param competitionType 다른 poi와 경쟁하는 방법
///
/// \param competitionUnit 경쟁을 하는 단위
///
/// \param orderType competitionType이 same일 때, 경쟁하는 기준
///
/// \param zOrder layer의 zOrder. 값이 클수록 위에 그려진다.
///
/// \param radius LOD를 계산할 때 사용하는 반경 원의 반지름
///
- (nonnull instancetype)initWithLayerID:(NSString * _Nonnull)layerID competitionType:(CompetitionType)competitionType competitionUnit:(CompetitionUnit)competitionUnit orderType:(OrderingType)orderType zOrder:(NSInteger)zOrder radius:(float)radius OBJC_DESIGNATED_INITIALIZER;
/// layerID
@property (nonatomic, copy) NSString * _Nonnull layerID;
/// 다른 poi와 경쟁하는 방법을 지정한다. 해당 레이어에 속한 poi는 모두 해당 방법으로 경쟁한다.
@property (nonatomic) CompetitionType competitionType;
/// 경쟁할 때 단위를 지정한다. 해당 레이어에 속한 poi는 모두 해당 방법으로 경쟁한다.
@property (nonatomic) CompetitionUnit competitionUnit;
/// competitionType이 same일 때 경쟁하는 기준을 설정한다.
@property (nonatomic) OrderingType orderType;
/// layer의 zOrder
/// zOrder는 같은 LodLabelLayer타입끼리만 유효하며, zOrder 값이 클수록 더 위에 그려진다
/// 즉, zOrder가 0인 LodLabelLayer는에 속한 Label은 zOrder가 1인 LodLabelLayer에 속한 Label보다 아래에 그려진다.
@property (nonatomic) NSInteger zOrder;
/// Lod 처리시 계산하는 반경
@property (nonatomic) float radius;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PoiText;
@class PoiBadge;

/// 지도상에 대량의 Poi를 그리기 위한 클래스
/// Lod 처리를 통해 성능저하를 줄이면서 대량의 Poi를 표시하고자 할 때 사용한다.
/// LodPoi를 추가하기 위해서는 먼저 KakaoMap에 LodLabelLayer를 추가한 뒤, 해당 Layer에 LodPoi를 추가할 수 있다.
/// show, hide, style 변경이 가능하며, Poi마다 개별 badge를 추가할 수 있다.
/// 레벨별로 충돌검사를 하는 LOD 처리가 들어가므로, 이동 및 회전에 대한 interface는 존재하지 않는다.
/// LodPoi는 사용자가 직접 생성할 수 없으며, PoiOptions class를 이용하여 LodLabelLayer에 추가하면 해당 Object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK6LodPoi")
@interface LodPoi : NSObject <Label>
/// LodPoi를 보여준다.
- (void)show;
/// LodPoi를 표시하고, 해당 위치로 이동한다.
/// \param callback LodPoi위치로 카메라 이동이 끝났을 때, 호출할 callback ( optional)
///
- (void)showWithAutoMoveWithCallback:(void (^ _Nullable)(void))callback;
/// LodPoi를 숨긴다.
- (void)hide;
/// LodPoi의 Style을 바꾼다.
/// LabelManager에 등록한 PoiStyle의 키를 이용하여 Style을 변경한다.
/// \param styleID 변경할 Style의 ID
///
/// \param enableTransition 변경시 trasition 효과 적용 여부
///
- (void)changeStyleWithStyleID:(NSString * _Nonnull)styleID enableTransition:(BOOL)enableTransition;
/// LodPoi의 text와 style을 변경한다.
/// LodPoi의 text와 style을 바꿀 때 사용한다.
/// \param texts 바꾸고자 하는 LodPoi의 text
///
/// \param styleID 변경할 styleID.
///
/// \param enableTransition Style 변경시 trasition 효과 적용 여부
///
- (void)changeTextAndStyleWithTexts:(NSArray<PoiText *> * _Nonnull)texts styleID:(NSString * _Nonnull)styleID enableTransition:(BOOL)enableTransition;
/// 개별 Poi에 Badge를 추가한다.
/// seealso:
/// PoiBadge
/// \param badge 추가할 Poi Badge
///
- (void)addBadge:(PoiBadge * _Nonnull)badge;
/// 개별 Poi에 여러개의 Badge를 추가한다.
/// seealso:
/// PoiBadge
/// \param badges 추가할 Poi Badge 배열
///
- (void)addBadges:(NSArray<PoiBadge *> * _Nonnull)badges;
/// Poi에 추가된 뱃지를 지운다.
/// Poi에 등록된 Badge ID를 이용하여 지운다.
/// note:
/// PoiStyle에 추가되어있는 In-Style Badge는 스타일에 종속되므로, 해당 함수로 지울 수 없다.
/// \param badgeID 지우고자하는 badge의 ID
///
- (void)removeBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi에 등록된 Badge를 일괄 지운다.
/// note:
/// PoiStyle에 추가되어있는 In-Style Badge는 스타일에 종속되므로, 해당 함수를 호출해도 지워지지 않는다.
- (void)removeAllBadge;
/// Poi에 등록되어있는 Badge를 보여준다.
/// \param badgeID 보여주고자 하는 badge의 ID
///
- (void)showBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi에 등록되어있는 Badge들을 보여준다.
/// \param badgeIDs 보여주고자 하는 badge의 ID 배열
///
- (void)showBadgesWithBadgeIDs:(NSArray<NSString *> * _Nonnull)badgeIDs;
/// Poi에 등록되어있는 Badge를 숨긴다.
/// \param badgeID 숨기고자 하는 badge의 ID
///
- (void)hideBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi에 등록되어있는 Badge들을 숨긴다.
/// \param badgeIDs 숨기고자 하는 badge의 ID 배열
///
- (void)hideBadgesWithBadgeIDs:(NSArray<NSString *> * _Nonnull)badgeIDs;
/// Poi의 In-Style badge를 보여준다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 badge를 보여준다.
/// \param badgeID 보여주고자 하는 In-Style badge의 ID
///
- (void)showStyleBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi의 In-Style badge를 모두 보여준다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 모든 badge를 보여준다.
- (void)showAllStyleBadges;
/// Poi의 In-Style badge를 숨긴다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 badge를 숨긴다.
/// \param badgeID 숨기고자 하는 In-Style badge의 ID
///
- (void)hideStyleBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi의 In-Style badge를 모두 숨긴다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 모든 badge를 숨긴다.
- (void)hideAllStyleBadges;
/// Poi가 속한 LayerID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// Poi의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull itemID;
/// LodPoi의 렌더링 우선순위
/// 새로운 rank로 값을 assign 하면, 해당 LodPoi의 rank가 업데이트된다.
@property (nonatomic) NSInteger rank;
/// LodPoi의 Clickable 여부
/// clickable 여부를 새로 assign하면, LodPoi의 click여부가 업데이트된다.
@property (nonatomic) BOOL clickable;
/// LodPoi가 현재 뷰에 보여지고 있는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 좌표계 및 좌표계 변환을 담당하는 클래스
/// 지원하는 좌표계 : WTM(5181), WCONG, WGS84(4326), Kakao(3857)
SWIFT_CLASS("_TtC12KakaoMapsSDK17MapCoordConverter")
@interface MapCoordConverter : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// WCong 좌표를 WGS84 좌표로 변환한다.
/// \param wcong 변환할 WCong 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WGS84 경위도 좌표
+ (struct GeoCoordinate)fromWCongToWGS84WithWcong:(struct CartesianCoordinate)wcong SWIFT_WARN_UNUSED_RESULT;
/// WCong 좌표를 Kakao 좌표로 변환한다.
/// \param wcong 변환할 wcong 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// Kakao  좌표
+ (struct CartesianCoordinate)fromWCongToKakaoWithWcong:(struct CartesianCoordinate)wcong SWIFT_WARN_UNUSED_RESULT;
/// WCong 좌표를 WTM 좌표로 변환한다.
/// \param wcong 변환할 wcong 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WTM  좌표
+ (struct CartesianCoordinate)fromWCongToWTMWithWcong:(struct CartesianCoordinate)wcong SWIFT_WARN_UNUSED_RESULT;
/// WTM 좌표를 WCong 좌표로 변환한다.
/// \param wtm 변환할 WTM 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WCong  좌표
+ (struct CartesianCoordinate)fromWTMToWCongWithWtm:(struct CartesianCoordinate)wtm SWIFT_WARN_UNUSED_RESULT;
/// WTM 좌표를 WGS84 좌표로 변환한다.
/// \param wtm 변환할 WTM 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WGS84 경위도  좌표
+ (struct GeoCoordinate)fromWTMToWGS84WithWtm:(struct CartesianCoordinate)wtm SWIFT_WARN_UNUSED_RESULT;
/// WTM 좌표를 Kakao 좌표로 변환한다.
/// \param wtm 변환할 WTM 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// Kakao  좌표
+ (struct CartesianCoordinate)fromWTMToKakaoWithWtm:(struct CartesianCoordinate)wtm SWIFT_WARN_UNUSED_RESULT;
/// WGS84 좌표를 WCong 좌표로 변환한다.
/// \param wgs 변환할 WGS84 좌표를 나타내는 경위도좌표 값
///
///
/// returns:
/// WCong  좌표
+ (struct CartesianCoordinate)fromWGS84ToWCongWithWgs:(struct GeoCoordinate)wgs SWIFT_WARN_UNUSED_RESULT;
/// WGS84 좌표를 WTM 좌표로 변환한다.
/// \param wgs 변환할 WGS84 좌표를 나타내는 경위도좌표 값
///
///
/// returns:
/// WTM  좌표
+ (struct CartesianCoordinate)fromWGS84ToWTMWithWgs:(struct GeoCoordinate)wgs SWIFT_WARN_UNUSED_RESULT;
/// WGS84 좌표를 Kakao 좌표로 변환한다.
/// \param wgs 변환할 WGS84 좌표를 나타내는 경위도좌표 값
///
///
/// returns:
/// Kakao  좌표
+ (struct CartesianCoordinate)fromWGS84ToKakaoWithWgs:(struct GeoCoordinate)wgs SWIFT_WARN_UNUSED_RESULT;
/// Kakao 좌표를 WGS84 좌표로 변환한다.
/// \param kakao 변환할 Kakao 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WGS84  좌표
+ (struct GeoCoordinate)fromKakaoToWGS84WithKakao:(struct CartesianCoordinate)kakao SWIFT_WARN_UNUSED_RESULT;
/// Kakao 좌표를 WTM 좌표로 변환한다.
/// \param kakao 변환할 Kakao 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WTM  좌표
+ (struct CartesianCoordinate)fromKakaoToWTMWithKakao:(struct CartesianCoordinate)kakao SWIFT_WARN_UNUSED_RESULT;
/// Kakao 좌표를 WCong 좌표로 변환한다.
/// \param kakao 변환할 Kakao 좌표를 나타내는 평면좌표 값
///
///
/// returns:
/// WCong  좌표
+ (struct CartesianCoordinate)fromKakaoToWCongWithKakao:(struct CartesianCoordinate)kakao SWIFT_WARN_UNUSED_RESULT;
@end


/// 지도상의 위치를 나타내기 위한 클래스. WGS84(4326) 좌표계를 지원한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8MapPoint")
@interface MapPoint : NSObject
/// Initializer
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Initializer
/// WGS84 경위도좌표계 좌표값으로 MapPoint를 생성한다.
/// \param longitude 경도값
///
/// \param latitude 위도값
///
- (nonnull instancetype)initWithLongitude:(double)longitude latitude:(double)latitude;
/// Initializer
/// 다른 MapPoint 객체로부터 복사한 값으로 새로운 MapPoint 객체를 생성한다.
/// \param from 값을 가져올 MapPoint
///
- (nonnull instancetype)initFrom:(MapPoint * _Nonnull)from;
/// WGS84 좌표값
@property (nonatomic, readonly) struct GeoCoordinate wgsCoord;
@end



/// MapPolygonShape를 구성할 때 사용하는 MapPolygon 클래스.
/// 폴리곤은 단독으로 Map에 추가할 수 없으며, Shape에 종속되는 객체이다.
/// 하나의 외곽선과 hole을 넣어서 구성할 수 있다. 외곽선 point인 exterior ring과 폴리곤 내부 홀을 표시하는 holes로 구성된다.
/// exteriorRing, 즉 외곽선은 시계방향으로 MapPoint를 넣어야 하고, hole은 시계반대방향으로 MapPoint를 넣어야한다.
/// MapPolygon의 Point는 지도좌표계(ex. 3857)타입의 MapPoint로만 구성한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10MapPolygon")
@interface MapPolygon : NSObject
/// initializer
/// \param exteriorRing MapPolygon의 외곽선
///
/// \param holes MapPolygon의 hole 배열. hole이 없을경우 nil로 지정
///
/// \param styleIndex PolygonStyleSet에서 사용할 PolygonStyle 인덱스
///
- (nonnull instancetype)initWithExteriorRing:(NSArray<MapPoint *> * _Nonnull)exteriorRing holes:(NSArray<NSArray<MapPoint *> *> * _Nullable)holes styleIndex:(NSUInteger)styleIndex OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param exteriorRing Polygon의 외곽선
///
/// \param hole Polygon의 하나의 hole. hole이 없을경우 nil로 지정
///
/// \param styleIndex PolygonStyleSet에서 사용할 PolygonStyle 인덱스
///
- (nonnull instancetype)initWithExteriorRing:(NSArray<MapPoint *> * _Nonnull)exteriorRing hole:(NSArray<MapPoint *> * _Nullable)hole styleIndex:(NSUInteger)styleIndex;
/// Polygon의 외곽선.
/// 시계방향의 MapPoint 배열로 구성한다.
@property (nonatomic, readonly, copy) NSArray<MapPoint *> * _Nonnull exteriorRing;
/// MapPolygon의 holes
/// 0개 이상으로 구성되며, 반시계방향의 MapPoint 배열로 구성한다.
@property (nonatomic, readonly, copy) NSArray<NSArray<MapPoint *> *> * _Nullable holes;
/// PolygonStyleSet에서 사용할 표출 스타일 인덱스를 지정한다.
@property (nonatomic, readonly) NSUInteger styleIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Shape protocol
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK5Shape_")
@protocol Shape
/// Shape 표출
- (void)show;
/// Shape 숨김
- (void)hide;
/// Shape ID
@property (nonatomic, readonly, copy) NSString * _Nonnull shapeID;
/// Shape이 속한 레이어 ID
@property (nonatomic, readonly, copy) NSString * _Nullable layerID;
/// Shape orientation
@property (nonatomic) double orientation;
/// Shape 표출 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
@end


/// 지도상에 특정 영역을 2d Polygon으로 표시하는 MapPolygonShape 클래스.
/// 지도 위 특정 위치에 의미있는 면형을 표시하기 위해 사용된다.
/// 따라서 PolygonShape와는 다르게, basePosition 없이  좌표계( ex. 3857 )로 구성되어있는 정점으로만 구성한다.
/// MapPolygonShape를 추가하기 위해서는 먼저 KakaoMap에 ShapeLayer를 추가한 뒤, 해당 Layer에 MapPolygonShape를 추가할 수 있다.
/// show, hide, style변경 및 이동/회전이 가능하다.
/// MapPolygonShape는 사용자가 직접 생성할 수 없으며, MapPolygonShapeOptions class를 이용하여 Layer에 추가하면 해당 object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK15MapPolygonShape")
@interface MapPolygonShape : NSObject <Shape>
/// MapPolygonShape를 보여준다.
- (void)show;
/// MapPolygonShape를 숨긴다.
- (void)hide;
/// MapPolygonShape의 style과 Data를 변경한다.
/// MapPolygonShape의 Style과 MapPolygonShape가 표시하는 polgyon Data를 변경하고자 할 때 사용한다. 단, polygon Data를 바꿀때는 해당 MapPolygonShape 객체가 가리키는 본질이 변하지 않을때만 사용한다. 즉 전혀 다른 MapPolygonShape 객체일때는 MapPolygonShape를 하나 더 만드는것을 권장한다.
/// \param styleID 변경할 styleID
///
/// \param polygons 업데이트 할 폴리곤 데이터.
///
- (void)changeStyleAndDataWithStyleID:(NSString * _Nonnull)styleID polygons:(NSArray<MapPolygon *> * _Nonnull)polygons;
/// shape가 속한 layerID
@property (nonatomic, readonly, copy) NSString * _Nullable layerID;
/// ShapeID.
@property (nonatomic, readonly, copy) NSString * _Nonnull shapeID;
/// PolygonShape의 현재 orientation값
/// 새로운 orientation값으로 assign할 경우, PolygonShape의 orientation이 변경된다.
@property (nonatomic) double orientation;
/// PolygonShape가 현재 지도에 표시되는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// MapPolygonShape생성 옵션 클래스.
/// MapPolygonShape는 지도상의 특정 위치에 의미있는 면형을 표시하기 위해 사용한다.
/// PolygonShape와는 다르게, basePosition없이 지도 좌표계로 구성되어있는 점으로만 폴리곤을 구성한다.
/// MapPolygonShape는 1개 이상의 MapPolygon으로 구성된다. MapPolygon은 지도 좌표계(ex. 3857)로 구성할 수 있다.
/// StyleSetPolygonShape에 속한 Polygon마다 StyleSet을 이용하여 다르게 표출할 수도 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK22MapPolygonShapeOptions")
@interface MapPolygonShapeOptions : NSObject
/// initializer
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 값이 클수록 위에 그려진다.
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param shapeID Shape의 ID
///
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 값이 클수록 위에 그려진다.
///
- (nonnull instancetype)initWithShapeID:(NSString * _Nonnull)shapeID styleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// Shape의 ID
@property (nonatomic, readonly, copy) NSString * _Nullable shapeID;
/// Shape가 표출될 StyleID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
/// Shape의 렌더링 우선순위
/// 높을수록 더 위에 그려지며, Shape type끼리만 유효하다.
/// 즉, zOrder = 0 인 Shape는 zOrder = 1 인 shape보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
/// Shape에 속한 폴리곤.
/// 1개 이상의 폴리곤으로 구성된다.
/// seealso:
/// MapPolygon
@property (nonatomic, copy) NSArray<MapPolygon *> * _Nonnull polygons;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// MapPolylineShape를 구성할 때 사용하는 Polyline 클래스
/// 폴리라인은 단독으로 Map에 추가할 수 없으며, Shape에 종속되는 객체이다.
/// 2개 이상의 MapPoint로 만들어진 라인으로 구성된다. 폴리라인의 캡 스타일도 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK11MapPolyline")
@interface MapPolyline : NSObject
/// Initializer
/// \param line MapPolyline을 구성하는 MapPoint 배열
///
/// \param styleIndex MapPolyline에 적용할 PolylineStyleSet에 속한 PolylineStyle의 index
///
- (nonnull instancetype)initWithLine:(NSArray<MapPoint *> * _Nonnull)line styleIndex:(NSUInteger)styleIndex OBJC_DESIGNATED_INITIALIZER;
/// 라인. 2개 이상의 MapPoint로 구성된다.
@property (nonatomic, readonly, copy) NSArray<MapPoint *> * _Nonnull line;
/// ShapeStyleSet에서 사용할 표출 인덱스
@property (nonatomic, readonly) NSUInteger styleIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 지도상에 특정 선형을 2d Polyline으로 표시하는  PolylineShape 클래스.
/// 지도 위 특정 위치에 의미있는 선형을 표시하기 위해 사용된다.
/// 따라서 PolylineShape와는 다르게, basePosition 없이  좌표계( ex. 3857 )로 구성되어있는 정점으로만 구성한다.
/// MapPolylineShape를 추가하기 위해서는 먼저 KakaoMap에 ShapeLayer를 추가한 뒤, 해당 Layer에 MapPolylineShape를 추가할 수 있다.
/// show, hide, style변경 및 이동/회전이 가능하다.
/// MapPolylineShape는 사용자가 직접 생성할 수 없으며, MapPolylineShapeOptions class를 이용하여 Layer에 추가하면 해당 Object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK16MapPolylineShape")
@interface MapPolylineShape : NSObject <Shape>
/// MapPolylineShape를 보여준다.
- (void)show;
/// MapPolylineShape를 숨긴다.
- (void)hide;
/// MapPolylineShape의 style과 Data를 변경한다.
/// MapPolylineShape의 style과 표시하는 MapPolyline Data를 변경하고자 할 때 사용한다.
/// 단, MapPolyline Data를 바꿀때는 해당 MapPolylineShape 객체가 가리키는 본질이 변하지 않을때만 사용한다.
/// 즉 전혀 다른 MapPolylineShape 객체일때는 MapPolylineShape를 하나 더 만드는것을 권장한다.
/// \param styleID 변경할 styleID
///
/// \param lines 업데이트 할 폴리라인 데이터.
///
- (void)changeStyleAndDataWithStyleID:(NSString * _Nonnull)styleID lines:(NSArray<MapPolyline *> * _Nonnull)lines;
/// Shape가 속한 layerID
@property (nonatomic, readonly, copy) NSString * _Nullable layerID;
/// Shape의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull shapeID;
/// MapPolylineShape의 Orientation (radian)
/// 새로운 orientation값을 assign하면, PolylineShape의 orientation 값이 업데이트된다.
@property (nonatomic) double orientation;
/// MapPolylineShape가 현재 지도에 표시되는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// MapPolylineShape 생성 옵션 클래스.
/// MapPolylineShape는 지도상의 특정 위치에 의미있는 선형을 표시하기 위해 사용한다.
/// PolylineShape와는 다르게, basePosition 없이 지도 좌표계로 구성되어있는 점으로만 폴리라인을 구성한다.
/// MapPolylineShape는 1개 이상의 MapPolyline으로 구성된다. MapPolyline은 지도 좌표계(ex. 3857)로 구성할 수 있다.
/// Style은 PolylineShape에 속한 Polyline마다 StyleSet을 이용하여 다르게 적용할 수 있다.
/// PolylineShape의 id를 별도로 지정하지 않는 경우, 내부적으로 자동으로 부여한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK23MapPolylineShapeOptions")
@interface MapPolylineShapeOptions : NSObject
/// initializer
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 값이 높을수록 위에 그려진다.
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param shapeID Shape의 ID
///
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 값이 높을수록 위에 그려진다.
///
- (nonnull instancetype)initWithShapeID:(NSString * _Nonnull)shapeID styleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// Shape의 ID
@property (nonatomic, readonly, copy) NSString * _Nullable shapeID;
/// Shape가 표출될 StyleID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
/// Shape의 렌더링 우선순위
/// 높을수록 더 위에 그려지며, Shape type끼리만 유효하다.
/// 즉, zOrder = 0 인 Shape는 zOrder = 1 인 shape보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
/// Shape에 속한 MapPolyline 배열
/// 1개 이상의 폴리라인으로 구성된다.
/// seealso:
/// MapPolyline
@property (nonatomic, copy) NSArray<MapPolyline *> * _Nonnull polylines;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// API에서 보여줄 View의 이름과 종류, 사용할 설정을 지정한다.
/// View를 어떻게 보여줄지에 대한 세부 설정은 config file로 컨피그 서버에 저장되어 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8ViewInfo")
@interface ViewInfo : NSObject
/// ViewInfo의 종류.
@property (nonatomic, readonly) ViewInfoType viewInfoType;
/// Cocoa에 등록된 app 이름.
@property (nonatomic, readonly, copy) NSString * _Nonnull appName;
/// View의 이름.
@property (nonatomic, readonly, copy) NSString * _Nonnull viewName;
/// 사용할 viewInfo의 이름. ex)’map’
@property (nonatomic, readonly, copy) NSString * _Nonnull viewInfoName;
/// 초기 활성화 여부
@property (nonatomic, readonly) BOOL enabledInitially;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 지도 ViewInfo. KakaoMap으로 view가 생성된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK11MapviewInfo")
@interface MapviewInfo : ViewInfo
/// 초기 위치
@property (nonatomic, readonly, strong) MapPoint * _Nonnull defaultPosition;
/// 초기 레벨
@property (nonatomic, readonly) NSInteger defaultLevel;
@end


@interface MapviewInfo (SWIFT_EXTENSION(KakaoMapsSDK))
/// Initializer
/// \param viewName view의 이름
///
/// \param appName Cocoa에 등록된 app 이름. 따로 등록된 내용이 없을 경우 “openmap” 사용.
///
/// \param viewInfo viewInfo의 이름.
///
/// \param defaultPosition 초기 위치(MapView인 경우). 기본값은 서울시청.
///
/// \param defaultLevel 초기 레벨(MapView인 경우). 기본값은 17.
///
/// \param enabled 초기 활성화 여부. 기본값은 true.
///
- (nonnull instancetype)initWithViewName:(NSString * _Nonnull)viewName appName:(NSString * _Nonnull)appName viewInfoName:(NSString * _Nonnull)viewInfoName defaultPosition:(MapPoint * _Nullable)defaultPosition defaultLevel:(NSInteger)defaultLevel enabled:(BOOL)enabled;
@end


/// PanoramaView에 표시할 Marker 클래스.
SWIFT_CLASS("_TtC12KakaoMapsSDK14PanoramaMarker")
@interface PanoramaMarker : NSObject
/// PanoramaMarker의 타입
/// seealso:
/// PanoramaMarkerType
@property (nonatomic, readonly) PanoramaMarkerType markerType;
/// PanoramaMarker가 표시될 방향의 pan 값
@property (nonatomic, readonly) double pan;
/// PanoramaMarker가 표시될 방향의 tilt 값
@property (nonatomic, readonly) double tilt;
/// PanoramaMarker가 표시될 위치
@property (nonatomic, readonly, strong) MapPoint * _Nullable position;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PoiIconStyle;
@class PoiTextStyle;

/// 특정레벨에 적용될 라벨스타일을 지정하는 클래스.
/// PoiStyle을 하나 이상의 PerLevelPoiStyle로 구성할 수 있다.
/// PerLevelPoiStyle에 지정된 레벨에서부터 하위의 PerLevelStyle이 지정된 레벨이 되기전까지 적용된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK16PerLevelPoiStyle")
@interface PerLevelPoiStyle : NSObject
/// initializer
/// \param iconStyle Poi의 IconStyle.
///
/// \param textStyle Poi의 TextStyle
///
/// \param padding padding
///
/// \param level 해당 Style이 표출되기 시작할 레벨. 특정 레벨에서 해당 표출 레벨의 iconStyle, 혹은 textStyle이 추가되지 않은 경우, Poi 심볼이나 텍스트가 표시되지 않는다.
///
- (nonnull instancetype)initWithIconStyle:(PoiIconStyle * _Nonnull)iconStyle textStyle:(PoiTextStyle * _Nonnull)textStyle padding:(float)padding level:(NSInteger)level OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param iconStyle Poi의 IconStyle
///
/// \param padding padding
///
/// \param level 해당 Style이 표출되기 시작할 레벨
///
- (nonnull instancetype)initWithIconStyle:(PoiIconStyle * _Nonnull)iconStyle padding:(float)padding level:(NSInteger)level OBJC_DESIGNATED_INITIALIZER;
/// Poi의 IconStyle
/// seealso:
/// PoiIconStyle
@property (nonatomic, readonly, strong) PoiIconStyle * _Nonnull iconStyle;
/// Poi의 TextStyle
/// seealso:
/// PoiTextStyle
@property (nonatomic, readonly, strong) PoiTextStyle * _Nullable textStyle;
/// padding
@property (nonatomic, readonly) float padding;
/// Style이 표출되기 시작할 레벨
@property (nonatomic, readonly) NSInteger level;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolygonStyle Unit 클래스.
/// Level별 PolygonStyle을 구성할 때 사용한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK20PerLevelPolygonStyle")
@interface PerLevelPolygonStyle : NSObject
/// initializer
/// \param color PolygonShape의 색깔
///
/// \param storkeWidth PolygonShape의 외곽선 두께
///
/// \param storkeColor PolygonShape의 외곽선 색깔
///
/// \param level 해당 단위 스타일이 표출 될 레벨
///
- (nonnull instancetype)initWithColor:(UIColor * _Nonnull)color strokeWidth:(NSUInteger)strokeWidth strokeColor:(UIColor * _Nonnull)strokeColor level:(NSInteger)level OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param color PolygonShape의 색깔
///
/// \param level 해당 단위 스타일이 표출 될 레벨
///
- (nonnull instancetype)initWithColor:(UIColor * _Nonnull)color level:(NSInteger)level;
/// Shape의 색깔.
@property (nonatomic, readonly, strong) UIColor * _Nonnull color;
/// Shape의 외곽선 두께. 지정하지 않을 경우 0
@property (nonatomic, readonly) NSUInteger strokeWidth;
/// Shape의 외곽선 색깔. 지정하지 않을 경우 투명.
@property (nonatomic, readonly, strong) UIColor * _Nonnull strokeColor;
/// 해당 스타일이 표출될 레벨 .
@property (nonatomic, readonly) NSInteger level;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PerLevelPolylineStyle의 단위 클래스
/// level별 PolylineStyle을 구성할 때 사용한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK21PerLevelPolylineStyle")
@interface PerLevelPolylineStyle : NSObject
/// Initializer
/// \param bodyColor Polyline의 body 색상
///
/// \param bodyWidth Polyline의 body 두께
///
/// \param strokeColor Polyline의 외곽선 색깔
///
/// \param storkeWidth Polyline의 외곽선 두께
///
/// \param level 해당 단위스타일이 표출될 레벨
///
- (nonnull instancetype)initWithBodyColor:(UIColor * _Nonnull)bodyColor bodyWidth:(NSUInteger)bodyWidth strokeColor:(UIColor * _Nonnull)strokeColor strokeWidth:(NSUInteger)strokeWidth level:(NSInteger)level OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param bodyColor Polyline의 body 색상
///
/// \param bodyWidth Polyline의 body 두께
///
/// \param level 해당 단위스타일이 표출될 레벨
///
- (nonnull instancetype)initWithBodyColor:(UIColor * _Nonnull)bodyColor bodyWidth:(NSUInteger)bodyWidth level:(NSInteger)level;
/// Polyline의 Body 색깔.
@property (nonatomic, readonly, strong) UIColor * _Nonnull bodyColor;
/// Polyline의 Body 두께
@property (nonatomic, readonly) NSUInteger bodyWidth;
/// Polyline의 외곽선 색깔
@property (nonatomic, readonly, strong) UIColor * _Nonnull strokeColor;
/// Polyline의 외곽선 두께
@property (nonatomic, readonly) NSUInteger strokeWidth;
/// 해당 단위 스타일이 표출될 레벨
@property (nonatomic, readonly) NSInteger level;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PerLevelRouteStyle 단위 클래스.
/// Level별 Route Style을 구성할 때 사용한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK18PerLevelRouteStyle")
@interface PerLevelRouteStyle : NSObject
/// Initializer
/// \param width Route Width
///
/// \param color rotue Color
///
/// \param strokeWidth Route의 외곽선 두께
///
/// \param strokeColor Route의 외곽선 색깔
///
/// \param level 해당 단위 스타일이 표출될 레벨
///
/// \param patternIndex 추가한 패턴의 인덱스
///
- (nonnull instancetype)initWithWidth:(NSUInteger)width color:(UIColor * _Nonnull)color strokeWidth:(NSUInteger)strokeWidth strokeColor:(UIColor * _Nonnull)strokeColor level:(NSInteger)level patternIndex:(NSInteger)patternIndex OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param width Route Width
///
/// \param color rotue Color
///
/// \param level 해당 단위 스타일이 표출될 레벨
///
/// \param patternIndex 추가한 패턴의 인덱스
///
- (nonnull instancetype)initWithWidth:(NSUInteger)width color:(UIColor * _Nonnull)color level:(NSInteger)level patternIndex:(NSInteger)patternIndex;
/// Route의 두께.
@property (nonatomic, readonly) NSUInteger width;
/// Route의 색깔
@property (nonatomic, readonly, strong) UIColor * _Nonnull color;
/// Route의 외곽선 두께
@property (nonatomic, readonly) NSUInteger strokeWidth;
/// Route의 외곽선 색깔
@property (nonatomic, readonly, strong) UIColor * _Nonnull strokeColor;
/// 스타일이 표출될 레벨
@property (nonatomic, readonly) NSInteger level;
/// 추가한 패턴의 인덱스
@property (nonatomic, readonly) NSInteger patternIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PerLevelWaveTextStyle을 표시하기 위한 클래스
/// 하나의 WaveTextStyle을 하나 이상의 PerLevelWaveTextStyle로 구성할 수 있다.
/// PerLevelWaveTextStyle에 지정된 레벨에서부터 하위의 PerLevelWaveTextStyle이 지정된 레벨이 되기전까지 적용된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK21PerLevelWaveTextStyle")
@interface PerLevelWaveTextStyle : NSObject
/// Initializer
/// \param textStyle WaveText의 TextStyle
///
/// \param level 해당 스타일이 표시될 레벨
///
- (nonnull instancetype)initWithTextStyle:(TextStyle * _Nonnull)textStyle level:(NSInteger)level OBJC_DESIGNATED_INITIALIZER;
/// WaveText의 TextStyle
/// seealso:
/// TextStyle
@property (nonatomic, readonly, strong) TextStyle * _Nonnull textStyle;
/// Style이 표출될 level
/// PerLevelWaveTextStyle 단독으로는 사용되지 않으며, WaveTextStyle을 생성할 때 사용된다.
/// seealso:
/// WaveTextStyle
@property (nonatomic, readonly) NSInteger level;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 지도상에 Poi를 그리기 위한 클래스
/// Poi를 추가하기 위해서는 먼저 KakaoMap에 LabelLayer를 추가한 뒤, 해당 Layer에 Poi를 추가할 수 있다.
/// show, hide, style 변경이 가능하며, Poi마다 개별 badge를 추가할 수 있다.
/// 이동, 또는 회전을 하는 애니메이션이 가능하다. 이동 애니메이션중에 다른 애니메이션 동작을 할 경우 기존 이동 애니메이션이 멈춘다. 회전 애니메이션 중에 다른 회전 애니메이션을 할 경우 기존 애니메이션이 멈춘다.
/// Poi는 사용자가 직접 생성할 수 없으며, PoiOptions class를 이용하여 Layer에 추가하면 해당 Object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK3Poi")
@interface Poi : NSObject <Label>
/// Poi를 보여준다.
- (void)show;
/// Poi를 표시하고, 해당 위치로 이동한다.
/// \param callback Poi위치로 카메라 이동이 끝났을 때, 호출할 callback ( optional)
///
- (void)showWithAutoMoveWithCallback:(void (^ _Nullable)(void))callback;
/// Poi를 숨긴다.
- (void)hide;
/// Poi의 Style을 변경한다.
/// LabelManager에 등록한 PoiStyle의 키를 이용하여 Style을 변경한다.
/// \param styleID 변경할 Style의 ID
///
/// \param enableTransition Style 변경시 trasition 효과 적용 여부
///
- (void)changeStyleWithStyleID:(NSString * _Nonnull)styleID enableTransition:(BOOL)enableTransition;
/// Poi의 text와 style을 변경한다.
/// Poi의 text와 style을 바꿀 때 사용한다.
/// \param texts 바꾸고자 하는 PoiText
///
/// \param styleID 변경할 styleID.
///
/// \param enableTransition 변경시 trasition 효과 적용 여부
///
- (void)changeTextAndStyleWithTexts:(NSArray<PoiText *> * _Nonnull)texts styleID:(NSString * _Nonnull)styleID enableTransition:(BOOL)enableTransition;
/// 개별 Poi에 Badge를 추가한다.
/// seealso:
/// PoiBadge
/// \param badge 추가할 Poi Badge
///
- (void)addBadge:(PoiBadge * _Nonnull)badge;
/// 개별 Poi에 여러개의 Badge를 추가한다.
/// seealso:
/// PoiBadge
/// \param badges 추가할 Poi Badge 배열
///
- (void)addBadges:(NSArray<PoiBadge *> * _Nonnull)badges;
/// Poi에 추가된 뱃지를 지운다.
/// Poi에 등록된 Badge ID를 이용하여 지운다.
/// note:
/// PoiStyle에 추가되어있는 In-Style Badge는 스타일에 종속되므로, 해당 함수로 지울 수 없다.
/// \param badgeID 지우고자하는 badge의 ID
///
- (void)removeBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi에 등록된 Badge를 일괄 지운다.
/// note:
/// PoiStyle에 추가되어있는 In-Style Badge는 스타일에 종속되므로, 해당 함수를 호출해도 지워지지 않는다.
- (void)removeAllBadge;
/// Poi에 등록되어있는 Badge를 보여준다.
/// \param badgeID 보여주고자 하는 badge의 ID
///
- (void)showBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi에 등록되어있는 Badge들을 보여준다.
/// \param badgeIDs 보여주고자 하는 badge의 ID 배열
///
- (void)showBadgesWithBadgeIDs:(NSArray<NSString *> * _Nonnull)badgeIDs;
/// Poi에 등록되어있는 Badge를 숨긴다.
/// \param badgeID 숨기고자 하는 badge의 ID
///
- (void)hideBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi에 등록되어있는 Badge들을 숨긴다.
/// \param badgeIDs 숨기고자 하는 badge의 ID 배열
///
- (void)hideBadgesWithBadgeIDs:(NSArray<NSString *> * _Nonnull)badgeIDs;
/// Poi의 In-Style badge를 보여준다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 badge를 보여준다.
/// \param badgeID 보여주고자 하는 In-Style badge의 ID
///
- (void)showStyleBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi의 In-Style badge를 모두 보여준다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 모든 badge를 보여준다.
- (void)showAllStyleBadges;
/// Poi의 In-Style badge를 숨긴다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 badge를 숨긴다.
/// \param badgeID 숨기고자 하는 In-Style badge의 ID
///
- (void)hideStyleBadgeWithBadgeID:(NSString * _Nonnull)badgeID;
/// Poi의 In-Style badge를 모두 숨긴다.
/// LabelManager를 통해 등록된 PoiStyle에 종속되는 모든 badge를 숨긴다.
- (void)hideAllStyleBadges;
/// Poi를 지정한 위치로 옮긴다
/// Poi를 지정한 위치로 지정한 시간동안 이동시킨다.
/// \param position 이동시킬 위치
///
/// \param duration 애니메이션 시간
///
- (void)moveAt:(MapPoint * _Nonnull)position duration:(NSUInteger)duration;
/// Poi를 지정한 각도로 회전시킨다.
/// Poi를 지정한 각도로 지정한 시간동안 회전시킨다. 현재 방향을 기준으로 회전하는것이 아니라, 절대회전방위로 이동한다.
/// 회전중에 setOrientation()이 호출되면, 멈춘다.
/// \param roll 회전시킬 각도
///
/// \param duration 애니메이션 시간
///
- (void)rotateAt:(double)roll duration:(NSUInteger)duration;
/// Poi가 특정지점들을 따라서 움직이게 한다.
/// Path를 지정해서 Poi가 해당 path를 따라 움직이게 한다. 단, Poi의 각도는 변하지 않고 지정한 Path를 따라 움직이기만 한다.
/// 이동중에 setPosition / moveAt이 호출되면 멈춘다.
/// \param points Poi가 따라서 움직일 각도
///
/// \param duration 애니메이션 시간
///
/// \param cornerRadius Path중 코너를 통과할 때 부드러운 이동 효과를 주기 위한 곡선으로 처리하는 길이
///
/// \param jumpTreshold 해당 함수 실행중에 새로운 경로가 들어왔을때 현재위치~새 경로 시작점간에 거리에서 점프를 할지에 대한 임계값.
///
- (void)moveOnPath:(NSArray<MapPoint *> * _Nonnull)points duration:(NSUInteger)duration cornerRadius:(float)cornerRadius jumpThreshold:(float)jumpThreshold;
/// Poi가 특정지점들을 따라서 회전하면서 움직이게 한다.
/// Path를 지정해서 Poi가 해당 path를 따라 회전하면서 움직이게 한다. path의 각도에 따라 Poi도 같이 회전한다.
/// \param points Poi가 따라서 움직일 path
///
/// \param baseRadian path가 1개뿐이거나, 진행방향의 역방향으로 path가 들어와 방향을 알 수 없을 때 가이드가 될 radian 값.
///
/// \param duration 애니메이션 시간
///
/// \param cornerRadius Path중 코너를 통과할 때 부드러운 이동 효과를 주기 위한 곡선으로 처리하는 길이
///
/// \param jumpTreshold 해당 함수 실행중에 새로운 경로가 들어왔을때 현재위치~새 경로 시작점간에 거리에서 점프를 할지에 대한 임계값.
///
- (void)moveAndRotateOnPath:(NSArray<MapPoint *> * _Nonnull)points baseRadian:(float)baseRadian duration:(NSUInteger)duration cornerRadius:(float)cornerRadius jumpThreshold:(float)jumpThreshold;
/// 현재 Poi의 position을 공유할 Poi를 추가한다/
/// 파라미터의 Poi가 현재 Poi의 위치만을 따라간다.
/// \param poi 현재 poi의 position을 공유할 poi
///
- (void)sharePositionWithPoi:(Poi * _Nonnull)poi;
/// 현재 Poi와 지정된 poi간에 더이상 position을 공유하지 않게한다.
/// \param poi position공유를 하지 않을 poi
///
- (void)removeSharePositionWithPoi:(Poi * _Nonnull)poi;
/// 현재 Poi의 transform을 공유할 Poi를 추가한다.
/// 파라미터의 Poi가 현재 객체 Poi의 transform을 따라간다.
/// \param poi 현재 poi의 transform을 공유할 poi
///
- (void)shareTransformWithPoi:(Poi * _Nonnull)poi;
/// 현재 Poi와 지정된 poi간에 더이상 transform을 공유하지 않게한다.
/// \param poi transform공유를 하지 않을 poi
///
- (void)removeShareTransformWithPoi:(Poi * _Nonnull)poi;
/// 현재 Poi의 transform을 공유할 Shape를 추가한다.
/// 파라미터의 Shape가 현재 객체 Poi의 transform을 따라간다.
/// \param shape 현재 poi의 transform을 공유할 shape
///
- (void)shareTransformWithShape:(id <Shape> _Nonnull)shape;
/// 현재 Poi와 지정된 shape간에 더이상 transform을 공유하지 않게한다.
/// \param shape transform공유를 하지 않을 shape
///
- (void)removeShareTransformWithShape:(id <Shape> _Nonnull)shape;
/// Poi가 속한 LayerID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// Poi의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull itemID;
/// Poi의 렌더링 우선순위
/// rank값을 새로 assign하면, Poi의 rank가 업데이트 된다.
@property (nonatomic) NSInteger rank;
/// Poi의 clickable 여부. 생성 옵션에서 따로 지정하지 않는 경우, default는 false로 설정된다.
/// 새로운 값을 assign하여 clickable 여부를 바꿀 수 있다.
@property (nonatomic) BOOL clickable;
/// Poi의 위치
/// 새로운 position값으로 assign하면, Poi의 position값이 변경된다.
@property (nonatomic, strong) MapPoint * _Nonnull position;
/// Poi의 Orientation(radian)
/// 새로운 orientation값으로 assign하면, Poi의 Orientation값이 변경된다.
@property (nonatomic) double orientation;
/// Poi가 현재 뷰에 보여지고 있는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// Poi가 그려진 위치로부터 pixelOffset을 적용한다.
/// left/top 방향은 -, right/bottom 방향은 +로 offset을 지정할 수 있다.
@property (nonatomic) CGPoint pixelOffset;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Poi에 위에서 아래로 떨어지는 Drop Animation 효과를 주는 클래스.
/// Animator를 생성해서 Animator에 효과를 주고자 하는 poi를 넣고, animator를 동작시키는 방식이다.
/// Animator는 사용자가 직접 생성할 수 없으며, LabelManager를 통해서만 생성한 객체를 받아서 사용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK11PoiAnimator")
@interface PoiAnimator : NSObject <Animator>
/// Animator를 동작시킨다.
/// Animator에 추가된 Poi가 하나도 없을 경우, 동작하지 않는다. start를 호출한 이후에는 Animator에 Poi를 추가하거나 지울 수 없다. 추가하고자 하는 경우, stop을 호출하고 추가해야한다.
/// start 호출 이후 애니메이션이 끝나면 Animator에 추가된 Poi는 비워지므로, 다시 start를 호출하려면 Poi를 추가해야한다.
/// Poi Interface에 있는 애니메이션은 animator가 start되면 모두 멈춘다.
- (void)start;
/// Animator 동작을 멈춘다.
/// stop이 호출되면 애니메이션이 끝난것으로 간주되어 Animator에 속한 Poi는 모두 비워지므로, Animator를 다시 동작시키려면 다시 Poi를 Animator에 추가해야한다.
- (void)stop;
/// Animator 의 종료 콜백을 지정한다. Start 된 애니메이션이 종료되거나 stop이 호출되면 지정한 callback 이 호출된다. nil 로 지정해서 기존에 지정했던 callback을 제거할 수 있다. 기본값 nil.
/// \param callback Animator에 추가할 종료 콜백.
///
- (void)setStopCallback:(void (^ _Nullable)(id <Animator> _Nullable))callback;
/// Animator에 Poi를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 Poi를 추가한다. start() 를 호출한 이후에는 애니메이션이 끝나기 전까지 poi를 추가할 수 없다.
/// \param poi Animator에 추가할 poi
///
- (void)addPoi:(Poi * _Nonnull)poi;
/// Animator에 여러개의 Poi를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 Poi를 추가한다. start() 를 호출한 이후에는 애니메이션이 끝나기 전까지 poi를 추가할 수 없다.
/// \param pois Animator에 추가할 poi 배열
///
- (void)addPois:(NSArray<Poi *> * _Nonnull)pois;
/// Animator에 추가한 poi를 모두 지운다.
/// start() 호출 이후에는 동작하지 않는다.
- (void)clearAllPois;
/// 추가한 animatorID
@property (nonatomic, readonly, copy) NSString * _Nonnull animatorID;
/// Animator 시작 여부
@property (nonatomic, readonly) BOOL isStart;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PoiBadge 클래스
/// Poi에 Poi icon 심볼이미지외에 추가 이미지를 표시하고자 할 경우 사용할 수 있다.
/// Poi에 개별로 지정하거나 PoiIconStyle에 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8PoiBadge")
@interface PoiBadge : NSObject
/// initializer
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     badgeID: 추가할 badge의 ID
///   </li>
///   <li>
///     image: badge의 image
///   </li>
///   <li>
///     offset: Badge가 위치할 offset
///   </li>
///   <li>
///     zOrder: Badge의 zOrder. 뱃지의 배치 순서를 결정한다. 값이 클수록 더 위에 그려진다.
///   </li>
/// </ul>
- (nonnull instancetype)initWithBadgeID:(NSString * _Nonnull)badgeID image:(UIImage * _Nullable)image offset:(CGPoint)offset zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// badge의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull badgeID;
/// 추가한 badge의 offset
@property (nonatomic, readonly) CGPoint offset;
/// badge의 Image
@property (nonatomic, readonly, strong) UIImage * _Nullable image;
/// badge의 zOrder. 해당 값으로 badge의 배치 순서를 바꿀 수 있다.
/// 값이 큰 Badge가 더 위에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PoiIconStyle Class.
/// Poi의 Icon Style을 정의한다.
/// Poi의 심 볼이미지, AnchorPoint등을 정의한다.
/// Poi가 나타나거나 사라질 때, Icon의 애니메이션 효과인 transition type을 정의할 수 있다.
/// 또한 Icon에 종속되는 Badge를 Style로 정의할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12PoiIconStyle")
@interface PoiIconStyle : NSObject
/// Initializer
/// \param symbol Poi의 심볼이미지
///
/// \param anchorPoint Symbol Image의 AnchorPoint. default값은 (0.5, 0.5)
///
/// \param transition Poi가 show/hide 할 때 애니메이션 효과 타입
///
/// \param enableEntranceTransition 레벨변경시 스타일이 변할 때, 지정한 transition효과 적용여부. show()/hide()는 해당 값과 관계없이 transition 효과가 적용된다.
///
/// \param enableExitTransition 레벨변경시 스타일이 변할 때, 지정한 transition 효과 적용 여부. show()/hide()는 해당 값과 관계없이 transition 효과가 적용된다.
///
/// \param badges IconStyle에 종속되는 Badge. 여러개의 Poi에 badge가 포함된 똑같은 스타일을 사용하면 일괄적으로 뱃지가 표시된다.
///
- (nonnull instancetype)initWithSymbol:(UIImage * _Nullable)symbol anchorPoint:(CGPoint)anchorPoint transition:(struct PoiTransition)transition enableEntranceTransition:(BOOL)enableEntranceTransition enableExitTransition:(BOOL)enableExitTransition badges:(NSArray<PoiBadge *> * _Nullable)badges OBJC_DESIGNATED_INITIALIZER;
/// Poi의 심볼이미지
@property (nonatomic, readonly, strong) UIImage * _Nullable symbol;
/// AnchorPoint
@property (nonatomic, readonly) CGPoint anchorPoint;
/// Poi가 show/hide하거나, 레벨변경에 의해 스타일이 변할 때 심볼에 적용되는 애니메이션 효과 정의
@property (nonatomic, readonly) struct PoiTransition transition;
/// 레벨변경에 의해 스타일이 변할 때, transition 효과 적용 여부. false로 설정할 경우 설정한 transition이 적용되지 않는다.
/// 해당 값과 관계없이 Poi가 show()로 화면에 표시될 때는 기존에 설정한 transition대로 동작한다.
/// 기본값은 true.
@property (nonatomic, readonly) BOOL enableEntranceTransiion;
/// 레벨변경에 의해 스타일이 변할 때, transition 효과 적용 여부. false로 설정할 경우 설정한 transition이 적용되지 않는다.
/// 해당 값과 관계없이 Poi가 hide()로 화면에서 사라질 때는 기존에 설정한 transition대로 동작한다.
/// 기본값은 true.
@property (nonatomic, readonly) BOOL enableExitTransition;
/// Poi IconStyle에 종속되는 뱃지
/// 여러개의 Poi에 badge가 포함된 똑같은 스타일을 사용하면 일괄적으로 뱃지가 표시된다.
@property (nonatomic, readonly, copy) NSArray<PoiBadge *> * _Nullable badges;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Poi 생성 옵션 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK10PoiOptions")
@interface PoiOptions : NSObject
/// initializer
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     styleID: 사용할 PoiStyle ID
///   </li>
/// </ul>
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     styleID: 사용할 PoiStyle ID
///   </li>
///   <li>
///     poiID: poi 고유 ID
///   </li>
/// </ul>
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID poiID:(NSString * _Nonnull)poiID;
/// PoiID. 지정하지 않을 경우 자동으로 부여된다.
@property (nonatomic, readonly, copy) NSString * _Nullable itemID;
/// Poi의 styleID
@property (nonatomic, copy) NSString * _Nonnull styleID;
/// Poi의 렌더링 우선순위
@property (nonatomic) NSInteger rank;
/// Poi의 클릭가능 여부
@property (nonatomic) BOOL clickable;
/// Poi의 transformType. 총 4가지 타입이 존재한다.
/// seealso:
/// PoiTransformType
@property (nonatomic) PoiTransformType transformType;
/// Poi에 추가할 텍스트를 지정한다.
/// seealso:
/// PoiText
/// \param text Poi에 표시될 text
///
- (void)addText:(PoiText * _Nonnull)text;
/// Poi에 추가할 텍스트 목록
///
/// returns:
/// Poi에 표시될 text
- (NSArray<PoiText *> * _Nonnull)texts SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PoiStyle을 지정하는 클래스.
/// 1개 이상의 PerLevelPoiStyle로 구성된다.
/// LabelManager를 통해 Style을 등록한다. 등록된 style의 ID를 Poi에 지정해주면, Poi가 해당 스타일로 생성된다.
/// 혹은 등록된 styleID로 Poi의 스타일을 변경할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8PoiStyle")
@interface PoiStyle : NSObject
/// initializer
/// <ul>
///   <li>
///     parameters
///     <ul>
///       <li>
///         styleID: PoiStyle의 ID
///       </li>
///       <li>
///         styles: PoiStyle을 구성할 단위레벨별 PerLevelPoiStyle 배열
///       </li>
///     </ul>
///   </li>
/// </ul>
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID styles:(NSArray<PerLevelPoiStyle *> * _Nonnull)styles OBJC_DESIGNATED_INITIALIZER;
/// 추가된 PerLevelPoiStyle 배열
@property (nonatomic, readonly, copy) NSArray<PerLevelPoiStyle *> * _Nonnull styles;
/// PoiStyleID.
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Poi에 표시할 PoiText Class
/// Poi에 표시될 하나의 라인을 정의한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK7PoiText")
@interface PoiText : NSObject
/// initializer
/// \param text Poi에 표시할 text
///
/// \param styleIndex 적용한 PoiTextStyle내에서 TextLine의 인덱스. 인덱스가 생성해둔 PoiTextStyle의 크기를 넘어갈 경우, 가장 마지막에 추가한 styleIndex로 표시된다.
///
- (nonnull instancetype)initWithText:(NSString * _Nonnull)text styleIndex:(NSUInteger)styleIndex OBJC_DESIGNATED_INITIALIZER;
/// Poi에 표시될 Text
@property (nonatomic, readonly, copy) NSString * _Nonnull text;
/// 적용한 PoiTextStyle내에서 TextLine의 인덱스
@property (nonatomic, readonly) NSUInteger styleIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PoiTextLineStyle 클래스
/// PoiText 하나마다 PoiTextLineStyle을 지정할 수 있다.
/// 예를 들어, Poi에 PoiText를 2개 이상 넣고자 하는 경우, 각 PoiText마다 PoiTextStyle에 생성한 PoiTextLineStyle의 인덱스를 지정하여 특정 텍스트 스타일로 표시할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK16PoiTextLineStyle")
@interface PoiTextLineStyle : NSObject
/// initializer
/// default TextStyle과 center Layout 으로 지정된다.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// TextStyle
@property (nonatomic, strong) TextStyle * _Nonnull textStyle;
@end


/// PoiTextStyle class.
/// Poi에 Text를 넣을 경우, 이 Text의 Style을 정의하는 클래스.
/// 한개 이상의 PoiTextLineStyle로 구성된다. 하나의 Poi에 여러라인의 텍스트를 넣고 각 텍스트 라인마다 스타일을 다르게 주고자 하는 경우 두개 이상의 PoiTextLineStyle을 생성하여 PoiTextStyle을 구성할 수 있다.
/// Poi가 나타나거나 사라질 때, transition Type을 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12PoiTextStyle")
@interface PoiTextStyle : NSObject
/// Initailizer
/// \param transition Poi가 show/hide 할 때 애니메이션 효과
///
/// \param enableEntranceTransition 레벨변경시 스타일이 변할 때, 지정한 transition효과 적용여부. show()/hide()는 해당 값과 관계없이 transition 효과가 적용된다.
///
/// \param enableExitTransition 레벨변경시 스타일이 변할 때, 지정한 transition 효과 적용 여부. show()/hide()는 해당 값과 관계없이 transition 효과가 적용된다.
///
/// \param textLineStyles Poi의 Text Line별 스타일
///
- (nonnull instancetype)initWithTransition:(struct PoiTransition)transition enableEntranceTransition:(BOOL)enableEntranceTransition enableExitTransition:(BOOL)enableExitTransition textLineStyles:(NSArray<PoiTextLineStyle *> * _Nonnull)textLineStyles OBJC_DESIGNATED_INITIALIZER;
/// Poi가 show/hide하거나, 레벨변경에 의해 스타일이 변할 때 텍스트에 적용되는 애니메이션 효과 정의
/// seealso:
/// PoiTransition
@property (nonatomic, readonly) struct PoiTransition transition;
/// 레벨변경에 의해 스타일이 변할 때, transition 효과 적용 여부. false로 설정할 경우 설정한 transition이 적용되지 않는다.
/// 해당 값과 관계없이 Poi가 show()로 화면에 표시될 때는 기존에 설정한 transition대로 동작한다.
/// 기본값은 true.
@property (nonatomic, readonly) BOOL enableEntranceTransiion;
/// 레벨변경에 의해 스타일이 변할 때, transition 효과 적용 여부. false로 설정할 경우 설정한 transition이 적용되지 않는다.
/// 해당 값과 관계없이 Poi가 hide()로 화면에서 사라질 때는 기존에 설정한 transition대로 동작한다.
/// 기본값은 true.
@property (nonatomic, readonly) BOOL enableExitTransition;
/// Poi의 라인별 텍스트 스타일.
/// Poi에 멀티 라인의 텍스트를 넣을 경우, TextLine마다 TextLineStyle을 인덱스로 지정할 수 있다.
/// Poi에 두개 이상의 PoiText를 넣고, 각 PoiText에 생성한 PoiTextLineStyle의의 index를 지정한다.
@property (nonatomic, readonly, copy) NSArray<PoiTextLineStyle *> * _Nonnull textLineStyles;
/// text layouts(for obj-c)
- (NSArray<NSNumber *> * _Nonnull)textLayouts SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolygonShape를 구성할 때 사용하는 Polygon 클래스.
/// 폴리곤은 단독으로 Map에 추가할 수 없으며, Shape에 종속되는 객체이다.
/// 하나의 외곽선과 hole을 넣어서 구성할 수 있다. 외곽선 point인 exterior ring과 폴리곤 내부 홀을 표시하는 holes로 구성된다.
/// exteriorRing, 즉 외곽선은 시계방향으로 CGPoint를 넣어야 하고, hole은 시계반대방향으로 CGPoint를 넣어야한다.
/// Polygon의 Point는 basePosition을 기준으로 한 실수 타입의  CGPoint 정점으로 구성한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK7Polygon")
@interface Polygon : NSObject
/// initializer
/// \param exteriorRing Polygon의 외곽선
///
/// \param holes Polygon의 hole 배열. hole이 없을경우 nil로 지정
///
/// \param styleIndex PolygonStyleSet에서 사용할 PolygonStyle 인덱스
///
- (nonnull instancetype)initWithExteriorRing:(NSArray<NSValue *> * _Nonnull)exteriorRing holes:(NSArray<NSArray<NSValue *> *> * _Nullable)holes styleIndex:(NSUInteger)styleIndex OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param exteriorRing Polygon의 외곽선
///
/// \param hole Polygon의 하나의 hole. hole이 없을경우 nil로 지정
///
/// \param styleIndex PolygonStyleSet에서 사용할 PolygonStyle 인덱스
///
- (nonnull instancetype)initWithExteriorRing:(NSArray<NSValue *> * _Nonnull)exteriorRing hole:(NSArray<NSValue *> * _Nullable)hole styleIndex:(NSUInteger)styleIndex;
/// Polygon의 외곽선.
/// 시계방향의 CGPoint 배열로 구성한다.
@property (nonatomic, readonly, copy) NSArray<NSValue *> * _Nonnull exteriorRing;
/// Polygon의 holes
/// 0개 이상으로 구성되며, 반시계방향의 CGPoint 배열로 구성한다.
@property (nonatomic, readonly, copy) NSArray<NSArray<NSValue *> *> * _Nullable holes;
/// PolygonStyleSet에서 사용할 표출 스타일 인덱스를 지정한다.
@property (nonatomic, readonly) NSUInteger styleIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 지도상에 특정 영역을 2d Polygon으로 표시하는 PolygonShape 클래스.
/// basePosition을 기준으로 정점을 구성한다.
/// PolygonShape를 추가하기 위해서는 먼저 KakaoMap에 ShapeLayer를 추가한 뒤, 해당 Layer에 PolygonShape를 추가할 수 있다.
/// show, hide, style변경 및 이동/회전이 가능하다.
/// PolygonShape는 사용자가 직접 생성할 수 없으며, PolygonShapeOptions class를 이용하여 Layer에 추가하면 해당 object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12PolygonShape")
@interface PolygonShape : NSObject <Shape>
/// PolygonShape를 보여준다.
- (void)show;
/// PolygonShape를 숨긴다.
- (void)hide;
/// PolygonShape의 style과 Data를 변경한다.
/// PolygonShape의 Style과 PolygonShape가 표시하는 polgyon Data를 변경하고자 할 때 사용한다.
/// 단, polygon Data를 바꿀때는 해당 PolygonShape 객체가 가리키는 본질이 변하지 않을때만 사용한다.
/// 즉 전혀 다른 PolygonShape 객체일때는 PolygonShape를 하나 더 만드는것을 권장한다.
/// \param styleID 변경할 styleID
///
/// \param polygons 업데이트 할 폴리곤 데이터.
///
- (void)changeStyleAndDataWithStyleID:(NSString * _Nonnull)styleID polygons:(NSArray<Polygon *> * _Nonnull)polygons;
/// shape가 속한 layerID
@property (nonatomic, readonly, copy) NSString * _Nullable layerID;
/// ShapeID.
@property (nonatomic, readonly, copy) NSString * _Nonnull shapeID;
/// Shape의 base Position
@property (nonatomic, readonly, strong) MapPoint * _Nonnull basePosition;
/// PolygonShape의 position
/// 새로운 position값으로 assign 할 경우, PolygonShape의 position값이 update된다.
@property (nonatomic, strong) MapPoint * _Nonnull position;
/// PolygonShape의 현재 orientation값
/// 새로운 orientation값으로 assign할 경우, PolygonShape의 orientation이 변경된다.
@property (nonatomic) double orientation;
/// PolygonShape가 현재 지도에 표시되는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolygonShape생성 옵션 클래스.
/// PolygonShape는 지도상의 특정 2d polygon을 표시할 때 사용한다. basePosition을 기준점으로 오프셋 좌표인 CGPoint 로 이루어진 하나 이상의 폴리곤으로 구성된다.
/// CGPoint로 이루어진 폴리곤을 받아 위경도 좌표계에 폴리곤을 표시한다.
/// PolygonShape에 속한 Polygon마다 StyleSet을 이용하여 다르게 표출할 수도 있다.
/// PolylineShape의 id를 별도로 지정하지 않는 경우, 내부적으로 자동으로 부여한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK19PolygonShapeOptions")
@interface PolygonShapeOptions : NSObject
/// initializer
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 값이 클수록 더 위에 그려진다.
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param shapeID Shape의 ID
///
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 값이 클수록 더 위에 그려진다.
///
- (nonnull instancetype)initWithShapeID:(NSString * _Nonnull)shapeID styleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// Shape의 ID
@property (nonatomic, readonly, copy) NSString * _Nullable shapeID;
/// Shape가 표출될 StyleID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
/// Shape의 렌더링 우선순위.
/// 높을수록 더 위에 그려지며, Shape type끼리만 유효하다.
/// 즉, zOrder = 0 인 Shape는 zOrder = 1 인 shape보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
/// shape의 base position.
@property (nonatomic, strong) MapPoint * _Nonnull basePosition;
/// Shape에 속한 폴리곤.
/// 1개 이상의 폴리곤으로 구성된다.
/// seealso:
/// Polygon
@property (nonatomic, copy) NSArray<Polygon *> * _Nonnull polygons;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolygonStyle 클래스.
/// PolygonShape의 스타일을 지정하기 위해 사용한다. 한 개 이상의 PerLevelPolygonStyle로 구성된다.
/// PerLevelPolygonStyle Unit 클래스를 추가하여 레벨별로 표출할 스타일을 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12PolygonStyle")
@interface PolygonStyle : NSObject
/// initializer
/// \param styles PolygonStyle을 구성할 단위레벨별 PerLevelPolygonStyle 배열
///
- (nonnull instancetype)initWithStyles:(NSArray<PerLevelPolygonStyle *> * _Nonnull)styles OBJC_DESIGNATED_INITIALIZER;
/// 추가한 ShapeStyle 배열
@property (nonatomic, readonly, copy) NSArray<PerLevelPolygonStyle *> * _Nonnull styles;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolygonStyleSet 클래스
/// Shape내부에 여러개의 폴리곤이 있을 때, PolygonStyle은 하나의 스타일을 적용하게 되면 여러개의 폴리곤에 일괄적으로 똑같은 스타일이 적용된다.
/// 반면 PolygonStyleSet은 PolygonShape 내부에 여러개의 폴리곤이 있을때, 각 폴리곤마다 다른 스타일을 적용할 수 있다.
/// 즉, 하나의 스타일을 추가하더라도 폴리곤마다 다르게 표출될 수 있게 정의할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK15PolygonStyleSet")
@interface PolygonStyleSet : NSObject
/// initializer
/// \param styleSetID StyleSet ID
///
- (nonnull instancetype)initWithStyleSetID:(NSString * _Nonnull)styleSetID OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// <ul>
///   <li>
///     parameters
///     <ul>
///       <li>
///         styleSetID: StyleSet ID
///       </li>
///       <li>
///         styles: PolygonStyleSet을 구성할 PolygonStyle 배열
///       </li>
///     </ul>
///   </li>
/// </ul>
- (nonnull instancetype)initWithStyleSetID:(NSString * _Nonnull)styleSetID styles:(NSArray<PolygonStyle *> * _Nonnull)styles;
/// styleSet에 추가 될 LevelStyle을 추가한다.
/// \param style 추가할 ShapeLevelStyle
///
- (void)addStyle:(PolygonStyle * _Nonnull)style;
/// styleSet ID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleSetID;
/// 추가할 ShapeStyles
@property (nonatomic, readonly, copy) NSArray<PolygonStyle *> * _Nonnull styles;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolylineShape를 구성할 때 사용하는 Polyline 클래스
/// 폴리라인은 단독으로 Map에 추가할 수 없으며, Shape에 종속되는 객체이다.
/// basePosition을 기준점으로 하는 2개 이상의 CGPoint로 만들어진 라인으로 구성된다. 폴리라인의 캡 스타일도 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8Polyline")
@interface Polyline : NSObject
/// Initializer
/// \param line Polyline을 구성하는 CGPoint 배열
///
/// \param styleIndex Polyline에 적용할 PolylineStyleSet에 속한 PolylineStyle의 index
///
- (nonnull instancetype)initWithLine:(NSArray<NSValue *> * _Nonnull)line styleIndex:(NSUInteger)styleIndex OBJC_DESIGNATED_INITIALIZER;
/// 2개 이상의 CGPoint로 구성된다.
@property (nonatomic, readonly, copy) NSArray<NSValue *> * _Nonnull line;
/// ShapeStyleSet에서 사용할 표출 인덱스를 지정한다.
@property (nonatomic, readonly) NSUInteger styleIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 지도상에 특정 선형을 2d Polyline으로 표시하는  PolylineShape 클래스.
/// basePosition을 기준으로 정점을 구성한다
/// PolylineShape를 추가하기 위해서는 먼저 KakaoMap에 ShapeLayer를 추가한 뒤, 해당 Layer에 PolylineShape를 추가할 수 있다.
/// show, hide, style변경 및 이동/회전이 가능하다.
/// PolylineShape는 사용자가 직접 생성할 수 없으며, PolylineShapeOptions class를 이용하여 Layer에 추가하면 해당 Object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK13PolylineShape")
@interface PolylineShape : NSObject <Shape>
/// PolylineShape를 보여준다.
- (void)show;
/// PolylineShape를 숨긴다.
- (void)hide;
/// PolylineShape의 style과 Data를 변경한다.
/// PolylineShape의 style과 표시하는 polyline Data를 변경하고자 할 때 사용한다. 단, polyline Data를 바꿀때는 해당 PolylineShape 객체가 가리키는 본질이 변하지 않을때만 사용한다. 즉 전혀 다른 PolylineShape 객체일때는 PolylineShape를 하나 더 만드는것을 권장한다.
/// \param styleID 변경할 styleID
///
/// \param lines 업데이트 할 폴리라인 데이터.
///
- (void)changeStyleAndDataWithStyleID:(NSString * _Nonnull)styleID lines:(NSArray<Polyline *> * _Nonnull)lines;
/// Shape가 속한 layerID
@property (nonatomic, readonly, copy) NSString * _Nullable layerID;
/// Shape의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull shapeID;
/// Shape의 base Position
@property (nonatomic, readonly, strong) MapPoint * _Nonnull basePosition;
/// PolylineShape의 position
/// 새로운 값을 assign 하면, 해당 PolylineShape의 position이 업데이트된다.
@property (nonatomic, strong) MapPoint * _Nonnull position;
/// PolylineShape의 Orientation (radian)
/// 새로운 orientation값을 assign하면, PolylineShape의 orientation 값이 업데이트된다.
@property (nonatomic) double orientation;
/// PolylineShape가 현재 지도에 표시되는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolylineShape생성 옵션 클래스
/// PolylineShape는 지도상의 특정 2d polyline을 표시할 때 사용한다. basePosition을 기준점으로 오프셋 좌표인 CGPoint로 이루어진 하나 이상의 폴리라인으로 구성된다.
/// CGPoint로 이루어진 폴리라인을 받아 위경도 좌표계에 폴리라인을 표시한다.
/// Style은 PolylineShape에 속한 Polyline마다 StyleSet을 이용하여 다르게 표출할수도 있다.
/// PolylineShape의 id를 별도로 지정하지 않는 경우, 내부적으로 자동으로 부여한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK20PolylineShapeOptions")
@interface PolylineShapeOptions : NSObject
/// initializer
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 높을수록 더 위에 그려진다.
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param shapeID Shape의 ID
///
/// \param styleID 사용할 ShapeStyle ID
///
/// \param zOrder Shape의 렌더링 우선순위. 높을수록 더 위에 그려진다.
///
- (nonnull instancetype)initWithShapeID:(NSString * _Nonnull)shapeID styleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// Shape의 ID
@property (nonatomic, readonly, copy) NSString * _Nullable shapeID;
/// Shape가 표출될 StyleID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
/// Shape의 렌더링 우선순위.
/// 높을수록 더 위에 그려지며, Shape type끼리만 유효하다.
/// 즉, zOrder = 0 인 Shape는 zOrder = 1 인 shape보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
/// shape의 base position
@property (nonatomic, strong) MapPoint * _Nonnull basePosition;
/// Shape에 속한 Polyline 배열
/// 1개 이상의 폴리라인으로 구성된다.
/// seealso:
/// Polyline
@property (nonatomic, copy) NSArray<Polyline *> * _Nonnull polylines;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolylineStyle 클래스.
/// PolylineShape를 레벨별로 다른 스타일로 표출하고자 할 때 사용한다.
/// PerLevelPolylineStyle Unit 클래스를 추가하여 레벨별로 표출할 스타일을 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK13PolylineStyle")
@interface PolylineStyle : NSObject
/// initializer
/// \param styles PolylineStyle을 구성할 단위레벨별 PerLevelPolylineStyle 배열
///
- (nonnull instancetype)initWithStyles:(NSArray<PerLevelPolylineStyle *> * _Nonnull)styles OBJC_DESIGNATED_INITIALIZER;
/// 추가한 PerLevelPolylineStyle 배열
@property (nonatomic, readonly, copy) NSArray<PerLevelPolylineStyle *> * _Nonnull styles;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PolylineStyleSet 클래스
/// Shape 내부에 여러개의 Polyline이 존재할 경우, PolylineStyle은 Shape 내부 여러개의 폴리라인에 똑같은 스타일로 일괄적으로 적용된다.
/// 반면 PolylineStyleSet은 PolylineShape 내부에 여러개의 폴리라인이 있을 때, 각 폴리라인마다 다른 스타일을 적용할 수 있다.
/// 즉, 하나의 스타일을 추가하더라도 폴리곤마다 다르게 표출할 수 있도록 정의할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK16PolylineStyleSet")
@interface PolylineStyleSet : NSObject
/// Initializer
/// \param styleSetID styleSet ID
///
- (nonnull instancetype)initWithStyleSetID:(NSString * _Nonnull)styleSetID OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param styleSetID styleSet ID
///
/// \param styles PolylineStyleSet을 구성할 PolylineStyle 배열
///
/// \param capType Polyline에 시작/끝지점에 표시될 capType 지정. 스타일셋에 등록된 모든 PolylineStyle은 일괄적으로 이 capType이 적용된다.
///
- (nonnull instancetype)initWithStyleSetID:(NSString * _Nonnull)styleSetID styles:(NSArray<PolylineStyle *> * _Nonnull)styles capType:(PolylineCapType)capType;
/// styleSet에 추가될 LevelStyle을 추가한다.
/// \param style 추가할 style
///
- (void)addStyle:(PolylineStyle * _Nonnull)style;
/// styleSet ID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleSetID;
/// 추가할 shapeStyles
@property (nonatomic, readonly, copy) NSArray<PolylineStyle *> * _Nonnull styles;
/// 해당 스타일을 적용한 Polyline의 시작/끝지점에 표시될 capType
/// seealso:
/// PolylineCapType
@property (nonatomic, readonly) PolylineCapType capType;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Primitive 정점을 구성하는 유틸리티 클래스
/// Circle, Rectangle을 구성할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10Primitives")
@interface Primitives : NSObject
/// wgs84 좌표계 상의 두 점 사이의 거리를 구한다.
/// \param p1 첫번째 점
///
/// \param p2 두번째 점
///
///
/// returns:
/// 두 점 사이의 거리(meter)
+ (double)distanceWithP1:(MapPoint * _Nonnull)p1 p2:(MapPoint * _Nonnull)p2 SWIFT_WARN_UNUSED_RESULT;
/// CirclePoint를 가져온다.
/// \param radius Circle의 반지름(meter)
///
/// \param numPoints circle을 구성할 포인트 개수.
///
/// \param cw 시계방향으로 구성할지에 대한 여부. false인경우 시계반대방향으로 리턴된다.
///
///
/// returns:
/// Circle형태의 CGPoint 배열
+ (NSArray<NSValue *> * _Nonnull)getCirclePointsWithRadius:(double)radius numPoints:(NSInteger)numPoints cw:(BOOL)cw SWIFT_WARN_UNUSED_RESULT;
/// CirclePoint를 가져온다.
/// \param radius Circle의 반지름(meter)
///
/// \param numPoints circle을 구성할 포인트 개수.
///
/// \param cw 시계방향으로 구성할지에 대한 여부. false인경우 시계반대방향으로 리턴된다.
///
/// \param center CirclePoint를  지도 좌표계로 생성하기 위해 중심점을 지정
///
///
/// returns:
/// Circle형태의 MapPoint배열
+ (NSArray<MapPoint *> * _Nonnull)getCirclePointsWithRadius:(double)radius numPoints:(NSInteger)numPoints cw:(BOOL)cw center:(MapPoint * _Nonnull)center SWIFT_WARN_UNUSED_RESULT;
/// RectanglePoint를 가져온다.
/// \param width Rectangle의 너비(meter)
///
/// \param height Rectnagle의 높이(meter)
///
/// \param cw 시계방향으로 구성할지에 대한 여부. false인경우 시계반대방향으로 리턴된다.
///
///
/// returns:
/// Rectangle형태의 CGPoint 배열
+ (NSArray<NSValue *> * _Nonnull)getRectanglePointsWithWidth:(double)width height:(double)height cw:(BOOL)cw SWIFT_WARN_UNUSED_RESULT;
/// RectanglePoint를 가져온다.
/// \param width Rectangle의 너비(meter)
///
/// \param height Rectnagle의 높이(meter)
///
/// \param cw 시계방향으로 구성할지에 대한 여부. false인경우 시계반대방향으로 리턴된다.
///
/// \param center Rectangle Point를  지도 좌표계로 생성하기 위해 중심점을 지정
///
///
/// returns:
/// Circle형태의 MapPoint 배열
+ (NSArray<MapPoint *> * _Nonnull)getRectanglePointsWithWidth:(double)width height:(double)height cw:(BOOL)cw center:(MapPoint * _Nonnull)center SWIFT_WARN_UNUSED_RESULT;
/// startPoint ~ endPoint까지 Curve Point를 생성한다.
/// \param startPoint 시작 point
///
/// \param endPoint 끝 point
///
/// \param isLeft 시작-끝을 기준으로 왼쪽으로 휘어지는 커브인지에 대한 여부. false인경우 오른쪽으로 휘어지는 커브 point를 생성한다.
///
///
/// returns:
/// 생성한 곡선 MapPoint 배열
+ (NSArray<MapPoint *> * _Nonnull)getCurvePointsWithStartPoint:(MapPoint * _Nonnull)startPoint endPoint:(MapPoint * _Nonnull)endPoint isLeft:(BOOL)isLeft SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class RoadviewLookAt;
@protocol RoadviewEventDelegate;

/// 로드뷰를 그리기 위한 클래스.
/// 로드뷰는 바로 그려지지 않고, 로드뷰지점 데이터를 요청하여 데이터가 수신되면 그려진다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8Roadview")
@interface Roadview : ViewBase
/// 로드뷰를 요청한다.
/// 요청 결과에 따라 이벤트가 발생된다.
/// \param position 로드뷰를 요청할 지점 위치.
///
/// \param panoID 파노라마 ID.
///
/// \param markers 로드뷰에 표시할 마커들. 없을 경우 nil.
///
/// \param lookAt 초기 로드뷰 진입시 바라볼 방향. 지정하지 않을 경우 nil. 지정하지 않을 경우 정북 수평방향을 바라본다.
///
- (void)requestRoadviewWithPosition:(MapPoint * _Nonnull)position panoID:(NSString * _Nullable)panoID markers:(NSArray<PanoramaMarker *> * _Nullable)markers lookAt:(RoadviewLookAt * _Nullable)lookAt;
/// 로드뷰 뷰와 연결된 지도 뷰를 지정한다.
/// 지도 뷰와 연결하면 지도 뷰가 회전하면 로드뷰 뷰도 회전하고, 로드뷰 지점 이동에 따라 지도 뷰도 이동한다.
/// \param viewName 연결할 지도 뷰의 이름. 해당 이름의 지도뷰가 없을 경우 아무 동작 없음.
///
- (void)linkMapView:(NSString * _Nonnull)viewName;
/// 로드뷰 뷰와 연결된 지도 뷰를 해제한다.
- (void)unlinkMapView;
/// 뷰를 다시 그린다.
- (void)refresh;
/// 로고의 위치를 지정한다.
/// 로고는 SpriteGUI 와 같은 방식으로 화면상의 특정위치에 고정적으로 표시되므로, 다른 GUI 와 겹치는 현상을 피하기 위해 로고의 위치를 이동시키는 데 사용한다.
/// 위치 지정방식은 SpriteGUI와 동일하다.
/// \param origin 로고의 alignment
///
/// \param position alignment 기준점으로부터의 offset
///
- (void)setLogoPositionWithOrigin:(struct GuiAlignment)origin position:(CGPoint)position;
/// 로드뷰 카메라의 pan값
@property (nonatomic, readonly) double pan;
/// 로드뷰 카메라의 tilt값
@property (nonatomic, readonly) double tilt;
/// 뷰의 활성화 상태
/// <code>true</code>인 경우 렌더링이 실행되며,<code>false</code>인 경우 렌더링을 하지 않는다.
@property (nonatomic) BOOL isEnabled;
/// 로드뷰 이벤트 delegate를 지정한다.
@property (nonatomic, strong) id <RoadviewEventDelegate> _Nullable eventDelegate;
@end



/// Roadview의 이벤트 delegate.
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK21RoadviewEventDelegate_")
@protocol RoadviewEventDelegate
@optional
/// 로드뷰의 크기가 변경되었을 때 발생.
/// \param roadview Roadview
///
- (void)roadviewDidResized:(Roadview * _Nonnull)roadview;
/// 파노라마가 갱신되었을 때 발생.
/// \param panoId 갱신된 파노라마 ID
///
- (void)panoramaUpdated:(NSString * _Nonnull)panoId;
/// 포커스 변경시 발생.
/// \param roadview Roadview
///
/// \param focus 포커스 상태
///
- (void)roadviewFocusDidChangedWithRoadview:(Roadview * _Nonnull)roadview focus:(BOOL)focus;
@required
/// 로드뷰 요청 결과 수신시 발생.
/// \param roadview Roadview
///
/// \param panoID 파노라마 ID
///
/// \param position 파노라마 지점 위치
///
- (void)roadviewResultDidReceivedWithRoadview:(Roadview * _Nonnull)roadview panoID:(NSString * _Nonnull)panoID position:(MapPoint * _Nonnull)position;
@optional
/// 로드뷰 요청 결과 결과없음 수신시 발생.
/// \param roadview Roadview
///
- (void)noRoadviewResult:(Roadview * _Nonnull)roadview;
/// 로드뷰 요청 실패시 발생.
/// \param roadview Roadview
///
- (void)roadviewRequestDidFailed:(Roadview * _Nonnull)roadview;
/// 잘못된 요청 (ex. index범위 밖의 과거사진 요청).
/// \param roadview Roadview
///
- (void)invalidRoadviewRequest:(Roadview * _Nonnull)roadview;
/// 로드뷰의 영역이 클릭되었을 때 호출.
/// \param roadview Roadview
///
/// \param point 클릭된 위치
///
- (void)roadviewDidTappedWithRoadview:(Roadview * _Nonnull)roadview point:(CGPoint)point;
@end


/// 로드뷰 viewInfo. Roadview로 view가 생성된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12RoadviewInfo")
@interface RoadviewInfo : ViewInfo
@end


@interface RoadviewInfo (SWIFT_EXTENSION(KakaoMapsSDK))
- (nonnull instancetype)initWithViewName:(NSString * _Nonnull)viewName viewInfoName:(NSString * _Nonnull)viewInfoName enabled:(BOOL)enabled;
@end


/// 로드뷰가 화면에 표시될 때 카메라가 바라보는 방향을 지정하기 위한 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK14RoadviewLookAt")
@interface RoadviewLookAt : NSObject
/// Initializer
/// \param pan 카메라 회전각(radian, 정북기준 시계방향).
///
/// \param tilt 카메라 기울임각(radian, 지평선과 평행 기준, 양수값이 지면방향)
///
- (nonnull instancetype)initWithPan:(double)pan tilt:(double)tilt OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param position 카메라가 바라볼 위치
///
- (nonnull instancetype)initWithPosition:(MapPoint * _Nonnull)position OBJC_DESIGNATED_INITIALIZER;
/// 카메라 회전각(radian, 정북기준 시계방향).
@property (nonatomic, readonly) double pan;
/// 카메라 기울임각(radian, 지평선과 평행 기준, 양수값이 지면방향)
@property (nonatomic, readonly) double tilt;
/// 카메라가 바라볼 위치
@property (nonatomic, readonly, strong) MapPoint * _Nullable position;
/// RoadviewLookAt Type.
@property (nonatomic, readonly) RoadviewLookAtType lookAtType;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class RouteSegment;

/// 맵에 표시되는 Route를 나타내는 클래스.
/// Route는 Polyline/MapPolyline 과 마찬가지로 선을 그리는 기능을 하지만 경로선을 표현하기 위한 기능을 추가로 가지고 있다.
/// 예를 들면 레벨별로 디테일 조절 처리가 들어간다. 즉, 상위 레벨일수록 RoutePoints가 rough하게 표시되며, 하위레벨일수록 자세하게 표시된다.
/// 따라서 맵에 경로를 표시할 때 사용하기에 적절하다. show/hide/style 변경 등이 가능하다.
/// 하나 이상의 RouteSegment로 이루어진다. Route는 레벨별로 디테일 조절 처리가 들어간다.
/// Route를 추가하기 위해서는 먼저 KakaoMap에 RouteLayer를 추가한 뒤, 해당 Layer에 Route를 추가한다.
/// Route는 사용자가 직접 생성할 수 없으며, RouteLayer를 통해 해당 Object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK5Route")
@interface Route : NSObject
/// Route를 보여준다.
- (void)show;
/// Route를 숨긴다.
- (void)hide;
/// Route의 style과 Data를 변경한다.
/// Route의 Style과 함께 Route가 표시하는 RouteSegment Data를 변경하고자 할 때 사용한다. 단, RouteSegment Data를 바꿀때는 해당 Route 객체가 가리키는 본질이 변하지 않을때만 사용한다. 즉 전혀 다른 Route 객체일때는 Route를 하나 더 만드는것을 권장한다.
/// ex. 경로 탐색 결과를 보여주고, 교통 정보가 업데이트 되어서 스타일과 segment가 바뀌어야 하는 경우.
/// ex. 경로 탐색 결과를 여러개 보여주고, disabled route <-> enabled route 로 style 전환이 필요한 경우.
/// \param styleID 변경할 styleID
///
/// \param segments 변경할 route segments data.
///
- (void)changeStyleAndDataWithStyleID:(NSString * _Nonnull)styleID segments:(NSArray<RouteSegment *> * _Nonnull)segments;
/// Route의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull routeID;
/// Route가 속한 Layer의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// Route의 렌더링 우선순위. 값이 클수록 위에 그려진다.
/// 새로운 zOrder로 assgin하면, 해당 Route의 zOrder가 업데이트된다.
/// zOrder = 0인 Route는 zOrder = 1 인 Route보다 아래에 그려진다.
@property (nonatomic) NSInteger zOrder;
/// Route가 표출되고있는지에 대한 여부를 가져온다.
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class RouteOptions;

/// Route객체를 관리하는 단위인 RouteLayer 클래스.
/// Route를 추가/삭제 등 관리할 수 있으며, 일종의 그룹처럼 관리가 가능하다.
/// 사용자가 직접 객체를 생성할 수 없으며, RouteManager를 통해 객체를 간접적으로 생성할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10RouteLayer")
@interface RouteLayer : NSObject
/// 현재 layer에 속한 Route를 일괄적으로 지운다.
- (void)clearAllRoutes;
/// 현재 Layer에 Route를 추가한다.
/// 하나의 레이어안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// seealso:
/// RouteSegment
/// \param option 추가할 segment의 option.
///
/// \param callback Route 추가가 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성한 Route 객체
- (Route * _Nullable)addRouteWithOption:(RouteOptions * _Nonnull)option callback:(void (^ _Nullable)(Route * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정 Route를 제거한다.
/// \param routeID 제거할 routeID
///
/// \param callback Route제거가 완료되었을 때, 호출할 callback(optional)
///
- (void)removeRouteWithRouteID:(NSString * _Nonnull)routeID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 특정 Route를 제거한다.
/// \param routeIDs 제거할 routeID 배열
///
/// \param callback Route제거가 완료되었을 때, 호출할 callback(optional)
///
- (void)removeRoutesWithRouteIDs:(NSArray<NSString *> * _Nonnull)routeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 특정 Route를 보여준다.
/// \param routeIDs 보여줄 routeID 배열
///
- (void)showRoutesWithRouteIDs:(NSArray<NSString *> * _Nonnull)routeIDs;
/// 현재 Layer에 속한 특정 Route를 숨긴다.
/// \param routeIDs 숨길 routeID 배열
///
- (void)hideRoutesWithRouteIDs:(NSArray<NSString *> * _Nonnull)routeIDs;
/// 현재 Layer에 속한 Route를 가져온다.
/// \param routeID 가져올 routeID
///
///
/// returns:
/// ID에 해당하는 Route객체. 없을경우 nil
- (Route * _Nullable)getRouteWithRouteID:(NSString * _Nonnull)routeID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 다수의 Route를 가져온다.
/// \param routeIDs 가져올 routeID 배열
///
///
/// returns:
/// ID에 해당하는 Route객체 배열. 없을경우 nil
- (NSArray<Route *> * _Nullable)getRoutesWithRouteIDs:(NSArray<NSString *> * _Nonnull)routeIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 레이어에 속한 모든 Route를 가져온다.
///
/// returns:
/// 현재 Layer에 추가되어있는 모든 Route 객체 배열
- (NSArray<Route *> * _Nullable)getAllRoutes SWIFT_WARN_UNUSED_RESULT;
/// RouteLayer ID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// RouteLayer의 visible 상태.
/// layer의 on/off 상태를 나타내며, layer에 속한 객체의 show/hide는 별도로 동작시켜야한다.
/// 즉, layer의 visible이 true여도 layer에 속한 객체의 show를 호출해야 보이고, visible이 false라면 layer에 속한 객체는 화면에 표시되지 않는다.
@property (nonatomic) BOOL visible;
/// RouteLayer의 렌더링 우선순위
/// 값이 클수록 위에 그려진다. 같은 RouteLayer끼리만 유효하다.
/// 즉, zOrder = 0 인 RouteLayer에 속한 Route는 zOrder = 1 인 RouteLayer에 속한 Route보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class RouteStyleSet;

/// KakaoMap에서 Route 객체를 관리하기 위한 클래스
/// RotueLayer의 추가/삭제 등의 관리와 Route를 표시하기 위한 Style 추가가 가능하다.
/// KakaoMap에 종속적이므로 KakaoMap이 삭제된 뒤에도 사용하지 않도록 주의하여야 한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12RouteManager")
@interface RouteManager : NSObject
/// RouteStyleSet을 추가한다.
/// Route가 여러개의 RouteSegment로 구성되는 경우, 하나의 스타일셋으로 segment별로 다르게 표시할 수 있다. 같은 styleID로 추가하더라도 overwrite되지 않는다.
/// seealso:
/// RouteStyle
/// \param styleSet 추가할 RouteStyleSet
///
- (void)addRouteStyleSet:(RouteStyleSet * _Nonnull)styleSet;
/// RouteLayer를 추가한다.
/// Route관리할 수 있는 단위인 RouteLayer를 추가한다. 이미 KakaoMap에 추가되어있는 ID와 동일한 layer를 추가하고자 하는 경우, 기존 객체를 리턴한다.
/// \param layerID 추가할 routeLayer ID
///
/// \param zOrder layer의 렌더링 우선순위. 값이 높을수록 위에 그려진다.
///
///
/// returns:
/// 생성한 RouteLayer 객체
- (RouteLayer * _Nullable)addRouteLayerWithLayerID:(NSString * _Nonnull)layerID zOrder:(NSInteger)zOrder SWIFT_WARN_UNUSED_RESULT;
/// KakaoMap에 추가한 RouteLayer를 가져온다.
/// \param layerID 가져올 RouteLayer ID
///
///
/// returns:
/// ID에 해당하는 routerLayer 객체. 없을경우 nil 리턴
- (RouteLayer * _Nullable)getRouteLayerWithLayerID:(NSString * _Nonnull)layerID SWIFT_WARN_UNUSED_RESULT;
/// KakaoMap에 추가한 RouteLayer를 제거한다.
/// \param layerID 제거할 layer ID
///
- (void)removeRouteLayerWithLayerID:(NSString * _Nonnull)layerID;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Route를 생성하기 위한 Route 생성 옵션 클래스.
SWIFT_CLASS("_TtC12KakaoMapsSDK12RouteOptions")
@interface RouteOptions : NSObject
/// Initializer
/// \param styleID RouteStyleSet ID
///
/// \param zOrder Route 렌더링 우선순위. 값이 클수록 위에 그려진다.
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param routeID Route 고유 ID
///
/// \param styleID RouteStyleSet ID
///
/// \param zOrder Route 렌더링 우선순위. 값이 클수록 위에 그려진다.
///
- (nonnull instancetype)initWithRouteID:(NSString * _Nonnull)routeID styleID:(NSString * _Nonnull)styleID zOrder:(NSInteger)zOrder OBJC_DESIGNATED_INITIALIZER;
/// Route ID. 생성시 별도로 지정하지 않는 경우, 내부적으로 id를 자동으로 부여한다.
@property (nonatomic, readonly, copy) NSString * _Nullable routeID;
/// Route가 사용할 styleSet ID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
/// Route 렌더링 우선순위
/// 값이 클수록 위에 그려진다. 같은 Route끼리만 유효하다.
/// 즉, zOrder = 0 인 Route는 zOrder = 1 인 Route보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
/// Route를 구성하는 RouteSegment 배열.
/// Route는 하나 이상의 RouteSegment로 이루어진다. RouteSegment는 두개 이상의 정점으로 이루어지며, 각 Segment마다 StyleSet의 index를 부여하여 RouteSegment단위로 스타일을 다르게 표시할 수 있다.
/// seealso:
/// RouteSegment
@property (nonatomic, copy) NSArray<RouteSegment *> * _Nonnull segments;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// RoutePattern 클래스
/// Route에 표시할 패턴을 정의하는 클래스.
SWIFT_CLASS("_TtC12KakaoMapsSDK12RoutePattern")
@interface RoutePattern : NSObject
/// Initializer
/// \param pattern 사용할 패턴 이미지
///
/// \param distance 패턴이 표시되는 간격
///
/// \param symbol 반복적으로 그려지는 패턴 외에, 한번 표시되어 segment의 속성을 표현하는 심볼
///
/// \param pinStart 패턴의 시작지점을 고정할지에 대한 여부
///
/// \param pinEnd 패턴의 끝지점을 고정할지에 대한 여부
///
- (nonnull instancetype)initWithPattern:(UIImage * _Nonnull)pattern distance:(float)distance symbol:(UIImage * _Nullable)symbol pinStart:(BOOL)pinStart pinEnd:(BOOL)pinEnd OBJC_DESIGNATED_INITIALIZER;
/// 사용할 패턴 이미지
@property (nonatomic, readonly, strong) UIImage * _Nullable pattern;
/// 패턴 이미지 외에 패턴의 속성을 표시할 심볼
@property (nonatomic, readonly, strong) UIImage * _Nullable symbol;
/// 패턴이 표시되는 간격
@property (nonatomic, readonly) float distance;
/// 패턴이 시작지점에 고정적으로 그려지게 하는 여부
@property (nonatomic, readonly) BOOL pinStart;
/// 패턴이 끝지점에 고정적으로 그려지게 하는 여부
@property (nonatomic, readonly) BOOL pinEnd;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Route를 나타내는 RouteSegment 클래스.
/// Route는 하나 이상의 segment로 구성되고, Segment는 두 개 이상의 라인 포인트로 이루어지며, 모든 라인 포인트를 순서대로 연결한 선으로 그려진다.
/// 각 RouteSegment별로 다른 styleIndex를 적용하여 다르게 표시할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12RouteSegment")
@interface RouteSegment : NSObject
/// Initializer
/// \param points Segment를 구성하는 라인 포인트 배열
///
/// \param styleIndex Segment를 표시할 style의 인덱스
///
- (nonnull instancetype)initWithPoints:(NSArray<MapPoint *> * _Nonnull)points styleIndex:(NSUInteger)styleIndex OBJC_DESIGNATED_INITIALIZER;
/// 라인 포인트 배열
@property (nonatomic, readonly, copy) NSArray<MapPoint *> * _Nonnull points;
/// segment를 표시할 스타일 인덱스
@property (nonatomic, readonly) NSUInteger styleIndex;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// RouteStyle 클래스.
/// Route의 style을 지정하기 위해 사용한다. 한개 이상의 PerLevelRouteStyle 로 구성된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10RouteStyle")
@interface RouteStyle : NSObject
/// initializer
/// \param styles RouteStyle을 구성할 단위레벨별 PerLevelRouteStyle 배열
///
- (nonnull instancetype)initWithStyles:(NSArray<PerLevelRouteStyle *> * _Nonnull)styles OBJC_DESIGNATED_INITIALIZER;
/// 추가한 PerLevelRouteStyle 배열
@property (nonatomic, readonly, copy) NSArray<PerLevelRouteStyle *> * _Nonnull styles;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// RouteStyleSet 클래스
/// Route를 구성하는 여러개의 RouteSegment마다 다른 스타일을 적용하고자 할 때 사용한다. StyleSet에 추가한 스타일의 인덱스를 RouteSegment마다 지정할 수 있다.
/// 또한 RouteSegment마다 사용하고자 하는 Route Pattern 또한 해당 클래스에서 추가 할 수 있다. 패턴도 style과 마찬가지로 인덱스로 지정할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK13RouteStyleSet")
@interface RouteStyleSet : NSObject
/// Initializer
/// \param styleID StyleID
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param styleID StyleSet ID
///
/// \param styles RouteStyleSet을 구성할 RouteStyle 배열
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID styles:(NSArray<RouteStyle *> * _Nonnull)styles;
/// styleSet에 추가할 LevelStyle을 추가한다.
/// seealso:
/// RouteStyle
/// \param style 추가할 RouteStyle
///
- (void)addStyle:(RouteStyle * _Nonnull)style;
/// StyleSet에 RoutePattern을 추가한다.
/// seealso:
/// RoutePattern
/// \param pattern 추가하고자 하는 패턴
///
- (void)addPattern:(RoutePattern * _Nonnull)pattern;
/// styleSet ID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleSetID;
/// 추가한 RouteStyle 배열
@property (nonatomic, readonly, copy) NSArray<RouteStyle *> * _Nonnull styles;
/// 추가한 RoutePattern의 배열
@property (nonatomic, readonly, copy) NSArray<RoutePattern *> * _Nonnull patterns;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class ScaleAlphaAnimationKeyFrame;

/// AnimationEffect중 Animation 시간동안 지정된 Keyframe 에 따라 회전 변환을 수행하는 애니메이션 효과.
/// Poi에 적용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK25ScaleAlphaAnimationEffect")
@interface ScaleAlphaAnimationEffect : KeyFrameAnimationEffect
/// Initializer
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// 애니메이션 키프레임을 추가한다.
/// \param frame 추가할 키프레임.
///
- (void)addKeyframe:(ScaleAlphaAnimationKeyFrame * _Nonnull)frame;
@end


/// ScaleAlphaAnimation 을 구성하기 위해 하나의 keyframe을 구성하기 위한 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK27ScaleAlphaAnimationKeyFrame")
@interface ScaleAlphaAnimationKeyFrame : AnimationKeyFrame
/// Initializer
/// \param scale 확대변환 값. 1.0 기준 확대축소값.
///
/// \param alpha 투명도 값 0.0 ~ 1.0
///
/// \param interpolation 프레임 시간, 보간 방법.
///
- (nonnull instancetype)initWithScale:(struct Vector2)scale alpha:(float)alpha interpolation:(struct AnimationInterpolation)interpolation OBJC_DESIGNATED_INITIALIZER;
/// 투명도 값. 0.0~1.0
@property (nonatomic) float alpha;
/// 확대축소변환. 1.0 기준 확대값.
@property (nonatomic) struct Vector2 scale;
@end

@class ScaleAnimationKeyFrame;

/// AnimationEffect중 Animation 시간동안 지정된 Keyframe 에 따라 회전 변환을 수행하는 애니메이션 효과.
/// Poi에 적용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK20ScaleAnimationEffect")
@interface ScaleAnimationEffect : KeyFrameAnimationEffect
/// Initializer
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// 애니메이션 키프레임을 추가한다.
/// \param frame 추가할 키프레임.
///
- (void)addKeyframe:(ScaleAnimationKeyFrame * _Nonnull)frame;
@end


/// ScaleAnimation 을 구성하기 위해 하나의 keyframe을 구성하기 위한 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK22ScaleAnimationKeyFrame")
@interface ScaleAnimationKeyFrame : AnimationKeyFrame
/// Initializer
/// \param scale 확대변환 값. 1.0 기준 확대축소값.
///
/// \param interpolation 프레임 시간, 보간 방법.
///
- (nonnull instancetype)initWithScale:(struct Vector2)scale interpolation:(struct AnimationInterpolation)interpolation OBJC_DESIGNATED_INITIALIZER;
/// 확대축소변환. 1.0 기준 확대값.
@property (nonatomic) struct Vector2 scale;
@end



/// ShapeAnimation을 생성할 때 Animation Effect 종류를 정의하는 프로토콜.
SWIFT_PROTOCOL("_TtP12KakaoMapsSDK20ShapeAnimationEffect_")
@protocol ShapeAnimationEffect
/// 애니메이션의 지속시간,  프레임간의 보간 방법등을 지정
@property (nonatomic) struct AnimationInterpolation interpolation;
/// 애니메이션 종료시 대상 객체를 숨길지 여부를 지정.
@property (nonatomic) BOOL hideAtStop;
/// 애니메이션 재생 횟수.
@property (nonatomic) NSUInteger playCount;
@end


/// Shape에 애니메이션 효과를 주기 위한 Animator 클래스.
/// Animator를 생성해서 애니메이션 효과를 주고자 하는 Shape를 Animator에 넣어서 animator를 동작시키는 방식이다.
/// Animator는 사용자가 직접 생성할 수 없으며, ShapeManager를 통해서만 생성한 객체를 받아서 사용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK13ShapeAnimator")
@interface ShapeAnimator : NSObject <Animator>
/// Animator를 동작시킨다.
/// Animator에 추가된 Shape가 없으면 start함수는 동작하지 않는다. start를 호출한 이후에는 Animator에   Shape를 추가하거나 지울 수 없다.
/// 추가하고자 하는 경우, stop을 호출하고 추가해야한다.
/// start 호출 이후 애니메이션이 끝나면 Animator에 추가된 Shape는 비워지므로, 다시 start를 호출하려면 Shape를 추가해야한다.
/// Shape Interface에 있는 이동/회전등의 동작은 Animator가 start되면 멈춘다.
- (void)start;
/// Animator의 동작을 멈춘다.
/// stop이 호출되면 다시 애니메이션이 끝난것으로 간주되어 Animator에 속한 Shape는 모두 비워지므로, Animator를 다시 동작시키리면 다시 Shape를 Animator에 추가해야한다.
- (void)stop;
/// Animator 의 종료 콜백을 지정한다. Start 된 애니메이션이 종료되거나 stop이 호출되면 지정한 callback 이 호출된다. nil 로 지정해서 기존에 지정했던 callback을 제거할 수 있다. 기본값 nil.
/// \param callback Animator에 추가할 종료 콜백.
///
- (void)setStopCallback:(void (^ _Nullable)(id <Animator> _Nullable))callback;
/// Animator에 MapPolygonShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 MapPolygonShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 MapPolygonShape를 추가할 수 없다.
/// \param shape Animator에 추가할 MapPolygonShape
///
- (void)addMapPolygonShape:(MapPolygonShape * _Nonnull)shape;
/// Animator에 여러개의 MapPolygonShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 MapPolygonShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 MapPolygonShape를 추가할 수 없다.
/// \param shapes Animator에 추가할 MapPolygonShape 배열
///
- (void)addMapPolygonShapes:(NSArray<MapPolygonShape *> * _Nonnull)shapes;
/// Animator에 PolygonShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 PolygonShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 PolygonShape를 추가할 수 없다.
/// \param shape Animator에 추가할 PolygonShape
///
- (void)addPolygonShape:(PolygonShape * _Nonnull)shape;
/// Animator에 여러개의 PolygonShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 PolygonShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 PolygonShape를 추가할 수 없다.
/// \param shapes Animator에 추가할 PolygonShape 배열
///
- (void)addPolygonShapes:(NSArray<PolygonShape *> * _Nonnull)shapes;
/// Animator에 MapPolylineShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 MapPolylineShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 MapPolylineShape를 추가할 수 없다.
/// \param shape Animator에 추가할 MapPolylineShape
///
- (void)addMapPolylineShape:(MapPolylineShape * _Nonnull)shape;
/// Animator에 여러개의 MapPolylineShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 MapPolylineShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 MapPolylineShape를 추가할 수 없다.
/// \param shapes Animator에 추가할 MapPolylineShape 배열
///
- (void)addMapPolylineShapes:(NSArray<MapPolylineShape *> * _Nonnull)shapes;
/// Animator에 PolylineShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 PolylineShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 PolylineShape를 추가할 수 없다.
/// \param shape Animator에 추가할 PolylineShape
///
- (void)addPolylineShape:(PolylineShape * _Nonnull)shape;
/// Animator에 여러개의 PolylineShape를 추가한다.
/// 등록한 Animation에 동작시키고자 하는 PolylineShape를 추가한다. start()를 호출한 이후에는 애니메이션이 끝나기 전까지 PolylineShape를 추가할 수 없다.
/// \param shapes Animator에 추가할 PolylineShape 배열
///
- (void)addPolylineShapes:(NSArray<PolylineShape *> * _Nonnull)shapes;
/// Animator에 추가한 shape를 모두 지운다.
/// start() 호출 이후에는 동작하지 않는다.
- (void)clearAllShapes;
/// 추가한 animatorID
@property (nonatomic, readonly, copy) NSString * _Nonnull animatorID;
/// Animator 동작이 완료되고 나면 Animator에 추가된 폴리곤을 사라지게 할 지에 대한 여부
@property (nonatomic) BOOL hideAtStop;
/// Animator 시작 여부
@property (nonatomic, readonly) BOOL isStart;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Shape를 관리하는 단위인 ShapeLayer 클래스.
/// Shape를 추가/삭제 등 관리할 수 있으며, 일종의 그룹처럼 관리가 가능하다.
/// 사용자가 직접 객체를 생성할 수 없으며, LabelManager를 통해 객체를 간접적으로 생성할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK10ShapeLayer")
@interface ShapeLayer : NSObject
/// ShapeLayer의 visible 상태.
/// layer의 on/off 상태를 나타내며, layer에 속한 객체의 show/hide는 별도로 동작시켜야한다.
/// 즉, layer의 visible이 true여도 layer에 속한 객체의 show를 호출해야 보이고, visible이 false라면 layer에 속한 객체는 화면에 표시되지 않는다.
@property (nonatomic) BOOL visible;
/// 현재 레이어에 속한 모든 PolygonShape, MapPolygonShape를 표시한다.
- (void)showAllPolygonShapes;
/// 현재 레이어에 속한 모든 PolygonShape, MapPolygonShape를 숨긴다.
- (void)hideAllPolygonShapes;
/// 현재 레이어에 속한 모든 PolylineShape, MapPolylineShape를 표시한다.
- (void)showAllPolylineShapes;
/// 현재 레이어에 속한 모든 PolylineShape, MapPolylineShape를 숨긴다..
- (void)hideAllPolylineShapes;
/// 현재 레이어에 속한 모든 Shape를 표시한다.
- (void)showAllShapes;
/// 현재 레이어에 속한 모든 Shape를 숨긴다.
- (void)hideAllShapes;
/// 현재 layer에 있는 모든 item을 일괄적으로 지운다.
- (void)clearAllShapes;
/// 현재 Layer에 MapPolygonShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 MapPolygonShape 옵션
///
/// \param callback MapPolygonShape객체가 생성이 완료됐을 때 호출할 콜백함수(optional)
///
///
/// returns:
/// 생성된 MapPolygonShape 객체
- (MapPolygonShape * _Nullable)addMapPolygonShape:(MapPolygonShapeOptions * _Nonnull)shapeOptions callback:(void (^ _Nullable)(MapPolygonShape * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 다수의 MapPolygonShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 MapPolygonShape 옵션 배열
///
/// \param callback 생성한 다수의 MapPolygonShape가 모두 생성이 완료되었을 때, 호출할 콜백함수(optional)
///
///
/// returns:
/// 생성된 MapPolygonShape 객체 배열
- (NSArray<MapPolygonShape *> * _Nullable)addMapPolygonShapes:(NSArray<MapPolygonShapeOptions *> * _Nonnull)shapeOptions callback:(void (^ _Nullable)(NSArray<MapPolygonShape *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정 MapPolygonShape를 지운다.
/// \param shapeID Layer에서 제거할 MapPolygonShape Id
///
/// \param callback Layer에서 해당 Shape제거가 완료되었을 때, 호출할 콜백함수(optional)
///
- (void)removeMapPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 다수의 MapPolygonShape를 지운다.
/// \param shapeID Layer에서 제거할 MapPolygonShape Id 배열
///
/// \param callback Layer에서 id에 해당하는 모든 shape제거가 완료되었을 때, 호출할 콜백함수(optional)
///
- (void)removeMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 특정 MapPolygonShape를 보여준다.
/// \param shapeIDs 보여줄 MapPolygonShape ID 배열
///
- (void)showMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 특정 MapPolygonShape를 숨긴다.
/// \param shapeIDs 숨길 MapPolygonShape ID 배열
///
- (void)hideMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 MapPolygonShape를 가져온다.
/// \param shapeID 가져올 MapPolygonShape ID
///
///
/// returns:
/// ID에 해당하는 MapPolygonShape 객체, 없을경우 nil.
- (MapPolygonShape * _Nullable)getMapPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 다수의 MapPolygonShape를 가져온다.
/// \param shapeIDs 가져올 MapPolygonShape ID 배열
///
///
/// returns:
/// ID에 해당하는 MapPolygonShape 객체 배열, 없을경우 nil.
- (NSArray<MapPolygonShape *> * _Nullable)getMapPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 MapPolygonShape를 가져온다.
///
/// returns:
/// 현재 Layer에 추가된 MapPolygonShape 배열
- (NSArray<MapPolygonShape *> * _Nullable)getAllMapPolygonShapes SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 PolygonShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 PolygonShape 옵션
///
/// \param callback PolygonShape객체가 생성이 완료됐을 때 호출할 콜백함수(optional)
///
///
/// returns:
/// 생성된 PolygonShape 객체
- (PolygonShape * _Nullable)addPolygonShape:(PolygonShapeOptions * _Nonnull)shapeOptions callback:(void (^ _Nullable)(PolygonShape * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 다수의 PolygonShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 PolygonShape 옵션 배열
///
/// \param callback PolygonShape객체가 생성이 완료됐을 때 호출할 콜백함수(optional)
///
///
/// returns:
/// 생성된 Shape 객체 배열
- (NSArray<PolygonShape *> * _Nullable)addPolygonShapes:(NSArray<PolygonShapeOptions *> * _Nonnull)shapeOptions callback:(void (^ _Nullable)(NSArray<PolygonShape *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정 PolygonShape를 지운다.
/// \param shapeID Layer에서 제거할 PolygonShape Id
///
/// \param callback Layer에서 해당 Shape제거가 완료되었을 때, 호출할 콜백함수(optional)
///
- (void)removePolygonShapeWithShapeID:(NSString * _Nonnull)shapeID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 다수의 PolygonShape를 지운다.
/// \param shapeID Layer에서 제거할 PolygonShape Id 배열
///
/// \param callback Layer에서 id에 해당하는 모든 shape제거가 완료되었을 때, 호출할 콜백함수(optional)
///
- (void)removePolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 특정 PolygonShape를 보여준다.
/// \param shapeIDs 보여줄 PolygonShape ID 배열
///
- (void)showPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 특정 PolygonShape를 숨긴다.
/// \param shapeIDs 숨길 PolygonShape ID 배열
///
- (void)hidePolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 PolygonShape를 가져온다.
/// \param shapeID 가져올 PolygonShape ID
///
///
/// returns:
/// ID에 해당하는 PolygonShape 객체, 없을경우 nil.
- (PolygonShape * _Nullable)getPolygonShapeWithShapeID:(NSString * _Nonnull)shapeID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 다수의 PolygonShape를 가져온다.
/// \param shapeIDs 가져올 PolygonShape ID 배열
///
///
/// returns:
/// ID에 해당하는 PolygonShape 객체 배열, 없을경우 nil.
- (NSArray<PolygonShape *> * _Nullable)getPolygonShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 PolygonShape를 가져온다.
///
/// returns:
/// 현재 Layer에 추가된 PolygonShape 배열
- (NSArray<PolygonShape *> * _Nullable)getAllPolygonShapes SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 MapPolylineShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 객체를 리턴한다.
/// \param shapeOptions 생성할 MapPolylineShape 옵션
///
/// \param callback 생성한 MapPolylineShape 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 MapPolylineShape 객체
- (MapPolylineShape * _Nullable)addMapPolylineShape:(MapPolylineShapeOptions * _Nonnull)shapeOptions callback:(void (^ _Nullable)(MapPolylineShape * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 다수의 MapPolylineShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 MapPolylineShape 옵션
///
/// \param callback 생성한 MapPolylineShape 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 MapPolylineShape객체 배열
- (NSArray<MapPolylineShape *> * _Nullable)addMapPolylineShapes:(NSArray<MapPolylineShapeOptions *> * _Nonnull)shapeOptions callback:(void (^ _Nullable)(NSArray<MapPolylineShape *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정 MapPolylineShape를 지운다.
/// \param shapeID Layer에서 제거할 MapPolylineShape ID
///
/// \param callback Layer에서 지정한 MapPolylineShape가 지워졌을 때, 호출할 callback(optional)
///
- (void)removeMapPolylineShapeWithShapeID:(NSString * _Nonnull)shapeID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 다수의 MapPolylineShape를 지운다.
/// \param shapeIDs Layer에서 제거할 MapPolylineShape ID 배열
///
/// \param callback Layer에서 지정한 MapPolylineShape가 모두 지워졌을 때, 호출할 callback(optional)
///
- (void)removeMapPolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 특정 MapPolylineShape를 보여준다.
/// \param shapeIDs 보여줄 MapPolylineShape ID 배열
///
- (void)showMapPolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 특정 MapPolylineShape를 숨긴다.
/// \param shapeIDs 숨길 MapPolylineShape ID 배열
///
- (void)hideMapPolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 MapPolylineShape를 가져온다.
/// \param shapeIDs 가져올 MapPolylineShape
///
///
/// returns:
/// ID에 해당하는 MapPolylineShape 객체. 없을 경우 nil
- (MapPolylineShape * _Nullable)getMapPolylineShapeWithShapeID:(NSString * _Nonnull)shapeID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 다수의 MapPolylineShape를 가져온다.
/// \param shapeIDs 가져올 MapPolylineShape ID
///
///
/// returns:
/// ID에 해당하는 MapPolylineShape 객체. 없을 경우 nil
- (NSArray<MapPolylineShape *> * _Nullable)getMapPolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 MapPolylineShape를 가져온다.
///
/// returns:
/// 현재 Layer에 추가되어있는 모든 MapPolylineShape 객체 배열
- (NSArray<MapPolylineShape *> * _Nullable)getAllMapPolylineShapes SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 PolylineShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 객체를 리턴한다.
/// \param shapeOptions 생성할 PolylineShape 옵션
///
/// \param callback 생성한 MapPolylineShape 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 PolylineShape 객체
- (PolylineShape * _Nullable)addPolylineShape:(PolylineShapeOptions * _Nonnull)shapeOptions callback:(void (^ _Nullable)(PolylineShape * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 다수의 PolylineShape를 추가한다.
/// 하나의 레이어 안에 중복 ID로 추가할 수 없으며, 기존에 같은 아이디가 존재할 경우 기존 객체를 리턴한다.
/// \param shapeOptions 생성할 PolylineShape 옵션
///
/// \param callback 생성한 MapPolylineShape 생성이 완료되었을 때, 호출할 callback(optional)
///
///
/// returns:
/// 생성된 PolylineShape 객체 배열
- (NSArray<PolylineShape *> * _Nullable)addPolylineShapes:(NSArray<PolylineShapeOptions *> * _Nonnull)shapeOptions callback:(void (^ _Nullable)(NSArray<PolylineShape *> * _Nullable))callback SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에서 특정 PolylineShape를 지운다.
/// \param shapeID Layer에서 제거할 PolylineShape ID
///
- (void)removePolylineShapeWithShapeID:(NSString * _Nonnull)shapeID callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에서 다수의 PolylineShape를 지운다.
/// \param shapeIDs Layer에서 제거할 PolylineShape ID 배열
///
/// \param callback Layer에서 지정한 PolylineShape가 모두 지워졌을 때, 호출할 callback(optional)
///
- (void)removePolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs callback:(void (^ _Nullable)(void))callback;
/// 현재 Layer에 속한 특정 PolylineShape를 보여준다.
/// \param shapeIDs 보여줄 PolylineShape ID 배열
///
- (void)showPolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 특정 PolylineShape를 숨긴다.
/// \param shapeIDs 숨길 PolylineShape ID 배열
///
- (void)hidePolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs;
/// 현재 Layer에 속한 PolylineShape를 가져온다.
/// \param shapeIDs 가져올 PolylineShapeID
///
///
/// returns:
/// ID에 해당하는 PolylineShape 객체. 없을 경우 nil
- (PolylineShape * _Nullable)getPolylineShapeWithShapeID:(NSString * _Nonnull)shapeID SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 다수의 PolylineShape를 가져온다.
/// \param shapeIDs 가져올 PolylineShapeID
///
///
/// returns:
/// ID에 해당하는 PolylineShape 객체. 없을 경우 nil
- (NSArray<PolylineShape *> * _Nullable)getPolylineShapesWithShapeIDs:(NSArray<NSString *> * _Nonnull)shapeIDs SWIFT_WARN_UNUSED_RESULT;
/// 현재 Layer에 속한 모든 PolylineShape를 가져온다.
///
/// returns:
/// 현재 Layer에 추가되어있는 모든 PolylineShape 객체 배열
- (NSArray<PolylineShape *> * _Nonnull)getAllPolylineShapes SWIFT_WARN_UNUSED_RESULT;
/// ShapeLayer의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// ShapeLayer의 렌더링 우선순위.
/// 높은 zOrder의 Layer에 속한 Shape가 더 위에 그려지며, ShapeLayer type끼리만 유효하다.
/// 즉, zOrder = 0 인 ShapeLayer에 속한 Shape는 zOrder = 1 인 ShapeLayer에 속한 Shape보다 아래에 그려진다.
@property (nonatomic, readonly) NSInteger zOrder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// KakaoMap에서 사용자 shape를 사용하고 관리하기 위한 클래스
/// ShapeLayer의 추가/삭제 등의 관리와 shape의 style, animator추가가 가능하다.
/// KakaoMap에 종속적이므로 KakaoMap이 삭제된 뒤에도 사용하지 않도록 주의하여야 한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK12ShapeManager")
@interface ShapeManager : NSObject
/// PolygonStyleSet을 추가한다.
/// PolygonShape의 Polygon이 여러개인 경우, Polygon마다 다른 스타일을 설정할 수 있다. 같은 styleID로 추가하더라도 overwrite되지 않는다.
/// seealso:
/// PolygonStyleSet
/// \param styles 추가할 PolygonStyleSet
///
- (void)addPolygonStyleSet:(PolygonStyleSet * _Nonnull)styles;
/// PolylineStyleSet을 추가한다.
/// PolylineShape의 Polyline이 여러개인 경우, Polyline마다 다른 스타일을 설정할 수 있다. 같은 styleID로 추가하더라도 overwrite되지 않는다.
/// seealso:
/// PolylineStyleSet
/// \param styles 추가할 PolylineStyleSet
///
- (void)addPolylineStyleSet:(PolylineStyleSet * _Nonnull)styles;
/// ShapeLayer를 추가한다.
/// Shape를 관리할 수 있는 단위인 ShapeLayer를 추가한다. 이미 KakaoMap에 추가되어있는 ID와 동일한 layer를 추가하고자 하는 경우, 기존 객체를 리턴한다.
/// seealso:
/// ShapeLayerPassType
/// \param layerID 추가할 shapeLayerID
///
/// \param zOrder layer의 렌더링 우선순위. 높을수록 위에 그려진다.
///
/// \param passType ShapeLayer의 passType. 해당 레이어에 추가한 Shape가 그려지는 순서를 지정할 수 있다.
///
///
/// returns:
/// 생성한 ShapeLayer 객체
- (ShapeLayer * _Nullable)addShapeLayerWithLayerID:(NSString * _Nonnull)layerID zOrder:(NSInteger)zOrder passType:(ShapeLayerPassType)passType SWIFT_WARN_UNUSED_RESULT;
/// KakaoMap에 추가한 ShapeLayer를 가져온다.
/// \param layerID 가져올 shapeLayerID
///
///
/// returns:
/// ID에 해당하는 shapeLayer객체. 없을경우 nil 리턴
- (ShapeLayer * _Nullable)getShapeLayerWithLayerID:(NSString * _Nonnull)layerID SWIFT_WARN_UNUSED_RESULT;
/// KakaoMap에 추가한 ShaeLayer를 제거한다.
/// \param layerID 제거할 layer의 ID
///
- (void)removeShapeLayerWithLayerID:(NSString * _Nonnull)layerID;
/// ShapeAnimator를 추가한다.
/// ShapeAnimator 객체는 사용자가 직접 생성할 수 없으며, Manager를 통해서만 생성이 가능하다. 이미 존재하는 AnimatorID로는 overwrite되지 않는다.
/// seealso:
/// AnimationInterpolation
/// seealso:
/// WaveAnimationEffect
/// \param animatorID ShapeAnimator ID
///
/// \param effect ShapeAnimationEffect type의 애니메이션 효과 지정
///
///
/// returns:
/// 생성된 Animator 객체
- (ShapeAnimator * _Nullable)addShapeAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID effect:(id <ShapeAnimationEffect> _Nonnull)effect SWIFT_WARN_UNUSED_RESULT;
/// 추가한 ShapeAnimator 객체를 제거한다.
/// \param animatorID 제거할 animatorID
///
- (void)removeShapeAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID;
/// 추가되어있는 모든 ShapeAnimaotr를 제거한다.
- (void)clearAllShapeAnimators;
/// 추가한 ShapeAnimator 객체를 가져온다.
/// \param animatorID 가져올 AnimatorID
///
///
/// returns:
/// animatorID에 해당하는 ShapeAnimator 객체. 존재하지 않을 경우 nil 리턴
- (ShapeAnimator * _Nullable)getShapeAnimatorWithAnimatorID:(NSString * _Nonnull)animatorID SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// SpriteGui Class
/// 기본적으로 main layout을 가지고 있으며, mainLayout에 GuiComponent를 활용하여 원하는 GUI를 구성한다.
SWIFT_CLASS("_TtC12KakaoMapsSDK9SpriteGui")
@interface SpriteGui : GuiBase
/// initializer
/// SpriteGui 생성시 별도로 지정하지 않으면 default layout은 vertical layout으로 지정된다.
/// \param name Gui 이름
///
- (nonnull instancetype)init:(NSString * _Nonnull)name OBJC_DESIGNATED_INITIALIZER;
/// mainLayout에 Child component를 추가한다.
/// \param component GuiComponent
///
- (void)addChild:(GuiComponentBase * _Nonnull)component;
/// mainLayout에 추가된 component 중 하나를 가져온다.
/// \param componentId GuiComponent Id
///
///
/// returns:
/// Id에 해당하는 GuiComponent. 없을경우 nil
- (GuiComponentBase * _Nullable)getChild:(NSString * _Nonnull)componentId SWIFT_WARN_UNUSED_RESULT;
/// mainLayout의 childComponent 배치 방향. Vertical 혹은 Horizontal
@property (nonatomic) LayoutArrangement arrangement;
/// main Layout에 Gui 컴포넌트의 구분선 표시 여부
@property (nonatomic) BOOL showSplitLine;
/// main Layout에 Gui 컴포넌트의 구분선 컬러
@property (nonatomic, strong) UIColor * _Nonnull splitLineColor;
/// main Layout에 Gui 컴포넌트의 구분선 두께
@property (nonatomic) NSInteger splitLineWidth;
/// mainLayout의 배경 컬러
@property (nonatomic, strong) UIColor * _Nonnull bgColor;
/// Gui의 main layout
@property (nonatomic, readonly, strong) GuiLayout * _Nonnull main;
/// Gui가 그려질 origin을 지정한다. 이 origin을 기준점으로 position이 적용된다.
/// 값을 세팅하면, 별도의 updateGui() 호출 없이도 바로 반영된다.
@property (nonatomic) struct GuiAlignment origin;
/// origin으로 부터의 Position을 지정한다.
/// 값을 세팅하면, 별도의 updateGui() 호출 없이도 바로 반영된다.
@property (nonatomic) CGPoint position;
/// SpriteGu를 회전시킬 orientation 값
/// 값을 세팅하면, 별도의 updateGui() 호출 없이도 바로 반영된다.
@property (nonatomic) double orientation;
@end


/// SpriteGuiLayer - 화면상에 고정되는 형태의 GUI 들을 담는 Layer
SWIFT_CLASS("_TtC12KakaoMapsSDK14SpriteGuiLayer")
@interface SpriteGuiLayer : NSObject
/// SpriteGuiLayer의 visible 상태.
/// layer의 on/off 상태를 나타내며, layer에 속한 객체의 show/hide는 별도로 동작시켜야한다.
/// 즉, layer의 visible이 true여도 layer에 속한 객체의 show를 호출해야 보이고, visible이 false라면 layer에 속한 객체는 화면에 표시되지 않는다.
@property (nonatomic) BOOL visible;
/// 추가한 모든 SpriteGui를 지운다.
- (void)clear;
/// SpriteGui를 현재 레이어에 추가한다.
/// SpriteGui를 레이어에 추가하기 전까지는 화면에 표시되지 않는다.
/// 같은 이름으로 중복으로 추가할 수 없다.
/// \param gui 추가할 SpriteGui 객체
///
- (void)addSpriteGui:(SpriteGui * _Nonnull)gui;
/// SpriteGui를 현재 레이어에서 제거한다.
/// \param gui 제거할 SpriteGui 객체
///
- (void)removeSpriteGui:(SpriteGui * _Nonnull)gui;
/// guiName을 Key로 갖는 SpriteGui를 현재 레이어에서 제거한다.
/// \param guiName 제거할 SpriteGui의 guiName
///
- (void)removeSpriteGuiWithGuiName:(NSString * _Nonnull)guiName;
/// SpriteGuiLayer에 추가되어있는 SpriteGui를 guiName을 Key로 가져온다.
/// \param guiName 가져올 SpriteGui의 guiName
///
///
/// returns:
/// 이름에 해당하는 SpriteGui. 없을경우 nil
- (SpriteGui * _Nullable)getSpriteGuiWithGuiName:(NSString * _Nonnull)guiName SWIFT_WARN_UNUSED_RESULT;
/// SpriteGuiLayer에 특정 guiName을 가진 SpriteGui가 존재하는지 체크한다.
/// \param guiName 추가되어있는지 확인할 SpriteGui guiName
///
///
/// returns:
/// 존재 여부. 이미 추가되어있는 guiName의 경우 true, 아니면 false를 리턴한다.
- (BOOL)isSpriteGuiExistWithGuiName:(NSString * _Nonnull)guiName SWIFT_WARN_UNUSED_RESULT;
/// SpriteGuiLayer에 추가한 모든 SpriteGui를 가져온다.
///
/// returns:
/// 추가된 모든 SpriteGui 객체 배열
- (NSArray<SpriteGui *> * _Nullable)getAllSpriteGuis SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// 글씨 색, 외곽선 색, 폰트 크기, 외곽선 두께 등의 스타일 속성을 지정하는 클래스.
SWIFT_CLASS("_TtC12KakaoMapsSDK9TextStyle")
@interface TextStyle : NSObject
/// Initializer
/// \param fontSize font 크기
///
/// \param fontColor font 컬러
///
/// \param strokeThickness font 외곽선 두께
///
/// \param strokeColor font 외곽선 색깔
///
/// \param font 사용할 font 이름
///
/// \param charSpace 자간. 0~4 사이값을 권장
///
/// \param lineSpace 행간
///
/// \param aspectRatio 장평
///
- (nonnull instancetype)initWithFontSize:(NSUInteger)fontSize fontColor:(UIColor * _Nonnull)fontColor strokeThickness:(NSUInteger)strokeThickness strokeColor:(UIColor * _Nonnull)strokeColor font:(NSString * _Nonnull)font charSpace:(NSInteger)charSpace lineSpace:(float)lineSpace aspectRatio:(float)aspectRatio OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param fontSize font 크기
///
/// \param fontColor font 컬러
///
- (nonnull instancetype)initWithFontSize:(NSUInteger)fontSize fontColor:(UIColor * _Nonnull)fontColor;
/// 글씨의 색
@property (nonatomic, readonly, strong) UIColor * _Nonnull fontColor;
/// 글씨 외곽선 색
@property (nonatomic, readonly, strong) UIColor * _Nonnull strokeColor;
/// 글씨 크기
@property (nonatomic, readonly) NSUInteger fontSize;
/// 글씨 외곽선의 두께
@property (nonatomic, readonly) NSUInteger strokeThickness;
/// 폰트
@property (nonatomic, readonly, copy) NSString * _Nonnull font;
/// 자간
@property (nonatomic, readonly) NSInteger charSpace;
/// 행간
@property (nonatomic, readonly) float lineSpace;
/// 장평
@property (nonatomic, readonly) float aspectRatio;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// KakaoMap 오브젝트의 tracking을 관리하는 클래스
/// 설정한 오브젝트의 position, orientation을 카메라가 따라간다.
/// 한번에 하나의 객체만 tracking 가능하며, tracking중에 다른 객체를 tracking하고자 할 경우 stop을 호출해야 다른 객체를 tracking 할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK15TrackingManager")
@interface TrackingManager : NSObject
/// 지정한 poi의 tracking을 시작한다.
/// \param poi tracking하고자하는 poi 객체
///
- (void)startTrackingPoi:(Poi * _Nonnull)poi;
/// 현재 tracking하고 있는 객체의 tracking을 멈춘다.
- (void)stopTracking;
/// 지정한 객체의 tracking을 위치만 추적할것인지,  객체 회전값도 추적할것인지를 지정한다.
/// 기본적으로 위치만 추적하며 true로 설정할 경우 객체의 회전값도 카메라가 tracking한다.
@property (nonatomic) BOOL isTrackingRoll;
/// 현재 tracking mode인지에 대한 여부.
/// 특정 obejct를 tracking하여 position및 orientation을 카메라가 따라가는중일경우, true 리턴.
/// 한번에 하나의 객체만 tracking할 수 있으므로 해당 값이 true일 경우 또 다른 객체를 트래킹 할 수 없다.
@property (nonatomic, readonly) BOOL isTracking;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class TransformAnimationKeyFrame;

/// AnimationEffect중 Animation 시간동안 지정된 Keyframe 에 따라 이동, 회전, 확대 변환을 수행하는 애니메이션 효과.
/// Poi에 적용할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK24TransformAnimationEffect")
@interface TransformAnimationEffect : KeyFrameAnimationEffect
/// Initializer
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// 애니메이션 키프레임을 추가한다.
/// \param frame 추가할 키프레임.
///
- (void)addKeyframe:(TransformAnimationKeyFrame * _Nonnull)frame;
@end


/// TransformAnimation 을 구성하기 위해 하나의 keyframe을 구성하기 위한 클래스
/// 회전, 확대축소, 이동 변환 및 투명도 값으로 구성된다.
SWIFT_CLASS("_TtC12KakaoMapsSDK26TransformAnimationKeyFrame")
@interface TransformAnimationKeyFrame : AnimationKeyFrame
/// Initializer
/// \param translation 이동할 픽셀단위값. 화면 scale 값이 곱해져서 적용됨.
///
/// \param rotation 회전 변환값. 시계 방향 radian 값.
///
/// \param scale 확대변환 값. 1.0 기준 확대축소값.
///
/// \param alpha 투명도 값. 0.0~1.0
///
/// \param interpolation 프레임 시간, 보간 방법.
///
- (nonnull instancetype)initWithTranslation:(struct Vector2)translation rotation:(float)rotation scale:(struct Vector2)scale alpha:(float)alpha interpolation:(struct AnimationInterpolation)interpolation OBJC_DESIGNATED_INITIALIZER;
/// 회전변환, 시계 방향 radian 값.
@property (nonatomic) float rotation;
/// 확대축소변환. 1.0 기준 확대값.
@property (nonatomic) struct Vector2 scale;
/// 픽셀 이동변환. 이동할 픽셀단위값. 화면 scale 값이 곱해져서 적용됨.
@property (nonatomic) struct Vector2 translation;
/// 투명도 값. 0.0~1.0
@property (nonatomic) float alpha;
@end




/// WaveAnimation에서 레벨별로 정의되는 속성.
SWIFT_CLASS("_TtC12KakaoMapsSDK17WaveAnimationData")
@interface WaveAnimationData : NSObject
/// Initializer
/// <ul>
///   <li>
///     parameters
///     <ul>
///       <li>
///         startAlpha: 애니메이션이 시작할 때 Shape의 알파값
///       </li>
///       <li>
///         endAlpha: 애니메이션이 끝날 때 Shape의 알파값
///       </li>
///       <li>
///         startRadius: 애니메이션이 시작할때 Shape의 스케일 값(px)
///       </li>
///       <li>
///         endRadius: 애니메이션이 끝날 때 Shape의 스케일 값(px)
///       </li>
///       <li>
///         level: 애니메이션이 적용될 레벨
///       </li>
///     </ul>
///   </li>
/// </ul>
- (nonnull instancetype)initWithStartAlpha:(float)startAlpha endAlpha:(float)endAlpha startRadius:(float)startRadius endRadius:(float)endRadius level:(NSInteger)level OBJC_DESIGNATED_INITIALIZER;
/// 애니메이션이 시작될때의 알파값
@property (nonatomic, readonly) float startAlpha;
/// 애니메이션이 끝날때의 알파값
@property (nonatomic, readonly) float endAlpha;
/// 애니메이션이 시작될때의 스케일
@property (nonatomic, readonly) float startRadius;
/// 애니메이션이 끝날때의 스케일
@property (nonatomic, readonly) float endRadius;
/// 애니메이션 적용 레벨
@property (nonatomic, readonly) NSInteger level;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// ShapeAnimationEffect중 Animation시간 동안 알파값과 크기(scale)을 변경하는 애니메이션 효과 클래스.
/// 레벨별로 시작/끝 알파값과 크기를 다르게 정의할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK19WaveAnimationEffect")
@interface WaveAnimationEffect : NSObject <ShapeAnimationEffect>
/// Initializer
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Initializer
/// \param datas WaveAnimationData 의 배열
///
- (nonnull instancetype)initWithDatas:(NSArray<WaveAnimationData *> * _Nonnull)datas OBJC_DESIGNATED_INITIALIZER;
/// WaveAnimation을 레벨별로 정의한다.
/// 레벨별로 애니메이션이 시작할 때, 끝날때의 알파값과 스케일(px)을 지정할 수 있다.
/// 정의에 따라 애니메이션 시간 동안 Shape의  Fade In/Out과 확대/축소 등을 정의할 수 있다.
/// \param startAlpha 애니메이션이 시작할 때 Shape의 알파값
///
/// \param endAlpha 애니메이션이 끝날 때 Shape의 알파값
///
/// \param startRadius 애니메이션이 시작할때 Shape의 스케일 값(px)
///
/// \param endRadius 애니메이션이 끝날 때 Shape의 스케일 값(px)
///
/// \param level 애니메이션이 적용될 레벨
///
- (void)addAnimationDataWithStartAlpha:(float)startAlpha endAlpha:(float)endAlpha startRadius:(float)startRadius endRadius:(float)endRadius level:(NSInteger)level;
/// 정의한 WaveAnimation Data
@property (nonatomic, readonly, copy) NSArray<WaveAnimationData *> * _Nonnull datas;
/// 애니메이션 지속 시간, 보간방법  지정
@property (nonatomic) struct AnimationInterpolation interpolation;
/// 애니메이션 재생 횟수.
@property (nonatomic) NSUInteger playCount;
/// 애니메이션 종료 시 애니메이터에 속한 객체들을 숨길지에 대한 여부.
/// true로 설정하면 애니메이션이 종료되면 객체들이 화면에서 자동으로 사라진다.
@property (nonatomic) BOOL hideAtStop;
@end


/// WaveText class
/// 지도상에 흐르는 글씨를 표현하기 위한 클래스. Poi는 한 점을 표시하기 위해 사용되고, WaveText는 지도상에 여러개의 점을 표시하기 위해 사용한다.
/// WaveText를 지도상에 추가하기 위해서는 먼저  KakaoMap에 LabelLayer를 추가한 뒤, 해당 Layer에 WaveText를 추가할 수 있다.
/// WaveText 객체는 사용자가 직접 생성할 수 없으며, WaveTextOptions Class를 이용하여 Layer에 추가하면 해당 Object를 얻을 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK8WaveText")
@interface WaveText : NSObject <Label>
/// WaveText를 보여준다.
- (void)show;
/// WaveText를 숨긴다.
- (void)hide;
/// WaveText의 Style을 바꾼다.
/// LabelManager에 등록한 WaveTextStyle의 키를 이용하여 Style을 변경한다.
/// \param styleID 변경할 Style의 ID
///
/// \param enableTransition 스타일 변경시 transition효과 적용 여부.
///
- (void)changeStyleWithStyleID:(NSString * _Nonnull)styleID enableTransition:(BOOL)enableTransition;
/// WaveText의 text와 Data를 바꾼다.
/// WaveText의 text와 style을 바꿀 때 사용한다.
/// \param text 바꾸고자 하는 WaveText의 text
///
/// \param styleID 변경할 styleID.
///
- (void)changeTextAndStyleWithText:(NSString * _Nonnull)text styleID:(NSString * _Nonnull)styleID;
/// WaveText가 추가된 ViewBase
@property (nonatomic, readonly, strong) ViewBase * _Nullable view;
/// WaveText가 속한 LayerID
@property (nonatomic, readonly, copy) NSString * _Nonnull layerID;
/// WaveText의 ID
@property (nonatomic, readonly, copy) NSString * _Nonnull itemID;
/// WaveText가 현재 뷰에 보여지고 있는지 여부
@property (nonatomic, readonly) BOOL isShow;
/// 사용자 객체
@property (nonatomic, strong) id _Nullable userObject;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// WaveText 생성 옵션 클래스
SWIFT_CLASS("_TtC12KakaoMapsSDK15WaveTextOptions")
@interface WaveTextOptions : NSObject
/// initializer
/// \param styleID 사용할 WaveTextStyle ID
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID OBJC_DESIGNATED_INITIALIZER;
/// initializer
/// \param styleID 사용할 WaveTextStyleID
///
/// \param waveTextID waveTextID 지정. 지정하지 않을 경우 자동으로 부여된다.
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID waveTextID:(NSString * _Nonnull)waveTextID OBJC_DESIGNATED_INITIALIZER;
/// WaveTextID. 지정하지 않을 경우 자동으로 부여된다.
@property (nonatomic, readonly, copy) NSString * _Nullable itemID;
/// WaveText의 styleID
@property (nonatomic, copy) NSString * _Nonnull styleID;
/// WaveText의 렌더링 우선순위
@property (nonatomic) NSUInteger rank;
/// WaveText의 text
@property (nonatomic, copy) NSString * _Nonnull text;
/// WaveText가 표시 될 points
@property (nonatomic, copy) NSArray<MapPoint *> * _Nullable points;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// WaveTextStyle을 지정하는 클래스.
/// WaveText를 레벨별로 다른 스타일로 표출하고 싶은 경우, PerLevelWaveTextStyle에 스타일 표출 레벨을 지정한 후 일종의 styleSet인 WaveTextStyle을 생성하여 사용한다.
/// LabelManager를 통해 Style을 등록한다. 등록된 style의 ID를 WaveText에 지정해주면, WaveText가 해당 스타일로 생성된다.
/// 혹은 등록된 styleID로 WaveText의 스타일을 변경할 수 있다.
SWIFT_CLASS("_TtC12KakaoMapsSDK13WaveTextStyle")
@interface WaveTextStyle : NSObject
/// initializer
/// \param styleID WaveTextStyle의 ID
///
/// \param styles WaveTextStyle을 구성할 단위레벨별 PerLevelWaveTextStyle 배열
///
- (nonnull instancetype)initWithStyleID:(NSString * _Nonnull)styleID styles:(NSArray<PerLevelWaveTextStyle *> * _Nonnull)styles OBJC_DESIGNATED_INITIALIZER;
/// 추가된 PerLevelWaveTextStyle
@property (nonatomic, readonly, copy) NSArray<PerLevelWaveTextStyle *> * _Nonnull styles;
/// WaveTextStyle ID
@property (nonatomic, readonly, copy) NSString * _Nonnull styleID;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
